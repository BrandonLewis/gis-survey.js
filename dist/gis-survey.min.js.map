{"version":3,"file":"gis-survey.min.js","sources":["../src/core/event-emitter.js","../src/core/CoordinateTransformer.js","../src/core/GeoidModel.js","../src/core/SimpleWGS84Transformer.js","../src/core/TransformerFactory.js","../src/core/Coordinate.js","../src/core/CoordinateUtils.js","../src/core/GeometryEngine.js","../src/core/index.js","../src/features/FeatureBase.js","../src/features/PointFeature.js","../src/features/LineFeature.js","../src/features/PolygonFeature.js","../src/features/FeatureCollection.js","../src/tools/ToolBase.js","../src/tools/MeasurementTool.js","../src/tools/OffsetTool.js","../src/tools/DrawingTool.js","../src/tools/EditingTool.js","../src/tools/SnappingManager.js","../src/tools/SurveyManager.js","../src/features/index.js","../src/map/MapInterface.js","../src/map/Map3DInterface.js","../src/map/ElevationService.js","../src/map/GoogleMapsAdapter.js","../src/map/LeafletAdapter.js","../src/map/GoogleMapsElevationService.js","../src/map/MapFactory.js","../src/map/rendering/RenderingStrategy.js","../src/map/rendering/GoogleMapsRenderingStrategy.js","../src/map/LayerManager.js","../src/map/index.js","../src/tools/SimplifiedDrawingTool.js","../src/index.js"],"sourcesContent":["/**\n * EventEmitter - Simple event system for component communication\n * \n * Independent copy for gis-survey.js module to avoid dependencies on gnss.js module\n */\nexport class EventEmitter {\n  constructor() {\n    this.events = {};\n    this.debugMode = false;\n  }\n\n  /**\n   * Subscribe to an event\n   * @param {string} event - Event name\n   * @param {Function} listener - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  on(event, listener) {\n    if (!this.events[event]) {\n      this.events[event] = [];\n    }\n    \n    this.events[event].push(listener);\n    \n    // Return unsubscribe function\n    return () => {\n      this.events[event] = this.events[event].filter(l => l !== listener);\n    };\n  }\n  \n  /**\n   * Modern DOM-style event subscription (alias for on)\n   * @param {string} event - Event name\n   * @param {Function} listener - Callback function\n   */\n  addEventListener(event, listener) {\n    return this.on(event, listener);\n  }\n\n  /**\n   * Subscribe to an event once\n   * @param {string} event - Event name\n   * @param {Function} listener - Callback function\n   */\n  once(event, listener) {\n    const remove = this.on(event, (...args) => {\n      remove();\n      listener(...args);\n    });\n  }\n\n  /**\n   * Emit an event with data\n   * @param {string} event - Event name\n   * @param {*} data - Event data\n   */\n  emit(event, data) {\n    if (this.debugMode) {\n      console.log(`[EventEmitter] ${event}:`, data);\n    }\n    \n    if (this.events[event]) {\n      this.events[event].forEach(listener => {\n        try {\n          listener(data);\n        } catch (error) {\n          console.error(`Error in event listener for '${event}':`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Remove a specific listener for an event\n   * @param {string} event - Event name\n   * @param {Function} listener - Callback function to remove\n   */\n  off(event, listener) {\n    if (this.events[event]) {\n      this.events[event] = this.events[event].filter(l => l !== listener);\n    }\n  }\n  \n  /**\n   * Modern DOM-style event unsubscription (alias for off)\n   * @param {string} event - Event name\n   * @param {Function} listener - Callback function to remove\n   */\n  removeEventListener(event, listener) {\n    return this.off(event, listener);\n  }\n  \n  /**\n   * Remove all listeners for an event\n   * @param {string} event - Event name\n   */\n  removeAllListeners(event) {\n    if (event) {\n      delete this.events[event];\n    } else {\n      this.events = {};\n    }\n  }\n\n  /**\n   * Enable/disable debug mode\n   * @param {boolean} enabled - Whether debug mode is enabled\n   */\n  setDebug(enabled) {\n    this.debugMode = enabled;\n  }\n}\n\n// For backward compatibility\nexport default EventEmitter;","/**\n * CoordinateTransformer.js - Abstract interface for coordinate transformations\n * \n * Defines the interface that all coordinate transformers must implement.\n * This allows for swapping transformer implementations (simple vs. proj4js)\n * while maintaining consistent functionality.\n */\n\nimport { Coordinate } from './Coordinate.js';\n\n/**\n * Abstract base class for coordinate transformations.\n */\nexport class CoordinateTransformer {\n  /**\n   * Creates a new coordinate transformer.\n   * @throws {Error} If instantiated directly (abstract class)\n   */\n  constructor() {\n    if (this.constructor === CoordinateTransformer) {\n      throw new Error('CoordinateTransformer is an abstract class and cannot be instantiated directly');\n    }\n    \n    // Initialize cache for performance\n    this._transformCache = new Map();\n    this._geoidCache = new Map();\n    this._datelineHandled = false;\n  }\n  \n  /**\n   * Transform a coordinate from one projection to another.\n   * @param {Coordinate} coordinate - The coordinate to transform\n   * @param {string} fromProjection - Source projection\n   * @param {string} toProjection - Target projection\n   * @returns {Coordinate} A new coordinate in the target projection\n   * @throws {Error} Must be implemented by subclasses\n   */\n  transform(_coordinate, _fromProjection, _toProjection) {\n    throw new Error('Method transform() must be implemented by subclasses');\n  }\n  \n  /**\n   * Get list of supported projections.\n   * @returns {string[]} Array of supported projection identifiers\n   * @throws {Error} Must be implemented by subclasses\n   */\n  getSupportedProjections() {\n    throw new Error('Method getSupportedProjections() must be implemented by subclasses');\n  }\n  \n  /**\n   * Convert ellipsoidal height to orthometric height (from WGS84 ellipsoid to mean sea level).\n   * @param {Coordinate} coordinate - Coordinate with ellipsoidal height\n   * @returns {Coordinate} New coordinate with orthometric height\n   * @throws {Error} Must be implemented by subclasses\n   */\n  convertEllipsoidalToOrthometric(_coordinate) {\n    throw new Error('Method convertEllipsoidalToOrthometric() must be implemented by subclasses');\n  }\n  \n  /**\n   * Convert orthometric height to ellipsoidal height (from mean sea level to WGS84 ellipsoid).\n   * @param {Coordinate} coordinate - Coordinate with orthometric height\n   * @returns {Coordinate} New coordinate with ellipsoidal height\n   * @throws {Error} Must be implemented by subclasses\n   */\n  convertOrthometricToEllipsoidal(_coordinate) {\n    throw new Error('Method convertOrthometricToEllipsoidal() must be implemented by subclasses');\n  }\n  \n  /**\n   * Clear the internal transformation cache.\n   */\n  clearCache() {\n    this._transformCache.clear();\n    this._geoidCache.clear();\n  }\n  \n  /**\n   * Check if a coordinate crosses the international date line during transformation.\n   * @param {Coordinate} coordinate - The coordinate to check\n   * @param {string} fromProjection - Source projection\n   * @param {string} toProjection - Target projection\n   * @returns {boolean} True if the transformation crosses the date line\n   * @protected\n   */\n  _crossesDateLine(_coordinate, _fromProjection, _toProjection) {\n    // Simplistic date line crossing detection\n    // For more complex cases, subclasses should override this method\n    if (Math.abs(_coordinate.lng) > 170) {\n      // Near the date line, we might cross during transformation\n      return true;\n    }\n    return false;\n  }\n  \n  /**\n   * Generate a unique cache key for a transformation.\n   * @param {Coordinate} coordinate - The coordinate to transform\n   * @param {string} fromProjection - Source projection\n   * @param {string} toProjection - Target projection \n   * @returns {string} Cache key\n   * @protected\n   */\n  _getCacheKey(coordinate, fromProjection, toProjection) {\n    // Use precision that is high enough for our needs but allows caching\n    const lat = coordinate.lat.toFixed(9);\n    const lng = coordinate.lng.toFixed(9);\n    const elev = coordinate.elevation.toFixed(3);\n    \n    return `${lat}:${lng}:${elev}:${fromProjection}:${toProjection}`;\n  }\n  \n  /**\n   * Handle date line crossing in transformations.\n   * @param {Coordinate} coordinate - The coordinate to transform\n   * @param {string} fromProjection - Source projection\n   * @param {string} toProjection - Target projection\n   * @returns {Coordinate} Transformed coordinate\n   * @protected\n   */\n  _handleDateLineCrossing(coordinate, fromProjection, toProjection) {\n    // Prevent recursive handling\n    if (this._datelineHandled) {\n      this._datelineHandled = false;\n      return this._doTransform(coordinate, fromProjection, toProjection);\n    }\n    \n    this._datelineHandled = true;\n    \n    // Adjust longitude to avoid the date line\n    let adjustedCoord;\n    if (coordinate.lng > 0) {\n      // Adjust western hemisphere coordinates\n      adjustedCoord = new Coordinate(\n        coordinate.lat,\n        coordinate.lng - 360, // Shift to equivalent position without crossing date line\n        coordinate.elevation,\n        coordinate.heightReference,\n        fromProjection,\n      );\n    } else {\n      // Adjust eastern hemisphere coordinates\n      adjustedCoord = new Coordinate(\n        coordinate.lat,\n        coordinate.lng + 360, // Shift to equivalent position without crossing date line\n        coordinate.elevation,\n        coordinate.heightReference,\n        fromProjection,\n      );\n    }\n    \n    // Transform with adjusted coordinates\n    const transformed = this.transform(adjustedCoord, fromProjection, toProjection);\n    \n    // Restore to proper hemisphere\n    if (transformed.lng < -180) {\n      transformed.lng += 360;\n    } else if (transformed.lng > 180) {\n      transformed.lng -= 360;\n    }\n    \n    this._datelineHandled = false;\n    return transformed;\n  }\n  \n  /**\n   * Log transformation errors with context.\n   * @param {Error} error - The error that occurred\n   * @param {Coordinate} coordinate - The coordinate being transformed\n   * @param {string} fromProjection - Source projection\n   * @param {string} toProjection - Target projection\n   * @protected\n   */\n  _logTransformationError(error, coordinate, fromProjection, toProjection) {\n    console.error(`Transformation error: ${error.message}`, {\n      source: {\n        projection: fromProjection,\n        lat: coordinate.lat,\n        lng: coordinate.lng,\n        elev: coordinate.elevation,\n      },\n      target: toProjection,\n      error: error.stack,\n    });\n  }\n}","/**\n * GeoidModel.js - Model for converting between height reference systems\n * \n * Provides geoid height (separation between ellipsoid and orthometric height)\n * calculations for converting between ellipsoidal heights (GPS) and\n * orthometric heights (mean sea level).\n */\n\n/**\n * Static class that provides geoid height information.\n * \n * In a full implementation, this would load and interpolate from a geoid model\n * grid file (like GEOID18 for the USA). For this implementation, we'll use a\n * simplified, approximate model for demonstration purposes.\n */\nexport class GeoidModel {\n  /**\n   * Get the geoid height (separation between ellipsoid and geoid) at a location.\n   * Positive value means the geoid is above the ellipsoid.\n   * \n   * @param {number} lat - Latitude in decimal degrees\n   * @param {number} lng - Longitude in decimal degrees\n   * @returns {number} Geoid height in meters\n   */\n  static getHeight(lat, lng) {\n    // This is a simplified model for demonstration\n    // In a real application, this would load and interpolate from a grid file\n    // like GEOID18, EGM2008, etc.\n    \n    // For North America, a very simplified approximation\n    // Values generally range from -8m to -40m in North America\n    \n    // Check bounds\n    if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {\n      throw new Error(`Invalid coordinates: ${lat}, ${lng}`);\n    }\n    \n    // For areas in the continental US, use a simple bilinear approximation\n    if (lat >= 24 && lat <= 50 && lng >= -125 && lng <= -66) {\n      return this._approximateUSGeoidHeight(lat, lng);\n    }\n    \n    // Basic approximation with latitude as the primary driver\n    let height = 0;\n    \n    // Higher values in the south (more separation)\n    // Lower values in the north (less separation)\n    // Based on EGM2008 very generalized trends\n    if (lat >= 0 && lat <= 90) { // Northern hemisphere\n      height = -30 + (lat / 90) * 15; // Range from ~ -30 to -15 meters\n    } else { // Southern hemisphere\n      height = -30 + (lat / -90) * 15; // Range from ~ -30 to -15 meters\n    }\n    \n    // Add some longitude influence (rough approximation)\n    const lngFactor = Math.sin((lng + 100) * Math.PI / 180) * 5; // ±5m variation\n    height += lngFactor;\n    \n    return height;\n  }\n  \n  /**\n   * More detailed approximation for the continental United States.\n   * @param {number} lat - Latitude in decimal degrees\n   * @param {number} lng - Longitude in decimal degrees\n   * @returns {number} Approximate geoid height in meters\n   * @private\n   */\n  static _approximateUSGeoidHeight(lat, lng) {\n    // These would be replaced with proper grid interpolation in a real implementation\n    // Corners of a simplified geoid model for the continental US\n    const corners = [\n      { lat: 24, lng: -125, height: -32.5 }, // Southwest\n      { lat: 24, lng: -66, height: -29.5 },  // Southeast\n      { lat: 50, lng: -125, height: -22.5 }, // Northwest\n      { lat: 50, lng: -66, height: -34.0 },   // Northeast\n    ];\n    \n    // Normalize coordinates to 0-1 range within the grid\n    const normalizedLat = (lat - 24) / (50 - 24);\n    const normalizedLng = (lng - (-125)) / ((-66) - (-125));\n    \n    // Bilinear interpolation\n    const h1 = corners[0].height * (1 - normalizedLng) + corners[1].height * normalizedLng;\n    const h2 = corners[2].height * (1 - normalizedLng) + corners[3].height * normalizedLng;\n    \n    const geoidHeight = h1 * (1 - normalizedLat) + h2 * normalizedLat;\n    \n    // Add some local variation (simplified)\n    const localVariation = Math.sin(lat * 8) * Math.sin(lng * 6) * 2.5;\n    \n    return geoidHeight + localVariation;\n  }\n  \n  /**\n   * Load a geoid model grid file.\n   * This would be implemented in a full version of the library.\n   * \n   * @param {string} modelName - Name of the geoid model to load\n   * @returns {Promise<boolean>} Promise that resolves when the model is loaded\n   */\n  static async loadModel(modelName) {\n    console.warn(`GeoidModel.loadModel: ${modelName} not implemented. Using approximation.`);\n    return Promise.resolve(false);\n  }\n}","/**\n * SimpleWGS84Transformer.js - Implementation focused on WGS84 and common North American projections\n * \n * This implementation focuses on common North American coordinate systems used by\n * civil contractors, while being lightweight and efficient. It provides a simplified\n * set of transformations without requiring the full proj4js library.\n */\n\nimport { CoordinateTransformer } from './CoordinateTransformer.js';\nimport { Coordinate } from './Coordinate.js';\nimport { GeoidModel } from './GeoidModel.js';\n\n/**\n * Simple WGS84-focused coordinate transformer.\n * Supports common North American datums and projections.\n */\nexport class SimpleWGS84Transformer extends CoordinateTransformer {\n  /**\n   * Create a new SimpleWGS84Transformer.\n   */\n  constructor() {\n    super();\n    \n    // Define supported projections with parameters\n    this.projections = {\n      'WGS84': { // Standard GPS coordinates (EPSG:4326)\n        datum: 'WGS84',\n        type: 'geographic',\n        epsg: '4326',\n        params: {},\n      },\n      'NAD83': { // North American Datum 1983\n        datum: 'NAD83',\n        type: 'geographic',\n        epsg: '4269',\n        params: {},\n      },\n      'NAD27': { // North American Datum 1927\n        datum: 'NAD27',\n        type: 'geographic',\n        epsg: '4267',\n        params: {},\n      },\n      'UTM_NAD83_N': { // UTM North zones with NAD83 datum\n        datum: 'NAD83',\n        type: 'utm',\n        params: { north: true },\n      },\n      'UTM_NAD83_S': { // UTM South zones with NAD83 datum\n        datum: 'NAD83',\n        type: 'utm',\n        params: { north: false },\n      },\n      'StatePlane_NAD83': { // State Plane with NAD83 datum\n        datum: 'NAD83',\n        type: 'stateplane',\n        params: {},\n      },\n    };\n    \n    // Datum shift parameters\n    this.datumShifts = {\n      'WGS84_to_NAD83': { // Very minor shift for most applications\n        dx: 0.99343, // meters\n        dy: -1.90331, // meters\n        dz: -0.52655, // meters\n        rx: 0.025915, // arcseconds\n        ry: 0.009426, // arcseconds\n        rz: 0.011599, // arcseconds\n        ds: -0.00062,  // parts per million\n      },\n      'NAD83_to_NAD27': {\n        // Parameters vary by region - simplification\n        // This is a rough approximation - real transformations use grid files\n        dx: -8.0, // meters\n        dy: 160.0, // meters\n        dz: 176.0, // meters\n      },\n    };\n  }\n  \n  /**\n   * Get list of supported projections.\n   * @returns {string[]} Array of supported projection identifiers\n   */\n  getSupportedProjections() {\n    return Object.keys(this.projections);\n  }\n  \n  /**\n   * Transform a coordinate from one projection to another.\n   * @param {Coordinate} coordinate - The coordinate to transform\n   * @param {string} fromProjection - Source projection\n   * @param {string} toProjection - Target projection\n   * @returns {Coordinate} A new coordinate in the target projection\n   * @throws {Error} If projections are not supported\n   */\n  transform(coordinate, fromProjection, toProjection) {\n    // Validate inputs\n    this._validateProjection(fromProjection);\n    this._validateProjection(toProjection);\n    \n    // If same projection, return a copy\n    if (fromProjection === toProjection) {\n      return coordinate.clone();\n    }\n    \n    // Check for cached result\n    const cacheKey = this._getCacheKey(coordinate, fromProjection, toProjection);\n    const cached = this._transformCache.get(cacheKey);\n    if (cached) {\n      return cached;\n    }\n    \n    // Handle date line crossing\n    if (this._crossesDateLine(coordinate, fromProjection, toProjection)) {\n      return this._handleDateLineCrossing(coordinate, fromProjection, toProjection);\n    }\n    \n    // Transform the coordinate\n    let result;\n    \n    try {\n      // First convert to geographic coordinates (lat/lon) on source datum if needed\n      let geographicSource;\n      if (this.projections[fromProjection].type === 'geographic') {\n        geographicSource = coordinate.clone();\n      } else if (this.projections[fromProjection].type === 'utm') {\n        geographicSource = this._utmToGeographic(coordinate, this.projections[fromProjection].params);\n      } else if (this.projections[fromProjection].type === 'stateplane') {\n        geographicSource = this._statePlaneToGeographic(coordinate);\n      } else {\n        throw new Error(`Unsupported projection type: ${this.projections[fromProjection].type}`);\n      }\n      \n      // Then transform between datums if needed\n      let geographicTarget;\n      const sourceDatum = this.projections[fromProjection].datum;\n      const targetDatum = this.projections[toProjection].datum;\n      \n      if (sourceDatum === targetDatum) {\n        geographicTarget = geographicSource;\n      } else {\n        geographicTarget = this._transformDatum(geographicSource, sourceDatum, targetDatum);\n      }\n      \n      // Finally convert to target projection system if needed\n      if (this.projections[toProjection].type === 'geographic') {\n        result = geographicTarget.clone();\n        result.projection = toProjection;\n      } else if (this.projections[toProjection].type === 'utm') {\n        result = this._geographicToUtm(geographicTarget, this.projections[toProjection].params);\n        result.projection = toProjection;\n      } else if (this.projections[toProjection].type === 'stateplane') {\n        result = this._geographicToStatePlane(geographicTarget);\n        result.projection = toProjection;\n      } else {\n        throw new Error(`Unsupported projection type: ${this.projections[toProjection].type}`);\n      }\n      \n      // Cache the result\n      this._transformCache.set(cacheKey, result);\n      \n      return result;\n    } catch (error) {\n      this._logTransformationError(error, coordinate, fromProjection, toProjection);\n      throw new Error(`Transformation failed from ${fromProjection} to ${toProjection}: ${error.message}`);\n    }\n  }\n  \n  /**\n   * Convert ellipsoidal height to orthometric height.\n   * @param {Coordinate} coordinate - Coordinate with ellipsoidal height\n   * @returns {Coordinate} New coordinate with orthometric height\n   */\n  convertEllipsoidalToOrthometric(coordinate) {\n    const geoidHeight = this._getGeoidHeight(coordinate.lat, coordinate.lng);\n    \n    return new Coordinate(\n      coordinate.lat,\n      coordinate.lng,\n      coordinate.elevation - geoidHeight,\n      'orthometric',\n      coordinate.projection,\n    );\n  }\n  \n  /**\n   * Convert orthometric height to ellipsoidal height.\n   * @param {Coordinate} coordinate - Coordinate with orthometric height\n   * @returns {Coordinate} New coordinate with ellipsoidal height\n   */\n  convertOrthometricToEllipsoidal(coordinate) {\n    const geoidHeight = this._getGeoidHeight(coordinate.lat, coordinate.lng);\n    \n    return new Coordinate(\n      coordinate.lat,\n      coordinate.lng,\n      coordinate.elevation + geoidHeight,\n      'ellipsoidal',\n      coordinate.projection,\n    );\n  }\n  \n  /**\n   * Get the geoid height (separation between ellipsoid and geoid) at a location.\n   * @param {number} lat - Latitude in decimal degrees\n   * @param {number} lng - Longitude in decimal degrees\n   * @returns {number} Geoid height in meters\n   * @private\n   */\n  _getGeoidHeight(lat, lng) {\n    // Check cache first\n    const cacheKey = `${lat.toFixed(4)}:${lng.toFixed(4)}`;\n    const cached = this._geoidCache.get(cacheKey);\n    if (cached !== undefined) {\n      return cached;\n    }\n    \n    // Use the GeoidModel to get the height\n    const geoidHeight = GeoidModel.getHeight(lat, lng);\n    \n    // Cache the result\n    this._geoidCache.set(cacheKey, geoidHeight);\n    \n    return geoidHeight;\n  }\n  \n  /**\n   * Validate that a projection is supported.\n   * @param {string} projection - Projection identifier\n   * @throws {Error} If projection is not supported\n   * @private\n   */\n  _validateProjection(projection) {\n    if (!this.projections[projection]) {\n      throw new Error(`Unsupported projection: ${projection}. Supported projections are: ${this.getSupportedProjections().join(', ')}`);\n    }\n  }\n  \n  /**\n   * Transform coordinates between datums.\n   * @param {Coordinate} coordinate - Geographic coordinate to transform\n   * @param {string} fromDatum - Source datum\n   * @param {string} toDatum - Target datum\n   * @returns {Coordinate} Transformed coordinate\n   * @private\n   */\n  _transformDatum(coordinate, fromDatum, toDatum) {\n    if (fromDatum === toDatum) {\n      return coordinate.clone();\n    }\n    \n    // We'll use Helmert transformation for datum shifts\n    if (fromDatum === 'WGS84' && toDatum === 'NAD83') {\n      return this._applyHelmertTransformation(coordinate, this.datumShifts.WGS84_to_NAD83);\n    }\n    \n    if (fromDatum === 'NAD83' && toDatum === 'WGS84') {\n      return this._applyHelmertTransformation(coordinate, this._invertHelmertParams(this.datumShifts.WGS84_to_NAD83));\n    }\n    \n    if (fromDatum === 'NAD83' && toDatum === 'NAD27') {\n      return this._applyHelmertTransformation(coordinate, this.datumShifts.NAD83_to_NAD27);\n    }\n    \n    if (fromDatum === 'NAD27' && toDatum === 'NAD83') {\n      return this._applyHelmertTransformation(coordinate, this._invertHelmertParams(this.datumShifts.NAD83_to_NAD27));\n    }\n    \n    if (fromDatum === 'WGS84' && toDatum === 'NAD27') {\n      // Transform in two steps: WGS84 -> NAD83 -> NAD27\n      const nad83 = this._transformDatum(coordinate, 'WGS84', 'NAD83');\n      return this._transformDatum(nad83, 'NAD83', 'NAD27');\n    }\n    \n    if (fromDatum === 'NAD27' && toDatum === 'WGS84') {\n      // Transform in two steps: NAD27 -> NAD83 -> WGS84\n      const nad83 = this._transformDatum(coordinate, 'NAD27', 'NAD83');\n      return this._transformDatum(nad83, 'NAD83', 'WGS84');\n    }\n    \n    throw new Error(`Unsupported datum transformation: ${fromDatum} to ${toDatum}`);\n  }\n  \n  /**\n   * Apply Helmert transformation parameters.\n   * @param {Coordinate} coordinate - Geographic coordinate to transform\n   * @param {Object} params - Helmert transformation parameters\n   * @returns {Coordinate} Transformed coordinate\n   * @private\n   */\n  _applyHelmertTransformation(coordinate, params) {\n    // Convert lat/lon to 3D Cartesian coordinates (ECEF)\n    const ecef = this._geographicToECEF(coordinate);\n    \n    // Apply the 7-parameter Helmert transformation\n    const dx = params.dx || 0;\n    const dy = params.dy || 0;\n    const dz = params.dz || 0;\n    const rx = (params.rx || 0) * Math.PI / (180 * 3600); // arcseconds to radians\n    const ry = (params.ry || 0) * Math.PI / (180 * 3600);\n    const rz = (params.rz || 0) * Math.PI / (180 * 3600);\n    const ds = (params.ds || 0) / 1000000; // ppm to scale factor\n    \n    const x2 = (1 + ds) * (ecef.x + rz * ecef.y - ry * ecef.z) + dx;\n    const y2 = (1 + ds) * (-rz * ecef.x + ecef.y + rx * ecef.z) + dy;\n    const z2 = (1 + ds) * (ry * ecef.x - rx * ecef.y + ecef.z) + dz;\n    \n    // Convert back to geographic coordinates\n    return this._ecefToGeographic({ x: x2, y: y2, z: z2 }, coordinate.heightReference);\n  }\n  \n  /**\n   * Invert Helmert transformation parameters.\n   * @param {Object} params - Helmert transformation parameters\n   * @returns {Object} Inverted parameters\n   * @private\n   */\n  _invertHelmertParams(params) {\n    return {\n      dx: -(params.dx || 0),\n      dy: -(params.dy || 0),\n      dz: -(params.dz || 0),\n      rx: -(params.rx || 0),\n      ry: -(params.ry || 0),\n      rz: -(params.rz || 0),\n      ds: -(params.ds || 0),\n    };\n  }\n  \n  /**\n   * Convert geographic coordinates to ECEF (Earth-Centered, Earth-Fixed) coordinates.\n   * @param {Coordinate} coordinate - Geographic coordinate\n   * @returns {Object} ECEF coordinates { x, y, z }\n   * @private\n   */\n  _geographicToECEF(coordinate) {\n    const a = 6378137.0; // WGS84 semi-major axis in meters\n    const e2 = 0.00669437999014; // WGS84 first eccentricity squared\n    \n    // Handle different coordinate formats\n    const lat = coordinate.lat !== undefined ? coordinate.lat : coordinate.y;\n    const lng = coordinate.lng !== undefined ? coordinate.lng : coordinate.x;\n    const elevation = coordinate.elevation !== undefined ? coordinate.elevation : \n      (coordinate.z !== undefined ? coordinate.z : 0);\n    \n    // Validate coordinate values\n    if (lat === undefined || lng === undefined) {\n      throw new Error('Invalid coordinate: missing latitude or longitude');\n    }\n    \n    const φ = lat * Math.PI / 180; // latitude in radians\n    const λ = lng * Math.PI / 180; // longitude in radians\n    const h = elevation; // height above ellipsoid in meters\n    \n    const sinφ = Math.sin(φ);\n    const cosφ = Math.cos(φ);\n    const sinλ = Math.sin(λ);\n    const cosλ = Math.cos(λ);\n    \n    const N = a / Math.sqrt(1 - e2 * sinφ * sinφ); // radius of curvature in the prime vertical\n    \n    const x = (N + h) * cosφ * cosλ;\n    const y = (N + h) * cosφ * sinλ;\n    const z = (N * (1 - e2) + h) * sinφ;\n    \n    // Return in standard format plus original names for compatibility\n    return {\n      x, y, z,\n      lat, lng, elevation,\n      originalFormat: 'geographic',\n    };\n  }\n  \n  /**\n   * Convert ECEF coordinates to geographic coordinates.\n   * @param {Object} ecef - ECEF coordinates { x, y, z }\n   * @param {string} heightReference - Height reference system\n   * @returns {Coordinate} Geographic coordinate\n   * @private\n   */\n  _ecefToGeographic(ecef, heightReference) {\n    const a = 6378137.0; // WGS84 semi-major axis in meters\n    const e2 = 0.00669437999014; // WGS84 first eccentricity squared\n    const b = a * Math.sqrt(1 - e2); // semi-minor axis\n    \n    // Handle different coordinate formats if ECEF comes from different sources\n    const x = ecef.x;\n    const y = ecef.y;\n    const z = ecef.z;\n    \n    // Validate ECEF values\n    if (x === undefined || y === undefined || z === undefined) {\n      throw new Error('Invalid ECEF coordinate: missing x, y, or z component');\n    }\n    \n    const p = Math.sqrt(x*x + y*y); // distance from Z axis\n    const θ = Math.atan2(z * a, p * b); // parametric latitude\n    \n    const sinθ = Math.sin(θ);\n    const cosθ = Math.cos(θ);\n    \n    const φ = Math.atan2(\n      z + e2 * b * sinθ * sinθ * sinθ,\n      p - e2 * a * cosθ * cosθ * cosθ,\n    ); // latitude\n    \n    const λ = Math.atan2(y, x); // longitude\n    \n    const sinφ = Math.sin(φ);\n    const N = a / Math.sqrt(1 - e2 * sinφ * sinφ); // radius of curvature\n    \n    const h = p / Math.cos(φ) - N; // height above ellipsoid\n    \n    const lat = φ * 180 / Math.PI;\n    const lng = λ * 180 / Math.PI;\n    \n    // Create a new Coordinate using the standard format (lat, lng, elevation)\n    return new Coordinate(lat, lng, h, heightReference);\n  }\n  \n  /**\n   * Convert UTM coordinates to geographic coordinates.\n   * @param {Coordinate} coordinate - UTM coordinate\n   * @param {Object} params - UTM parameters including zone and hemisphere\n   * @returns {Coordinate} Geographic coordinate\n   * @private\n   */\n  _utmToGeographic(_coordinate, _params) {\n    // This would be a full implementation of the UTM to geographic conversion\n    // For simplicity, we'll provide a stub implementation - in production code\n    // this would use the full UTM conversion formulas\n    \n    // For demo purposes, we'll convert a fixed UTM coordinate\n    // In a real implementation, this would be determined from the coordinate's properties\n    // such as the UTM easting, northing, zone, and hemisphere\n    \n    throw new Error('UTM to Geographic conversion not fully implemented in SimpleWGS84Transformer');\n  }\n  \n  /**\n   * Convert geographic coordinates to UTM coordinates.\n   * @param {Coordinate} coordinate - Geographic coordinate\n   * @param {Object} params - UTM parameters including hemisphere\n   * @returns {Coordinate} UTM coordinate\n   * @private\n   */\n  _geographicToUtm(_coordinate, _params) {\n    // This would be a full implementation of the geographic to UTM conversion\n    // For simplicity, we'll provide a stub implementation - in production code\n    // this would use the full UTM conversion formulas\n    \n    throw new Error('Geographic to UTM conversion not fully implemented in SimpleWGS84Transformer');\n  }\n  \n  /**\n   * Convert State Plane coordinates to geographic coordinates.\n   * @param {Coordinate} coordinate - State Plane coordinate\n   * @returns {Coordinate} Geographic coordinate\n   * @private\n   */\n  _statePlaneToGeographic(_coordinate) {\n    // This would be a full implementation of the State Plane to geographic conversion\n    // For simplicity, we'll provide a stub implementation - in production code\n    // this would use the full State Plane conversion formulas for each state zone\n    \n    throw new Error('State Plane to Geographic conversion not fully implemented in SimpleWGS84Transformer');\n  }\n  \n  /**\n   * Convert geographic coordinates to State Plane coordinates.\n   * @param {Coordinate} coordinate - Geographic coordinate\n   * @returns {Coordinate} State Plane coordinate\n   * @private\n   */\n  _geographicToStatePlane(_coordinate) {\n    // This would be a full implementation of the geographic to State Plane conversion\n    // For simplicity, we'll provide a stub implementation - in production code\n    // this would use the full State Plane conversion formulas for each state zone\n    \n    throw new Error('Geographic to State Plane conversion not fully implemented in SimpleWGS84Transformer');\n  }\n}","/**\n * TransformerFactory.js - Factory for coordinate transformation providers\n * \n * Provides a central point for creating and accessing CoordinateTransformer \n * implementations. This factory pattern allows for switching transformer \n * implementations without changing client code.\n */\n\nimport { SimpleWGS84Transformer } from './SimpleWGS84Transformer.js';\n\n/**\n * Factory class for creating and accessing coordinate transformers.\n */\nexport class TransformerFactory {\n  // Static singleton instances for different transformer types\n  static _instances = new Map();\n  \n  // Selected transformer type\n  static _defaultType = 'simple';\n  \n  /**\n   * Set the default transformer type to use.\n   * @param {string} type - The transformer type ('simple' or 'proj4js')\n   */\n  static setDefaultType(type) {\n    if (!['simple', 'proj4js'].includes(type)) {\n      throw new Error(`Invalid transformer type: ${type}. Must be 'simple' or 'proj4js'`);\n    }\n    \n    this._defaultType = type;\n  }\n  \n  /**\n   * Get a transformer instance.\n   * @param {string} [type=null] - The transformer type to get, or null for default\n   * @returns {CoordinateTransformer} A coordinate transformer\n   */\n  static getTransformer(type = null) {\n    const transformerType = type || this._defaultType;\n    \n    // Check if we already have an instance\n    if (this._instances.has(transformerType)) {\n      return this._instances.get(transformerType);\n    }\n    \n    // Create a new instance\n    let transformer;\n    \n    switch (transformerType) {\n    case 'simple':\n      transformer = new SimpleWGS84Transformer();\n      break;\n        \n    case 'proj4js':\n      // Try to load proj4js if available\n      this._checkForProj4js();\n        \n      // We'll implement this when needed\n      throw new Error('Proj4js transformer not yet implemented. Use \"simple\" for now.');\n        \n    default:\n      throw new Error(`Unknown transformer type: ${transformerType}`);\n    }\n    \n    // Cache the instance\n    this._instances.set(transformerType, transformer);\n    \n    return transformer;\n  }\n  \n  /**\n   * Check if proj4js is available and log warning if not.\n   * @private\n   */\n  static _checkForProj4js() {\n    // Check if proj4js is available\n    if (typeof proj4 === 'undefined') {\n      console.warn('Proj4js transformer requested, but proj4js is not loaded. ' + \n                 'Make sure to include proj4.js in your project for full projection support.');\n      return false;\n    }\n    return true;\n  }\n  \n  /**\n   * Clear all cached transformer instances.\n   */\n  static clearCache() {\n    // Clear all transformer instances\n    for (const transformer of this._instances.values()) {\n      transformer.clearCache();\n    }\n    \n    this._instances.clear();\n  }\n  \n  /**\n   * Check if a certain transformer type is available.\n   * @param {string} type - The transformer type to check\n   * @returns {boolean} Whether the transformer is available\n   */\n  static isAvailable(type) {\n    switch (type) {\n    case 'simple':\n      return true;\n        \n    case 'proj4js':\n      return this._checkForProj4js();\n        \n    default:\n      return false;\n    }\n  }\n  \n  /**\n   * Get a list of all supported projection systems across all transformers.\n   * @returns {Object} Object mapping transformer type to array of supported projections\n   */\n  static getAllSupportedProjections() {\n    const result = {};\n    \n    // Always include simple transformer\n    result.simple = new SimpleWGS84Transformer().getSupportedProjections();\n    \n    // Check if proj4js is available\n    if (this._checkForProj4js()) {\n      // This would return a list of all projections supported by proj4js\n      // We'll implement this when needed\n      result.proj4js = ['Many EPSG codes supported when proj4js is loaded'];\n    }\n    \n    return result;\n  }\n}","/**\n * Coordinate.js - 3D Geographic Coordinate class\n * \n * Represents a point in 3D space using latitude, longitude, and elevation.\n * Supports different height references and projections, with transformation\n * functionality through a pluggable transformer system.\n */\n\nimport { TransformerFactory } from './TransformerFactory.js';\n\n/**\n * Class representing a geographic 3D coordinate.\n */\nexport class Coordinate {\n  /**\n   * Create a new coordinate.\n   * @param {number} lat - Latitude in decimal degrees\n   * @param {number} lng - Longitude in decimal degrees\n   * @param {number} [elevation=0] - Elevation in meters\n   * @param {string} [heightReference='ellipsoidal'] - Height reference system ('ellipsoidal' or 'orthometric')\n   * @param {string} [projection='WGS84'] - Coordinate projection system\n   */\n  constructor(lat, lng, elevation = 0, heightReference = 'ellipsoidal', projection = 'WGS84') {\n    try {\n      // Handle different input formats and parsing\n      if (typeof lat === 'string') lat = parseFloat(lat);\n      if (typeof lng === 'string') lng = parseFloat(lng);\n      if (typeof elevation === 'string') elevation = parseFloat(elevation);\n      \n      // Handle null/undefined/NaN latitude/longitude more gracefully with defaults\n      if (lat === null || lat === undefined || isNaN(lat)) {\n        console.warn('Invalid latitude provided, defaulting to 0');\n        lat = 0;\n      }\n      \n      if (lng === null || lng === undefined || isNaN(lng)) {\n        console.warn('Invalid longitude provided, defaulting to 0');\n        lng = 0;\n      }\n      \n      // Validate coordinate values with clamping instead of throwing\n      if (lat < -90 || lat > 90) {\n        console.warn(`Latitude ${lat} out of bounds, clamping to valid range`);\n        lat = Math.max(-90, Math.min(90, lat));\n      }\n      \n      if (lng < -180 || lng > 180) {\n        console.warn(`Longitude ${lng} out of bounds, clamping to valid range`);\n        lng = Math.max(-180, Math.min(180, lng));\n      }\n      \n      // Handle null/undefined elevation more gracefully\n      const safeElevation = elevation !== null && elevation !== undefined && !isNaN(elevation) \n        ? elevation \n        : 0;\n      \n      // Validate height reference system\n      const validHeightReferences = ['ellipsoidal', 'orthometric'];\n      if (!validHeightReferences.includes(heightReference)) {\n        console.warn(`Invalid height reference: ${heightReference}, using default 'ellipsoidal'`);\n        heightReference = 'ellipsoidal';\n      }\n      \n      this.lat = lat;\n      this.lng = lng;\n      this.elevation = safeElevation;\n      this.heightReference = heightReference;\n      this.projection = projection || 'WGS84';\n      \n      // Get transformer from factory using dependency injection\n      // This allows for switching transformer implementations\n      this.transformer = TransformerFactory.getTransformer();\n      \n      // For debugging\n      //console.log(`Created coordinate: ${this.lat}, ${this.lng}, ${this.elevation}`);\n      \n    } catch (error) {\n      console.error('Error in Coordinate constructor:', error);\n      // Create a safe default coordinate\n      this.lat = 0;\n      this.lng = 0;\n      this.elevation = 0;\n      this.heightReference = 'ellipsoidal';\n      this.projection = 'WGS84';\n      this.transformer = TransformerFactory.getTransformer();\n    }\n  }\n  \n  /**\n   * Create a Coordinate from an object with lat/lng/elevation properties.\n   * Supports multiple object formats commonly found in mapping applications.\n   * \n   * @param {Object} obj - Object with coordinate properties\n   * @param {number|string} [obj.lat] - Latitude (WGS84)\n   * @param {number|string} [obj.latitude] - Alternative latitude property\n   * @param {number|string} [obj.lng] - Longitude (WGS84)\n   * @param {number|string} [obj.longitude] - Alternative longitude property\n   * @param {number|string} [obj.elevation] - Elevation in meters\n   * @param {number|string} [obj.altitude] - Alternative elevation property\n   * @param {number|string} [obj.alt] - Alternative elevation property\n   * @param {string} [obj.heightReference] - Height reference system\n   * @param {string} [obj.projection] - Coordinate projection\n   * @returns {Coordinate} A new Coordinate object\n   */\n  static fromObject(obj) {\n    try {\n      if (!obj || typeof obj !== 'object') {\n        console.warn('Invalid object passed to Coordinate.fromObject', obj);\n        return new Coordinate(0, 0, 0);\n      }\n      \n      // Extract latitude (try different common property names)\n      let lat = obj.lat !== undefined ? obj.lat : \n        obj.latitude !== undefined ? obj.latitude :\n          obj.y !== undefined ? obj.y : 0;\n      \n      // Extract longitude (try different common property names)\n      let lng = obj.lng !== undefined ? obj.lng : \n        obj.longitude !== undefined ? obj.longitude :\n          obj.x !== undefined ? obj.x : 0;\n      \n      // Extract elevation (try different common property names)\n      const elevation = obj.elevation !== undefined ? obj.elevation : \n        obj.altitude !== undefined ? obj.altitude :\n          obj.alt !== undefined ? obj.alt :\n            obj.z !== undefined ? obj.z : 0;\n      \n      // Handle Google Maps-specific LatLng objects\n      if (typeof obj.lat === 'function' && typeof obj.lng === 'function') {\n        try {\n          lat = obj.lat();\n          lng = obj.lng();\n        } catch (e) {\n          console.warn('Error extracting lat/lng from Google Maps LatLng object', e);\n        }\n      }\n      \n      // Log the conversion for debugging\n      // console.log(`Coordinate.fromObject: (${lat}, ${lng}, ${elevation})`);\n      \n      return new Coordinate(\n        lat,\n        lng,\n        elevation,\n        obj.heightReference || 'ellipsoidal',\n        obj.projection || 'WGS84',\n      );\n    } catch (error) {\n      console.error('Error in Coordinate.fromObject:', error);\n      return new Coordinate(0, 0, 0);\n    }\n  }\n  \n  /**\n   * Convert this coordinate to a different projection.\n   * @param {string} targetProjection - Target projection system\n   * @returns {Coordinate} A new coordinate in the target projection\n   */\n  toProjection(targetProjection) {\n    if (this.projection === targetProjection) {\n      return this.clone();\n    }\n    \n    return this.transformer.transform(this, this.projection, targetProjection);\n  }\n  \n  /**\n   * Convert to a different height reference system.\n   * @param {string} reference - Target height reference system\n   * @returns {Coordinate} A new coordinate with the converted height reference\n   */\n  toHeightReference(reference) {\n    if (this.heightReference === reference) {\n      return this.clone();\n    }\n    \n    if (reference === 'orthometric' && this.heightReference === 'ellipsoidal') {\n      // Convert from ellipsoidal (GPS) to orthometric (mean sea level)\n      return this.transformer.convertEllipsoidalToOrthometric(this);\n    }\n    \n    if (reference === 'ellipsoidal' && this.heightReference === 'orthometric') {\n      // Convert from orthometric (mean sea level) to ellipsoidal (GPS)\n      return this.transformer.convertOrthometricToEllipsoidal(this);\n    }\n    \n    throw new Error(`Unsupported height reference conversion: ${this.heightReference} to ${reference}`);\n  }\n  \n  /**\n   * Calculate the 3D distance to another coordinate.\n   * @param {Coordinate} other - The other coordinate\n   * @returns {number} Distance in meters\n   */\n  distanceTo(other) {\n    // Ensure both coordinates are in the same reference system\n    let otherCoord = other;\n    \n    if (other.projection !== this.projection) {\n      otherCoord = other.toProjection(this.projection);\n    }\n    \n    if (otherCoord.heightReference !== this.heightReference) {\n      otherCoord = otherCoord.toHeightReference(this.heightReference);\n    }\n    \n    // Calculate horizontal distance using Haversine formula\n    const R = 6371000; // Earth radius in meters\n    const φ1 = this.lat * Math.PI / 180;\n    const φ2 = otherCoord.lat * Math.PI / 180;\n    const Δφ = (otherCoord.lat - this.lat) * Math.PI / 180;\n    const Δλ = (otherCoord.lng - this.lng) * Math.PI / 180;\n    \n    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +\n              Math.cos(φ1) * Math.cos(φ2) *\n              Math.sin(Δλ/2) * Math.sin(Δλ/2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));\n    const horizontalDistance = R * c;\n    \n    // Calculate elevation difference\n    const elevDiff = otherCoord.elevation - this.elevation;\n    \n    // Return 3D distance using Pythagorean theorem\n    return Math.sqrt(horizontalDistance * horizontalDistance + elevDiff * elevDiff);\n  }\n  \n  /**\n   * Calculate the bearing to another coordinate.\n   * @param {Coordinate} other - The other coordinate\n   * @returns {number} Bearing in degrees (0-360)\n   */\n  bearingTo(other) {\n    // Ensure same projection\n    const otherCoord = other.projection !== this.projection \n      ? other.toProjection(this.projection) \n      : other;\n    \n    const φ1 = this.lat * Math.PI / 180;\n    const φ2 = otherCoord.lat * Math.PI / 180;\n    const λ1 = this.lng * Math.PI / 180;\n    const λ2 = otherCoord.lng * Math.PI / 180;\n    \n    const y = Math.sin(λ2 - λ1) * Math.cos(φ2);\n    const x = Math.cos(φ1) * Math.sin(φ2) -\n              Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);\n    \n    let bearing = Math.atan2(y, x) * 180 / Math.PI;\n    bearing = (bearing + 360) % 360; // Normalize to 0-360\n    \n    return bearing;\n  }\n  \n  /**\n   * Calculate the midpoint between this coordinate and another.\n   * @param {Coordinate} other - The other coordinate \n   * @returns {Coordinate} A new coordinate at the midpoint\n   */\n  midpointTo(other) {\n    // Ensure same reference systems\n    let otherCoord = other;\n    \n    if (other.projection !== this.projection) {\n      otherCoord = other.toProjection(this.projection);\n    }\n    \n    if (otherCoord.heightReference !== this.heightReference) {\n      otherCoord = otherCoord.toHeightReference(this.heightReference);\n    }\n    \n    // Calculate midpoint\n    const φ1 = this.lat * Math.PI / 180;\n    const λ1 = this.lng * Math.PI / 180;\n    const φ2 = otherCoord.lat * Math.PI / 180;\n    const λ2 = otherCoord.lng * Math.PI / 180;\n    \n    const Bx = Math.cos(φ2) * Math.cos(λ2 - λ1);\n    const By = Math.cos(φ2) * Math.sin(λ2 - λ1);\n    \n    const φ3 = Math.atan2(\n      Math.sin(φ1) + Math.sin(φ2),\n      Math.sqrt((Math.cos(φ1) + Bx) * (Math.cos(φ1) + Bx) + By * By),\n    );\n    \n    const λ3 = λ1 + Math.atan2(By, Math.cos(φ1) + Bx);\n    \n    // Calculate average elevation\n    const midElevation = (this.elevation + otherCoord.elevation) / 2;\n    \n    return new Coordinate(\n      φ3 * 180 / Math.PI,\n      λ3 * 180 / Math.PI,\n      midElevation,\n      this.heightReference,\n      this.projection,\n    );\n  }\n  \n  /**\n   * Create a copy of this coordinate.\n   * @returns {Coordinate} A new coordinate with the same values\n   */\n  clone() {\n    return new Coordinate(\n      this.lat,\n      this.lng,\n      this.elevation,\n      this.heightReference,\n      this.projection,\n    );\n  }\n  \n  /**\n   * Convert the coordinate to a plain object.\n   * @returns {Object} Object representation of the coordinate\n   */\n  toObject() {\n    return {\n      lat: this.lat,\n      lng: this.lng,\n      elevation: this.elevation,\n      heightReference: this.heightReference,\n      projection: this.projection,\n    };\n  }\n  \n  /**\n   * Convert the coordinate to a GeoJSON point.\n   * @returns {Object} GeoJSON Point geometry\n   */\n  toGeoJSON() {\n    // Ensure WGS84 for GeoJSON compliance\n    const wgs84Coord = this.projection !== 'WGS84' \n      ? this.toProjection('WGS84') \n      : this;\n    \n    return {\n      type: 'Point',\n      coordinates: [wgs84Coord.lng, wgs84Coord.lat, wgs84Coord.elevation],\n    };\n  }\n  \n  /**\n   * Return string representation of the coordinate.\n   * @returns {string} String representation\n   */\n  toString() {\n    return `${this.lat.toFixed(7)},${this.lng.toFixed(7)},${this.elevation.toFixed(2)} (${this.projection}, ${this.heightReference})`;\n  }\n  \n  /**\n   * Return a compact string representation of the coordinate (lat, lng only).\n   * @returns {string} Compact string representation\n   */\n  toCompactString() {\n    return `${this.lat.toFixed(5)},${this.lng.toFixed(5)}`;\n  }\n  \n  /**\n   * Set the elevation (Z value) of the coordinate\n   * @param {number} elevation - The new elevation value in meters\n   * @returns {Coordinate} - This coordinate for chaining\n   */\n  setZ(elevation) {\n    // Handle null/undefined elevation more gracefully\n    const safeElevation = elevation !== null && elevation !== undefined ? elevation : 0;\n    \n    if (!Number.isFinite(safeElevation)) {\n      throw new Error(`Invalid elevation: ${elevation}. Must be a number.`);\n    }\n    \n    this.elevation = safeElevation;\n    return this;\n  }\n}","/**\n * CoordinateUtils.js - Coordinate format utilities\n * \n * Provides utility functions for working with different coordinate formats\n * and ensuring consistency across the application.\n */\n\nimport { Coordinate } from './Coordinate.js';\n\n/**\n * Coordinate Utilities\n * A collection of helper functions for coordinate processing\n */\nexport const CoordinateUtils = {\n  /**\n   * Standardize coordinate properties to use lat/lng/elevation format\n   * while preserving the original properties for compatibility\n   * \n   * @param {Object} coordinate - Coordinate object with either lat/lng or x/y/z properties\n   * @returns {Object} Standardized coordinate object with both property sets\n   */\n  standardizeCoordinate(coordinate) {\n    if (!coordinate || typeof coordinate !== 'object') {\n      console.warn('Invalid coordinate object provided to standardizeCoordinate');\n      return null;\n    }\n    \n    // Extract latitude (try different common property names)\n    const lat = coordinate.lat !== undefined ? coordinate.lat : \n      coordinate.latitude !== undefined ? coordinate.latitude :\n        coordinate.y !== undefined ? coordinate.y : null;\n    \n    // Extract longitude (try different common property names)\n    const lng = coordinate.lng !== undefined ? coordinate.lng : \n      coordinate.longitude !== undefined ? coordinate.longitude :\n        coordinate.x !== undefined ? coordinate.x : null;\n    \n    // Extract elevation (try different common property names)\n    const elevation = coordinate.elevation !== undefined ? coordinate.elevation : \n      coordinate.altitude !== undefined ? coordinate.altitude :\n        coordinate.alt !== undefined ? coordinate.alt :\n          coordinate.z !== undefined ? coordinate.z : 0;\n    \n    // Validate required properties\n    if (lat === null || lng === null) {\n      console.warn('Cannot standardize coordinate without lat/lng or x/y properties');\n      return coordinate; // Return original to avoid data loss\n    }\n    \n    // Return a standardized object with all properties\n    // This maintains backwards compatibility while ensuring\n    // that standard property names are available\n    return {\n      // Standard properties\n      lat,\n      lng,\n      elevation,\n      \n      // Common alternate properties\n      latitude: lat,\n      longitude: lng,\n      \n      // Legacy/cartesian properties\n      x: lng,\n      y: lat,\n      z: elevation,\n      \n      // Original properties for reference\n      ...coordinate,\n    };\n  },\n  \n  /**\n   * Convert any coordinate object to a proper Coordinate instance\n   * \n   * @param {Object|Coordinate} coordinate - A coordinate object or Coordinate instance\n   * @returns {Coordinate} A proper Coordinate instance\n   */\n  toCoordinate(coordinate) {\n    // If it's already a Coordinate instance, return it\n    if (coordinate instanceof Coordinate) {\n      return coordinate;\n    }\n    \n    // Otherwise, standardize and convert\n    return Coordinate.fromObject(this.standardizeCoordinate(coordinate));\n  },\n  \n  /**\n   * Extract standard lat/lng/elevation values from a coordinate object\n   * \n   * @param {Object} coordinate - Coordinate object with either lat/lng or x/y/z properties\n   * @returns {Object} Object with standardized lat/lng/elevation properties\n   */\n  extractStandardValues(coordinate) {\n    const standardized = this.standardizeCoordinate(coordinate);\n    \n    return {\n      lat: standardized.lat,\n      lng: standardized.lng,\n      elevation: standardized.elevation,\n    };\n  },\n  \n  /**\n   * Create a deep copy of a coordinate object with standard properties\n   * \n   * @param {Object} coordinate - Coordinate object to copy\n   * @returns {Object} A new coordinate object with standard properties\n   */\n  cloneWithStandardProperties(coordinate) {\n    const standardized = this.standardizeCoordinate(coordinate);\n    \n    // Create a new object with only the standard properties\n    return {\n      lat: standardized.lat,\n      lng: standardized.lng,\n      elevation: standardized.elevation,\n    };\n  },\n};","/**\n * GeometryEngine.js - Geodesic geometry calculations for 3D coordinates\n *\n * Provides accurate geometric calculations on an ellipsoidal Earth model,\n * taking elevation into account for true 3D calculations. This engine handles\n * complex computations such as area, volume, and intersection determination.\n */\n\nimport { Coordinate } from './Coordinate.js';\nimport { CoordinateUtils } from './CoordinateUtils.js';\n\n/**\n * Provides geometric calculations for geographic coordinates.\n */\nexport class GeometryEngine {\n  /**\n   * Calculate the total elevation gain along a path\n   * @param {Array<Coordinate>} coordinates - Array of coordinates representing the path\n   * @returns {number} Total elevation gain in meters\n   */\n  static calculateElevationGain(coordinates) {\n    if (!coordinates || coordinates.length < 2) {\n      return 0;\n    }\n\n    let totalGain = 0;\n\n    for (let i = 1; i < coordinates.length; i++) {\n      const prev = coordinates[i - 1];\n      const curr = coordinates[i];\n\n      // Skip if either coordinate doesn't have elevation data\n      if (prev.elevation === undefined || prev.elevation === null ||\n          curr.elevation === undefined || curr.elevation === null) {\n        continue;\n      }\n\n      // Only add positive elevation changes\n      const diff = curr.elevation - prev.elevation;\n      if (diff > 0) {\n        totalGain += diff;\n      }\n    }\n\n    return totalGain;\n  }\n\n  /**\n   * Calculate the total elevation loss along a path\n   * @param {Array<Coordinate>} coordinates - Array of coordinates representing the path\n   * @returns {number} Total elevation loss in meters (as a positive number)\n   */\n  static calculateElevationLoss(coordinates) {\n    if (!coordinates || coordinates.length < 2) {\n      return 0;\n    }\n\n    let totalLoss = 0;\n\n    for (let i = 1; i < coordinates.length; i++) {\n      const prev = coordinates[i - 1];\n      const curr = coordinates[i];\n\n      // Skip if either coordinate doesn't have elevation data\n      if (prev.elevation === undefined || prev.elevation === null ||\n          curr.elevation === undefined || curr.elevation === null) {\n        continue;\n      }\n\n      // Only add negative elevation changes (as positive values)\n      const diff = curr.elevation - prev.elevation;\n      if (diff < 0) {\n        totalLoss += Math.abs(diff);\n      }\n    }\n\n    return totalLoss;\n  }\n  /**\n     * Get the Coordinate class\n     * @returns {Object} Object containing the Coordinate class\n     * @private\n     */\n  static _getCoordinateClass() {\n    return { Coordinate };\n  }\n\n  /**\n     * Earth parameters.\n     * @private\n     */\n  static _EARTH_RADIUS_M = 6371000; // Mean radius in meters\n  static _WGS84_SEMI_MAJOR_AXIS = 6378137.0; // Semi-major axis in meters\n  static _WGS84_SEMI_MINOR_AXIS = 6356752.314245; // Semi-minor axis in meters\n  static _WGS84_FLATTENING = 1 / 298.257223563; // Flattening\n\n  /**\n     * Find the nearest point on a line segment to a given point.\n     * Instance method wrapper for the static nearestPointOnSegment method\n     * @param {Coordinate} start - Starting point of the segment\n     * @param {Coordinate} end - Ending point of the segment\n     * @param {Coordinate} point - The point to find the nearest to\n     * @returns {Object} Object containing the nearest point and distance information\n     */\n  nearestPointOnSegment(start, end, point) {\n    return GeometryEngine.nearestPointOnSegment(start, end, point);\n  }\n\n  /**\n     * Calculate the distance between two coordinates.\n     * @param {Coordinate|Object} coord1 - First coordinate\n     * @param {Coordinate|Object} coord2 - Second coordinate\n     * @param {Object} [options={}] - Calculation options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation in the calculation\n     * @returns {number} Distance in meters\n     */\n  static calculateDistance(coord1, coord2, options = {}) {\n    // Validate coordinates or coordinate-like objects\n    if (!coord1 || !coord2 ||\n            typeof coord1 !== 'object' || typeof coord2 !== 'object') {\n      console.error('Invalid coordinate format for distance calculation');\n      return 0;\n    }\n\n    const includeElevation = options.includeElevation !== false;\n\n    // Helper function to extract latitude from coordinate-like object\n    const getLat = (coord) => {\n      // Support both coord.lat and coord.latitude formats\n      return coord.lat !== undefined ? coord.lat :\n        coord.latitude !== undefined ? coord.latitude : null;\n    };\n\n    // Helper function to extract longitude from coordinate-like object\n    const getLng = (coord) => {\n      // Support both coord.lng and coord.longitude formats\n      return coord.lng !== undefined ? coord.lng :\n        coord.longitude !== undefined ? coord.longitude : null;\n    };\n\n    // Extract lat/lng values\n    const lat1 = getLat(coord1);\n    const lng1 = getLng(coord1);\n    const lat2 = getLat(coord2);\n    const lng2 = getLng(coord2);\n\n    // Validate lat/lng existence\n    if (lat1 === null || lng1 === null || lat2 === null || lng2 === null) {\n      console.error('Coordinates missing lat/lng properties for distance calculation');\n      return 0;\n    }\n\n    // Create simplified coordinate objects with consistent properties\n    const simpleCoord1 = {\n      lat: lat1,\n      lng: lng1,\n      elevation: coord1.elevation !== undefined ? coord1.elevation : 0,\n    };\n\n    const simpleCoord2 = {\n      lat: lat2,\n      lng: lng2,\n      elevation: coord2.elevation !== undefined ? coord2.elevation : 0,\n    };\n\n    // If both are true Coordinate instances with distanceTo method, use it\n    if (includeElevation &&\n            coord1 instanceof Coordinate &&\n            coord2 instanceof Coordinate &&\n            typeof coord1.distanceTo === 'function') {\n      return coord1.distanceTo(coord2);\n    }\n\n    // For 3D distance with elevation (Pythagorean approach)\n    if (includeElevation) {\n      // Calculate 2D distance\n      const distance2D = this._calculateApproximateDistance(simpleCoord1, simpleCoord2);\n\n      // Extract elevations\n      const elev1 = simpleCoord1.elevation !== undefined ? simpleCoord1.elevation : 0;\n      const elev2 = simpleCoord2.elevation !== undefined ? simpleCoord2.elevation : 0;\n\n      // Apply Pythagorean theorem for 3D distance\n      const elevDiff = elev2 - elev1;\n      return Math.sqrt(distance2D * distance2D + elevDiff * elevDiff);\n    }\n\n    // For 2D distance, use simplified Vincenty approximation\n    return this._calculateApproximateDistance(simpleCoord1, simpleCoord2);\n  }\n\n  /**\n     * Calculate the area of a polygon defined by an array of coordinates.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon (must be closed)\n     * @param {Object} [options={}] - Calculation options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation in the calculation\n     * @returns {number} Area in square meters\n     */\n  static calculateArea(coordinates, options = {}) {\n    const includeElevation = options.includeElevation !== false;\n\n    // Check if we have enough coordinates\n    if (coordinates.length < 3) {\n      return 0;\n    }\n\n    // Check if the polygon is closed\n    const firstCoord = coordinates[0];\n    const lastCoord = coordinates[coordinates.length - 1];\n    const isClosed = firstCoord.lat === lastCoord.lat &&\n            firstCoord.lng === lastCoord.lng;\n\n    // Create a closed copy if needed\n    const closedCoords = isClosed ? coordinates : [...coordinates, coordinates[0]];\n\n    // Check for self-intersection\n    if (this._isSelfIntersecting(closedCoords)) {\n      // For self-intersecting polygons, we'll need to triangulate\n      return this._calculateAreaWithTriangulation(closedCoords, options);\n    }\n\n    if (includeElevation) {\n      // For 3D area, project to a plane and calculate\n      return this._calculate3DArea(closedCoords);\n    } else {\n      // Use spherical geometry for 2D area\n      return this._calculate2DSphericalArea(closedCoords);\n    }\n  }\n\n  /**\n     * Calculate the perimeter of a polygon or the length of a line.\n     * @param {Coordinate[]} coordinates - Array of coordinates\n     * @param {Object} [options={}] - Calculation options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation in the calculation\n     * @returns {number} Perimeter in meters\n     */\n  static calculatePerimeter(coordinates, options = {}) {\n    const includeElevation = options.includeElevation !== false;\n\n    if (coordinates.length < 2) {\n      return 0;\n    }\n\n    let perimeter = 0;\n\n    // Sum the distances between consecutive points\n    for (let i = 0; i < coordinates.length - 1; i++) {\n      perimeter += this.calculateDistance(\n        coordinates[i],\n        coordinates[i + 1],\n        { includeElevation },\n      );\n    }\n\n    // If it's a polygon (has at least 3 points), close it\n    if (coordinates.length >= 3) {\n      // Check if already closed\n      const firstCoord = coordinates[0];\n      const lastCoord = coordinates[coordinates.length - 1];\n      const isClosed = firstCoord.lat === lastCoord.lat &&\n                firstCoord.lng === lastCoord.lng;\n\n      if (!isClosed) {\n        // Add distance from last point back to first\n        perimeter += this.calculateDistance(\n          coordinates[coordinates.length - 1],\n          coordinates[0],\n          { includeElevation },\n        );\n      }\n    }\n\n    return perimeter;\n  }\n\n  /**\n     * Calculate the length of a path (alias for calculatePerimeter).\n     * @param {Coordinate[]} coordinates - Array of coordinates\n     * @param {Object} [options={}] - Calculation options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation in the calculation\n     * @param {boolean} [options.closed=false] - Whether the path is closed\n     * @returns {number} Path length in meters\n     */\n  static calculatePathLength(coordinates, options = {}) {\n    return this.calculatePerimeter(coordinates, options);\n  }\n\n  /**\n     * Calculate a perpendicular offset point from a line segment.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a line\n     * @param {number} pointIndex - Index of the segment start point\n     * @param {number} segmentPosition - Normalized position along the segment (0-1)\n     * @param {number} distance - Offset distance in meters\n     * @param {Object} [options={}] - Calculation options\n     * @param {boolean} [options.enable3D=true] - Whether to include elevation in the calculation\n     * @returns {Object} Object with the offset point and other segment info\n     */\n  static calculatePerpendicularOffset(coordinates, pointIndex, segmentPosition, distance, options = {}) {\n    if (coordinates.length < 2 || pointIndex < 0 || pointIndex >= coordinates.length - 1) {\n      throw new Error('Invalid coordinates or point index for perpendicular offset');\n    }\n\n    const enable3D = options.enable3D !== false;\n\n    // Get the segment points\n    const startPoint = coordinates[pointIndex];\n    const endPoint = coordinates[pointIndex + 1];\n\n    // Calculate the point on the segment at the given position\n    const segmentFraction = Math.max(0, Math.min(1, segmentPosition));\n\n    // Interpolate the point position\n    const nearestPoint = new Coordinate(\n      startPoint.lat + segmentFraction * (endPoint.lat - startPoint.lat),\n      startPoint.lng + segmentFraction * (endPoint.lng - startPoint.lng),\n      enable3D ? startPoint.elevation + segmentFraction * (endPoint.elevation - startPoint.elevation) : null,\n      startPoint.heightReference,\n      startPoint.projection,\n    );\n\n    // Calculate the bearing of the segment\n    const segmentBearing = startPoint.bearingTo(endPoint);\n\n    // Calculate perpendicular bearing (90 degrees to the right)\n    const perpendicularBearing = (segmentBearing + 90) % 360;\n\n    // Calculate the offset point\n    const offsetPoint = this._calculateDestinationPoint(\n      nearestPoint,\n      distance,\n      perpendicularBearing,\n    );\n\n    // If 3D is enabled, ensure the offset point has proper elevation\n    if (enable3D && nearestPoint.elevation !== null && nearestPoint.elevation !== undefined) {\n      offsetPoint.elevation = nearestPoint.elevation;\n    }\n\n    return {\n      nearestPoint: nearestPoint,\n      offsetPoint: offsetPoint,\n      pointIndex: pointIndex,\n      segmentPosition: segmentFraction,\n      segmentBearing: segmentBearing,\n      perpendicularBearing: perpendicularBearing,\n    };\n  }\n\n  /**\n     * Calculate the bearing between two coordinates.\n     * @param {Coordinate} from - Starting coordinate\n     * @param {Coordinate} to - Ending coordinate\n     * @returns {number} Bearing in degrees (0-360)\n     */\n  static calculateBearing(from, to) {\n    // Use the bearing calculation from the Coordinate class\n    return from.bearingTo(to);\n  }\n\n  /**\n     * Create a geodesic arc with the given radius around a point.\n     * @param {Coordinate} center - Center coordinate\n     * @param {number} radiusMeters - Radius in meters\n     * @param {number} [startAngle=0] - Starting angle in degrees\n     * @param {number} [endAngle=360] - Ending angle in degrees\n     * @param {number} [segments=32] - Number of segments to create\n     * @returns {Coordinate[]} Array of coordinates forming the arc\n     */\n  static createArc(center, radiusMeters, startAngle = 0, endAngle = 360, segments = 32) {\n    const result = [];\n    const angleRange = endAngle - startAngle;\n\n    // Calculate angle increment based on segments\n    const angleIncrement = angleRange / segments;\n\n    for (let i = 0; i <= segments; i++) {\n      const angle = (startAngle + i * angleIncrement) * Math.PI / 180;\n      const point = this._calculateDestinationPoint(\n        center,\n        radiusMeters,\n        angle,\n      );\n      result.push(point);\n    }\n\n    return result;\n  }\n\n  /**\n     * Create a geodesic circle with the given radius around a point.\n     * @param {Coordinate} center - Center coordinate\n     * @param {number} radiusMeters - Radius in meters\n     * @param {number} [segments=32] - Number of segments to create\n     * @returns {Coordinate[]} Array of coordinates forming the circle\n     */\n  static createCircle(center, radiusMeters, segments = 32) {\n    return this.createArc(center, radiusMeters, 0, 360, segments);\n  }\n\n  /**\n     * Create a geodesic rectangle with the given dimensions.\n     * @param {Coordinate} center - Center coordinate\n     * @param {number} widthMeters - Width in meters\n     * @param {number} heightMeters - Height in meters\n     * @param {number} [rotationDegrees=0] - Rotation in degrees\n     * @returns {Coordinate[]} Array of coordinates forming the rectangle\n     */\n  static createRectangle(center, widthMeters, heightMeters, rotationDegrees = 0) {\n    const rotationRadians = rotationDegrees * Math.PI / 180;\n    const halfWidth = widthMeters / 2;\n    const halfHeight = heightMeters / 2;\n\n    // Calculate corners\n    const bearings = [\n      Math.atan2(-halfHeight, -halfWidth) + rotationRadians,\n      Math.atan2(-halfHeight, halfWidth) + rotationRadians,\n      Math.atan2(halfHeight, halfWidth) + rotationRadians,\n      Math.atan2(halfHeight, -halfWidth) + rotationRadians,\n    ];\n\n    const distances = [\n      Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight),\n      Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight),\n      Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight),\n      Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight),\n    ];\n\n    // Generate the corners\n    const corners = [];\n    for (let i = 0; i < 4; i++) {\n      const bearing = (bearings[i] * 180 / Math.PI + 360) % 360;\n      corners.push(this._calculateDestinationPoint(\n        center,\n        distances[i],\n        bearing,\n      ));\n    }\n\n    // Close the polygon\n    corners.push(corners[0]);\n\n    return corners;\n  }\n\n  /**\n     * Check if a point is contained within a polygon.\n     * @param {Coordinate} point - The point to check\n     * @param {Coordinate[]} polygon - Array of coordinates defining the polygon\n     * @returns {boolean} True if the point is inside the polygon\n     */\n  static isPointInPolygon(point, polygon) {\n    // Ray casting algorithm for point-in-polygon detection\n    let inside = false;\n\n    // Check if the polygon is closed - if not, close it\n    const isPolygonClosed = polygon[0].lat === polygon[polygon.length - 1].lat &&\n            polygon[0].lng === polygon[polygon.length - 1].lng;\n    const closedPolygon = isPolygonClosed ? polygon : [...polygon, polygon[0]];\n\n    // Ensure all coordinates are in the same projection\n    const targetProjection = point.projection;\n    const normalizedPolygon = closedPolygon.map(coord =>\n      coord.projection !== targetProjection ?\n        coord.toProjection(targetProjection) :\n        coord,\n    );\n\n    for (let i = 0, j = normalizedPolygon.length - 1; i < normalizedPolygon.length; j = i++) {\n      const xi = normalizedPolygon[i].lng;\n      const yi = normalizedPolygon[i].lat;\n      const xj = normalizedPolygon[j].lng;\n      const yj = normalizedPolygon[j].lat;\n\n      const intersect = ((yi > point.lat) !== (yj > point.lat)) &&\n                (point.lng < (xj - xi) * (point.lat - yi) / (yj - yi) + xi);\n\n      if (intersect) inside = !inside;\n    }\n\n    return inside;\n  }\n\n  /**\n     * Check if a point is contained within a polygon (alias for isPointInPolygon).\n     * @param {Coordinate} point - The point to check\n     * @param {Coordinate[]} polygon - Array of coordinates defining the polygon\n     * @returns {boolean} True if the point is inside the polygon\n     */\n  static pointInPolygon(point, polygon) {\n    return this.isPointInPolygon(point, polygon);\n  }\n\n  /**\n     * Calculate the centroid of a polygon.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon\n     * @returns {Coordinate} Centroid coordinate\n     */\n  static calculateCentroid(coordinates) {\n    // Check if we have enough coordinates\n    if (coordinates.length < 3) {\n      throw new Error('Cannot calculate centroid: need at least 3 coordinates');\n    }\n\n    // For simple polygons, use the arithmetic mean of coordinates\n    // For more complex cases, this is an approximation\n    let sumLat = 0;\n    let sumLng = 0;\n    let sumElev = 0;\n\n    for (const coord of coordinates) {\n      sumLat += coord.lat;\n      sumLng += coord.lng;\n      sumElev += coord.elevation;\n    }\n\n    return new Coordinate(\n      sumLat / coordinates.length,\n      sumLng / coordinates.length,\n      sumElev / coordinates.length,\n      coordinates[0].heightReference,\n      coordinates[0].projection,\n    );\n  }\n\n  /**\n     * Calculate the centroid of a polygon with holes.\n     * @param {Coordinate[]} exteriorRing - Array of coordinates defining the exterior ring\n     * @param {Array<Array<Coordinate>>} [holes=[]] - Array of holes, each an array of coordinates\n     * @returns {Coordinate|null} Centroid coordinate or null if insufficient coordinates\n     */\n  static calculatePolygonCentroid(exteriorRing, holes = []) {\n    // Check if we have enough coordinates for the exterior ring\n    if (!exteriorRing || exteriorRing.length < 3) {\n      console.warn('Cannot calculate polygon centroid: need at least 3 coordinates for exterior ring');\n      // Return null instead of throwing an error for easier error handling\n      // or if we have at least one coordinate, return it as a fallback\n      if (exteriorRing && exteriorRing.length > 0) {\n        return exteriorRing[0].clone();\n      }\n      return null;\n    }\n\n    // If there are no holes, use the regular centroid calculation\n    if (!holes || holes.length === 0) {\n      return this.calculateCentroid(exteriorRing);\n    }\n\n    // For polygons with holes, we can use different strategies:\n    // 1. Area-weighted centroid of exterior ring and holes\n    // 2. Find centroid of exterior ring and adjust based on holes\n    // 3. Triangulate and compute weighted centroid\n\n    // For simplicity, we'll use the exterior ring centroid\n    // with a slight adjustment if all holes are valid\n\n    // Calculate the centroid of the exterior ring\n    const exteriorCentroid = this.calculateCentroid(exteriorRing);\n\n    // Filter valid holes (those with at least 3 points)\n    const validHoles = holes.filter(hole => hole && hole.length >= 3);\n\n    if (validHoles.length === 0) {\n      return exteriorCentroid;\n    }\n\n    // Calculate area of exterior ring\n    const exteriorArea = this.calculateArea(exteriorRing);\n    if (exteriorArea === 0) {\n      return exteriorCentroid;\n    }\n\n    // Calculate area-weighted centroid considering holes\n    let totalArea = exteriorArea;\n    let weightedLat = exteriorCentroid.lat * exteriorArea;\n    let weightedLng = exteriorCentroid.lng * exteriorArea;\n    let weightedElev = exteriorCentroid.elevation * exteriorArea;\n\n    for (const hole of validHoles) {\n      const holeCentroid = this.calculateCentroid(hole);\n      const holeArea = this.calculateArea(hole);\n\n      totalArea -= holeArea;\n      weightedLat -= holeCentroid.lat * holeArea;\n      weightedLng -= holeCentroid.lng * holeArea;\n      weightedElev -= holeCentroid.elevation * holeArea;\n    }\n\n    // If the total area becomes too small or negative, fall back to exterior centroid\n    if (totalArea <= 0) {\n      return exteriorCentroid;\n    }\n\n    // Calculate the final weighted centroid\n    return new Coordinate(\n      weightedLat / totalArea,\n      weightedLng / totalArea,\n      weightedElev / totalArea,\n      exteriorRing[0].heightReference,\n      exteriorRing[0].projection,\n    );\n  }\n\n  /**\n     * Calculate the center of a path (line).\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a path\n     * @returns {Coordinate} Center coordinate of the path\n     */\n  static calculatePathCenter(coordinates) {\n    // Check if we have coordinates\n    if (coordinates.length === 0) {\n      throw new Error('Cannot calculate path center: no coordinates provided');\n    }\n\n    // For a single point, return it\n    if (coordinates.length === 1) {\n      return coordinates[0].clone();\n    }\n\n    // For a path with two points, return the midpoint\n    if (coordinates.length === 2) {\n      const lat = (coordinates[0].lat + coordinates[1].lat) / 2;\n      const lng = (coordinates[0].lng + coordinates[1].lng) / 2;\n      const elevation = (coordinates[0].elevation + coordinates[1].elevation) / 2;\n\n      return new Coordinate(\n        lat,\n        lng,\n        elevation,\n        coordinates[0].heightReference,\n        coordinates[0].projection,\n      );\n    }\n\n    // For a path with more than two points, find the middle point along the path\n    const totalLength = this.calculatePathLength(coordinates);\n    const targetDistance = totalLength / 2;\n\n    // Find the point at the target distance\n    let currentDistance = 0;\n\n    for (let i = 0; i < coordinates.length - 1; i++) {\n      const segmentLength = this.calculateDistance(\n        coordinates[i],\n        coordinates[i + 1],\n        { includeElevation: true },\n      );\n\n      if (currentDistance + segmentLength >= targetDistance) {\n        // The center point is on this segment\n        const remainingDistance = targetDistance - currentDistance;\n        const fraction = remainingDistance / segmentLength;\n\n        // Interpolate the position\n        const bearing = coordinates[i].bearingTo(coordinates[i + 1]);\n        const center = this._calculateDestinationPoint(\n          coordinates[i],\n          segmentLength * fraction,\n          bearing,\n        );\n\n        // Interpolate the elevation\n        center.elevation = coordinates[i].elevation +\n                    (coordinates[i + 1].elevation - coordinates[i].elevation) * fraction;\n\n        return center;\n      }\n\n      currentDistance += segmentLength;\n    }\n\n    // If something went wrong, fall back to the midpoint of the path\n    let sumLat = 0;\n    let sumLng = 0;\n    let sumElev = 0;\n\n    for (const coord of coordinates) {\n      sumLat += coord.lat;\n      sumLng += coord.lng;\n      sumElev += coord.elevation;\n    }\n\n    return new Coordinate(\n      sumLat / coordinates.length,\n      sumLng / coordinates.length,\n      sumElev / coordinates.length,\n      coordinates[0].heightReference,\n      coordinates[0].projection,\n    );\n  }\n\n  /**\n     * Create an offset line parallel to an existing line.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a line\n     * @param {number} offsetMeters - Offset distance in meters (positive is right, negative is left)\n     * @param {Object} [options={}] - Offset options\n     * @param {boolean} [options.closed=false] - Whether the line forms a closed loop\n     * @returns {Coordinate[]} Array of coordinates forming the offset line\n     */\n  static createOffsetLine(coordinates, offsetMeters, options = {}) {\n    if (coordinates.length < 2) {\n      throw new Error('Cannot create offset: need at least 2 coordinates');\n    }\n\n    const closed = options.closed || false;\n    const result = [];\n\n    // Process each segment\n    for (let i = 0; i < coordinates.length - 1; i++) {\n      const start = coordinates[i];\n      const end = coordinates[i + 1];\n\n      // Calculate bearing of the segment\n      const bearing = start.bearingTo(end);\n\n      // Calculate perpendicular bearing (90 degrees to the right)\n      const perpBearing = (bearing + 90) % 360;\n\n      // Calculate offset points\n      const startOffset = this._calculateDestinationPoint(\n        start,\n        offsetMeters,\n        perpBearing,\n      );\n\n      result.push(startOffset);\n\n      // Add the end point for the last segment\n      if (i === coordinates.length - 2) {\n        const endOffset = this._calculateDestinationPoint(\n          end,\n          offsetMeters,\n          perpBearing,\n        );\n        result.push(endOffset);\n      }\n    }\n\n    // If closed, add first point to close the loop\n    if (closed && result.length > 2) {\n      result.push(result[0]);\n    }\n\n    return result;\n  }\n\n  /**\n     * Find the closest point on a line segment to a given point.\n     * @param {Coordinate|Object} point - The reference point\n     * @param {Coordinate|Object} segmentStart - Start of the line segment\n     * @param {Coordinate|Object} segmentEnd - End of the line segment\n     * @returns {Object} Object with the closest point and distance information\n     */\n  static nearestPointOnSegment(start, end, point) {\n    const result = this._findClosestPointOnLineSegment(point, start, end);\n    return {\n      point: result.point,\n      distance: result.distance,\n      fraction: result.fraction,\n      segmentPosition: result.fraction, // For compatibility with existing code\n    };\n  }\n\n  /**\n     * Calculate a destination point given a starting point, distance, and bearing.\n     * Public method wrapping the private implementation.\n     * @param {Coordinate} coordinate - Starting coordinate\n     * @param {number} distance - Distance in meters\n     * @param {number} bearing - Bearing in degrees\n     * @returns {Coordinate} Destination coordinate\n     */\n  static destinationCoordinate(coordinate, distance, bearing) {\n    return this._calculateDestinationPoint(coordinate, distance, bearing);\n  }\n\n  /**\n     * Calculate a destination point given a starting point, distance, and bearing.\n     * Uses CoordinateUtils for consistent property handling.\n     * @param {Coordinate|Object} start - Starting coordinate\n     * @param {number} distance - Distance in meters\n     * @param {number} bearing - Bearing in degrees\n     * @returns {Coordinate} Destination coordinate\n     * @private\n     */\n  static _calculateDestinationPoint(start, distance, bearing) {\n    // Standardize coordinate properties\n    const standardStart = CoordinateUtils.standardizeCoordinate(start);\n\n    if (!standardStart) {\n      console.error('Invalid starting coordinate for destination calculation:', start);\n      return null;\n    }\n\n    const earthRadius = this._EARTH_RADIUS_M;\n    const bearingRad = bearing * Math.PI / 180;\n    const latRad = standardStart.lat * Math.PI / 180;\n    const lngRad = standardStart.lng * Math.PI / 180;\n\n    const distRatio = distance / earthRadius;\n    const sinDistRatio = Math.sin(distRatio);\n    const cosDistRatio = Math.cos(distRatio);\n\n    const sinLat1 = Math.sin(latRad);\n    const cosLat1 = Math.cos(latRad);\n\n    const sinLat2 = sinLat1 * cosDistRatio + cosLat1 * sinDistRatio * Math.cos(bearingRad);\n    const lat2 = Math.asin(sinLat2);\n\n    const y = Math.sin(bearingRad) * sinDistRatio * cosLat1;\n    const x = cosDistRatio - sinLat1 * sinLat2;\n    const lng2 = lngRad + Math.atan2(y, x);\n\n    // Preserve the original height reference and projection if available\n    const heightReference = start.heightReference ? start.heightReference :\n      (start instanceof Coordinate ? start.heightReference : 'ellipsoidal');\n    const projection = start.projection ? start.projection :\n      (start instanceof Coordinate ? start.projection : 'WGS84');\n\n    return new Coordinate(\n      lat2 * 180 / Math.PI,\n      ((lng2 * 180 / Math.PI) + 540) % 360 - 180, // Normalize to -180 to +180\n      standardStart.elevation,\n      heightReference,\n      projection,\n    );\n  }\n\n  /**\n     * Find the closest point on a line segment to a given point.\n     * Uses CoordinateUtils for consistent property handling.\n     * @param {Coordinate|Object} point - The reference point\n     * @param {Coordinate|Object} segmentStart - Start of the line segment\n     * @param {Coordinate|Object} segmentEnd - End of the line segment\n     * @returns {Object} Object with closest point and distance information\n     * @private\n     */\n  static _findClosestPointOnLineSegment(point, segmentStart, segmentEnd) {\n    // Standardize coordinates using CoordinateUtils\n    const standardPoint = CoordinateUtils.toCoordinate(point);\n    const standardStart = CoordinateUtils.toCoordinate(segmentStart);\n    const standardEnd = CoordinateUtils.toCoordinate(segmentEnd);\n\n    // Calculate vectors\n    const x = standardPoint.lng - standardStart.lng;\n    const y = standardPoint.lat - standardStart.lat;\n    const dx = standardEnd.lng - standardStart.lng;\n    const dy = standardEnd.lat - standardStart.lat;\n\n    // Calculate dot product\n    const dot = x * dx + y * dy;\n\n    // Calculate squared length of the segment\n    const len2 = dx * dx + dy * dy;\n\n    // Calculate parametric position along the line segment\n    const t = len2 > 0 ? Math.max(0, Math.min(1, dot / len2)) : 0;\n\n    // Calculate closest point\n    const closestLng = standardStart.lng + t * dx;\n    const closestLat = standardStart.lat + t * dy;\n\n    // Calculate elevation (linear interpolation)\n    const closestElev = standardStart.elevation +\n            t * (standardEnd.elevation - standardStart.elevation);\n\n    // Create the closest point coordinate\n    const closestPoint = new Coordinate(\n      closestLat,\n      closestLng,\n      closestElev,\n      standardStart.heightReference,\n      standardStart.projection,\n    );\n\n    // Calculate the distance to the closest point\n    const distance = standardPoint.distanceTo(closestPoint);\n\n    return {\n      point: closestPoint,\n      distance,\n      fraction: t,\n    };\n  }\n    \n  /**\n     * Check if two line segments intersect.\n     * @param {Coordinate} p1 - First point of first line segment\n     * @param {Coordinate} p2 - Second point of first line segment\n     * @param {Coordinate} p3 - First point of second line segment\n     * @param {Coordinate} p4 - Second point of second line segment\n     * @returns {boolean} True if the line segments intersect\n     * @private\n     */\n  static _lineSegmentsIntersect(p1, p2, p3, p4) {\n    // Convert to longitude, latitude order for calculation\n    const pt1 = { x: p1.lng, y: p1.lat };\n    const pt2 = { x: p2.lng, y: p2.lat };\n    const pt3 = { x: p3.lng, y: p3.lat };\n    const pt4 = { x: p4.lng, y: p4.lat };\n\n    // Calculate cross products\n    const d1 = this._direction(pt3, pt4, pt1);\n    const d2 = this._direction(pt3, pt4, pt2);\n    const d3 = this._direction(pt1, pt2, pt3);\n    const d4 = this._direction(pt1, pt2, pt4);\n\n    // Check if the line segments intersect\n    return (((d1 > 0 && d2 < 0) || (d1 < 0 && d2 > 0)) &&\n                ((d3 > 0 && d4 < 0) || (d3 < 0 && d4 > 0))) ||\n            (d1 === 0 && this._onSegment(pt3, pt4, pt1)) ||\n            (d2 === 0 && this._onSegment(pt3, pt4, pt2)) ||\n            (d3 === 0 && this._onSegment(pt1, pt2, pt3)) ||\n            (d4 === 0 && this._onSegment(pt1, pt2, pt4));\n  }\n\n  /**\n     * Calculate the direction of three points.\n     * @param {Object} a - First point {x, y}\n     * @param {Object} b - Second point {x, y}\n     * @param {Object} c - Third point {x, y}\n     * @returns {number} Direction value\n     * @private\n     */\n  static _direction(a, b, c) {\n    return (c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y);\n  }\n\n  /**\n     * Check if a point is on a line segment.\n     * @param {Object} a - First endpoint of segment {x, y}\n     * @param {Object} b - Second endpoint of segment {x, y}\n     * @param {Object} c - Point to check {x, y}\n     * @returns {boolean} True if the point is on the segment\n     * @private\n     */\n  static _onSegment(a, b, c) {\n    return c.x <= Math.max(a.x, b.x) && c.x >= Math.min(a.x, b.x) &&\n            c.y <= Math.max(a.y, b.y) && c.y >= Math.min(a.y, b.y);\n  }\n\n  /**\n     * Check if a polygon is self-intersecting.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon\n     * @returns {boolean} True if the polygon is self-intersecting\n     * @private\n     */\n  static _isSelfIntersecting(coordinates) {\n    // Check all line segments against all other line segments for intersection\n    for (let i = 0; i < coordinates.length - 1; i++) {\n      for (let j = i + 2; j < coordinates.length - 1; j++) {\n        // Skip adjacent segments\n        if (i === 0 && j === coordinates.length - 2) continue;\n\n        const p1 = coordinates[i];\n        const p2 = coordinates[i + 1];\n        const p3 = coordinates[j];\n        const p4 = coordinates[j + 1];\n\n        if (this._lineSegmentsIntersect(p1, p2, p3, p4)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n     * Check if a polygon or path is self-intersecting.\n     * Public method wrapping the private implementation.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon or path\n     * @returns {boolean} True if the polygon or path is self-intersecting\n     */\n  static hasSelfIntersections(coordinates) {\n    if (!coordinates || coordinates.length < 4) {\n      return false; // A path needs at least 4 points to self-intersect\n    }\n\n    return this._isSelfIntersecting(coordinates);\n  }\n\n  /**\n     * Calculate 2D area using spherical geometry.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon\n     * @returns {number} Area in square meters\n     * @private\n     */\n  static _calculate2DSphericalArea(coordinates) {\n    // We don't need R here since it's used in _calculateSphericalTriangleArea\n    let area = 0;\n\n    // For more than 3 coordinates, we compute the area using a sum of spherical triangles\n    for (let i = 1; i < coordinates.length - 1; i++) {\n      area += this._calculateSphericalTriangleArea(\n        coordinates[0],\n        coordinates[i],\n        coordinates[i + 1],\n      );\n    }\n\n    return Math.abs(area);\n  }\n\n  /**\n     * Calculate the area of a spherical triangle using Girard's formula.\n     * @param {Coordinate} A - First coordinate\n     * @param {Coordinate} B - Second coordinate\n     * @param {Coordinate} C - Third coordinate\n     * @returns {number} Area in square meters\n     * @private\n     */\n  static _calculateSphericalTriangleArea(A, B, C) {\n    const R = this._EARTH_RADIUS_M;\n\n    // Convert to radians\n    const a1 = A.lat * Math.PI / 180;\n    const a2 = A.lng * Math.PI / 180;\n    const b1 = B.lat * Math.PI / 180;\n    const b2 = B.lng * Math.PI / 180;\n    const c1 = C.lat * Math.PI / 180;\n    const c2 = C.lng * Math.PI / 180;\n\n    // Calculate the angles of the spherical triangle\n    const a = Math.acos(\n      Math.sin(b1) * Math.sin(c1) +\n            Math.cos(b1) * Math.cos(c1) * Math.cos(b2 - c2),\n    );\n    const b = Math.acos(\n      Math.sin(a1) * Math.sin(c1) +\n            Math.cos(a1) * Math.cos(c1) * Math.cos(a2 - c2),\n    );\n    const c = Math.acos(\n      Math.sin(a1) * Math.sin(b1) +\n            Math.cos(a1) * Math.cos(b1) * Math.cos(a2 - b2),\n    );\n\n    // Calculate the spherical excess (in radians)\n    const E = a + b + c - Math.PI;\n\n    // Calculate the area\n    return E * R * R;\n  }\n\n  /**\n     * Calculate area of a self-intersecting polygon using triangulation.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon\n     * @param {Object} options - Calculation options\n     * @returns {number} Area in square meters\n     * @private\n     */\n  static _calculateAreaWithTriangulation(coordinates, _options) {\n    // For simplicity in this implementation, we'll assume the polygon is not self-intersecting\n    // A full implementation would use ear clipping or other triangulation methods\n\n    console.warn('Self-intersecting polygon detected. Area calculation may be inaccurate.');\n\n    // Fall back to 2D calculation\n    return this._calculate2DSphericalArea(coordinates);\n  }\n\n  /**\n     * Calculate 3D area considering elevation.\n     * @param {Coordinate[]} coordinates - Array of coordinates defining a polygon\n     * @returns {number} Area in square meters\n     * @private\n     */\n  static _calculate3DArea(coordinates) {\n    // For 3D area, we'll project to a plane and calculate\n    // First determine plane normal vector by taking cross product\n    // of vectors formed by first three points\n\n    if (coordinates.length < 3) {\n      return 0;\n    }\n\n    // Convert to Cartesian coordinates\n    const cartesian = coordinates.map(coord => this._geographicToCartesian(coord));\n\n    // Calculate normal vector of best-fit plane\n    const normal = this._calculateBestFitPlaneNormal(cartesian);\n\n    // Project points onto the plane\n    const projectedPoints = cartesian.map(point =>\n      this._projectPointOntoPlane(point, normal, cartesian[0]),\n    );\n\n    // Calculate 3D area of the polygon on this plane\n    let area = 0;\n    for (let i = 0; i < projectedPoints.length - 1; i++) {\n      const p1 = projectedPoints[i];\n      const p2 = projectedPoints[i + 1];\n\n      // Add area of triangle formed with origin point\n      const crossProduct = this._crossProduct(p1, p2);\n      area += 0.5 * this._vectorLength(crossProduct);\n    }\n\n    return area;\n  }\n\n  /**\n     * Calculate the normal vector of the best-fit plane for a set of points.\n     * @param {Object[]} points - Array of Cartesian coordinates {x, y, z}\n     * @returns {Object} Normal vector {x, y, z}\n     * @private\n     */\n  static _calculateBestFitPlaneNormal(points) {\n    // For simplicity, we'll use the normal of the first triangle\n    // In a full implementation, we would use Principal Component Analysis\n\n    if (points.length < 3) {\n      return { x: 0, y: 0, z: 1 }; // Default to up\n    }\n\n    // Calculate vectors from first point to second and third points\n    const v1 = {\n      x: points[1].x - points[0].x,\n      y: points[1].y - points[0].y,\n      z: points[1].z - points[0].z,\n    };\n\n    const v2 = {\n      x: points[2].x - points[0].x,\n      y: points[2].y - points[0].y,\n      z: points[2].z - points[0].z,\n    };\n\n    // Calculate cross product to get normal vector\n    const normal = this._crossProduct(v1, v2);\n\n    // Normalize\n    const length = this._vectorLength(normal);\n\n    return {\n      x: normal.x / length,\n      y: normal.y / length,\n      z: normal.z / length,\n    };\n  }\n\n  /**\n     * Convert geographic coordinates to Cartesian (ECEF) coordinates.\n     * Uses CoordinateUtils for consistent property handling.\n     * @param {Coordinate|Object} coord - Geographic coordinate\n     * @returns {Object} Cartesian coordinate with consistent property naming\n     * @private\n     */\n  static _geographicToCartesian(coord) {\n    const a = this._WGS84_SEMI_MAJOR_AXIS;\n    const e2 = 0.00669437999014; // WGS84 first eccentricity squared\n\n    // Standardize coordinate properties using CoordinateUtils\n    const standardCoord = CoordinateUtils.standardizeCoordinate(coord);\n\n    if (!standardCoord || standardCoord.lat === null || standardCoord.lng === null) {\n      console.error('Invalid coordinate format for conversion:', coord);\n      // Return a default value at origin\n      return { x: 0, y: 0, z: 0, originalFormat: 'cartesian' };\n    }\n\n    const latRad = standardCoord.lat * Math.PI / 180;\n    const lngRad = standardCoord.lng * Math.PI / 180;\n    const h = standardCoord.elevation;\n\n    const sinLat = Math.sin(latRad);\n    const cosLat = Math.cos(latRad);\n    const sinLng = Math.sin(lngRad);\n    const cosLng = Math.cos(lngRad);\n\n    const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);\n\n    // Create result with both naming conventions for compatibility\n    const result = {\n      x: (N + h) * cosLat * cosLng,\n      y: (N + h) * cosLat * sinLng,\n      z: (N * (1 - e2) + h) * sinLat,\n      // Include standardized geographic properties\n      lat: standardCoord.lat,\n      lng: standardCoord.lng,\n      elevation: standardCoord.elevation,\n      originalFormat: 'geographic',\n    };\n\n    return result;\n  }\n\n  /**\n     * Project a point onto a plane.\n     * @param {Object} point - Cartesian coordinate {x, y, z}\n     * @param {Object} normal - Normal vector of the plane {x, y, z}\n     * @param {Object} planePoint - A point on the plane {x, y, z}\n     * @returns {Object} Projected point on the plane\n     * @private\n     */\n  static _projectPointOntoPlane(point, normal, planePoint) {\n    // Calculate vector from plane point to target point\n    const v = {\n      x: point.x - planePoint.x,\n      y: point.y - planePoint.y,\n      z: point.z - planePoint.z,\n    };\n\n    // Calculate distance from point to plane\n    const dist = this._dotProduct(v, normal);\n\n    // Project the point onto the plane\n    return {\n      x: point.x - dist * normal.x,\n      y: point.y - dist * normal.y,\n      z: point.z - dist * normal.z,\n    };\n  }\n\n  /**\n     * Calculate the dot product of two vectors.\n     * @param {Object} v1 - First vector {x, y, z}\n     * @param {Object} v2 - Second vector {x, y, z}\n     * @returns {number} Dot product\n     * @private\n     */\n  static _dotProduct(v1, v2) {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n  }\n\n  /**\n     * Calculate the cross product of two vectors.\n     * @param {Object} v1 - First vector {x, y, z}\n     * @param {Object} v2 - Second vector {x, y, z}\n     * @returns {Object} Cross product vector {x, y, z}\n     * @private\n     */\n  static _crossProduct(v1, v2) {\n    return {\n      x: v1.y * v2.z - v1.z * v2.y,\n      y: v1.z * v2.x - v1.x * v2.z,\n      z: v1.x * v2.y - v1.y * v2.x,\n    };\n  }\n\n  /**\n     * Calculate the length of a vector.\n     * @param {Object} v - Vector {x, y, z}\n     * @returns {number} Vector length\n     * @private\n     */\n  static _vectorLength(v) {\n    return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n  }\n\n  /**\n     * Calculate the approximate 2D distance between two coordinates using Haversine formula.\n     * @param {Coordinate|Object} coord1 - First coordinate\n     * @param {Coordinate|Object} coord2 - Second coordinate\n     * @returns {number} Distance in meters\n     * @private\n     */\n  static _calculateApproximateDistance(coord1, coord2) {\n    const R = this._EARTH_RADIUS_M;\n    const lat1 = coord1.lat * Math.PI / 180;\n    const lat2 = coord2.lat * Math.PI / 180;\n    const dLat = lat2 - lat1;\n    const dLon = (coord2.lng - coord1.lng) * Math.PI / 180;\n\n    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos(lat1) * Math.cos(lat2) *\n            Math.sin(dLon / 2) * Math.sin(dLon / 2);\n    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n\n    return R * c;\n  }\n}","/**\n * Core module for the gis-survey.js library.\n * \n * Provides the foundational 3D coordinate system, transformations,\n * and geometry calculations for the survey tools.\n */\n\n// Export the core classes\nexport { Coordinate } from './Coordinate.js';\nexport { GeoidModel } from './GeoidModel.js';\nexport { TransformerFactory } from './TransformerFactory.js';\nexport { CoordinateTransformer } from './CoordinateTransformer.js';\nexport { SimpleWGS84Transformer } from './SimpleWGS84Transformer.js';\nexport { CoordinateUtils } from './CoordinateUtils.js';\n\n/**\n * Initialize the core geometry module.\n * @param {Object} [options] - Initialization options\n * @param {string} [options.transformerType='simple'] - Type of transformer to use ('simple' or 'proj4js')\n * @param {string} [options.geoidModel='default'] - Geoid model to use for height reference conversions\n * @returns {Promise<boolean>} Promise that resolves when initialization is complete\n */\nexport async function initializeCore(options = {}) {\n  const { \n    transformerType = 'simple',\n    geoidModel = 'default',\n  } = options;\n  \n  // Set the default transformer type\n  if (options.transformerType) {\n    try {\n      const { TransformerFactory } = await import('./TransformerFactory.js');\n      TransformerFactory.setDefaultType(transformerType);\n    } catch (error) {\n      console.error(`Failed to set transformer type: ${error.message}`);\n      return false;\n    }\n  }\n  \n  // Load geoid model if specified\n  if (geoidModel !== 'default') {\n    try {\n      const { GeoidModel } = await import('./GeoidModel.js');\n      await GeoidModel.loadModel(geoidModel);\n    } catch (error) {\n      console.error(`Failed to load geoid model: ${error.message}`);\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Create a coordinate object.\n * Convenience function for creating coordinates.\n * \n * @param {number} lat - Latitude in decimal degrees\n * @param {number} lng - Longitude in decimal degrees\n * @param {number} [elevation=0] - Elevation in meters\n * @param {string} [heightReference='ellipsoidal'] - Height reference system ('ellipsoidal' or 'orthometric')\n * @param {string} [projection='WGS84'] - Coordinate projection system\n * @returns {Coordinate} A new Coordinate object\n */\nexport function createCoordinate(lat, lng, elevation = 0, heightReference = 'ellipsoidal', projection = 'WGS84') {\n  const { Coordinate } = require('./Coordinate.js');\n  return new Coordinate(lat, lng, elevation, heightReference, projection);\n}\n\n/**\n * Get a list of all supported projections.\n * @returns {string[]} Array of supported projection identifiers\n */\nexport function getSupportedProjections() {\n  const { TransformerFactory } = require('./TransformerFactory.js');\n  return TransformerFactory.getAllSupportedProjections();\n}\n\n/**\n * Utility function to create a geojson feature from a coordinate.\n * @param {Coordinate} coordinate - The coordinate to convert\n * @param {Object} [properties={}] - Properties to include in the GeoJSON feature\n * @returns {Object} GeoJSON Feature object\n */\nexport function coordinateToGeoJSON(coordinate, properties = {}) {\n  return {\n    type: 'Feature',\n    geometry: coordinate.toGeoJSON(),\n    properties,\n  };\n}\n\n/**\n * Utility function to create a geojson feature collection from an array of coordinates.\n * @param {Coordinate[]} coordinates - Array of coordinates to convert\n * @param {Object} [properties={}] - Additional properties for the feature collection\n * @returns {Object} GeoJSON FeatureCollection object\n */\nexport function coordinatesToGeoJSON(coordinates, properties = {}) {\n  return {\n    type: 'FeatureCollection',\n    features: coordinates.map((coord, index) => coordinateToGeoJSON(coord, { \n      id: index, \n      ...properties, \n    })),\n    properties,\n  };\n}","/**\n * Base abstract class for all survey features\n * @module gnss/survey/features/FeatureBase\n */\nimport { EventEmitter } from '../core/event-emitter.js';\n\nexport class FeatureBase extends EventEmitter {\n  /**\n     * Initialize a feature\n     * @param {Object} options - Configuration options for the feature\n     * @param {string} [options.id] - Unique identifier for the feature\n     * @param {string} [options.name] - Human-readable name for the feature\n     * @param {Object} [options.style] - Style properties for the feature\n     * @param {Object} [options.properties] - Custom properties for the feature\n     * @param {Object} [options.metadata] - Metadata related to the feature\n     */\n  constructor(options = {}) {\n    super();\n        \n    if (this.constructor === FeatureBase) {\n      throw new Error('Abstract class \\'FeatureBase\\' cannot be instantiated directly.');\n    }\n        \n    this.id = options.id || `feature_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n    this.name = options.name || `Feature ${this.id.substr(-4)}`;\n    this.type = 'feature';\n    this.style = options.style || {};\n    this.properties = options.properties || {};\n    this.metadata = options.metadata || {};\n    this.selected = false;\n    this.visible = options.visible !== false;\n    this.editable = options.editable !== false;\n    this.interactive = options.interactive !== false;\n    this.rendered = null;\n    this.timestamp = options.timestamp || Date.now();\n    this.sourceData = options.sourceData || null;\n  }\n    \n  /**\n     * Get the feature type string\n     * @returns {string} - The feature type\n     */\n  getType() {\n    return this.type;\n  }\n    \n  /**\n     * Get the feature's bounds\n     * @returns {Object} - The bounds object with northEast and southWest coordinates\n     */\n  getBounds() {\n    throw new Error('Method \\'getBounds()\\' must be implemented.');\n  }\n    \n  /**\n     * Get the feature's center coordinate\n     * @returns {Coordinate} - The center coordinate\n     */\n  getCenter() {\n    throw new Error('Method \\'getCenter()\\' must be implemented.');\n  }\n    \n  /**\n     * Get the elevation range of the feature\n     * @returns {Object} - Object with min and max elevations\n     */\n  getElevationRange() {\n    throw new Error('Method \\'getElevationRange()\\' must be implemented.');\n  }\n    \n  /**\n     * Check if the feature contains a coordinate\n     * @param {Coordinate} coordinate - The coordinate to check\n     * @param {Object} [options] - Tolerance and other options\n     * @returns {boolean} - True if the feature contains the coordinate\n     */\n  contains(_coordinate, _options = {}) {\n    throw new Error('Method \\'contains()\\' must be implemented.');\n  }\n    \n  /**\n     * Find the nearest point on the feature to a given coordinate\n     * @param {Coordinate} coordinate - The reference coordinate\n     * @returns {Object} - Object with the nearest point and distance\n     */\n  nearest(_coordinate) {\n    throw new Error('Method \\'nearest()\\' must be implemented.');\n  }\n    \n  /**\n     * Export the feature to GeoJSON\n     * @param {Object} [options] - Export options\n     * @returns {Object} - GeoJSON representation of the feature\n     */\n  toGeoJSON(_options = {}) {\n    throw new Error('Method \\'toGeoJSON()\\' must be implemented.');\n  }\n    \n  /**\n     * Import feature from GeoJSON\n     * @param {Object} geojson - GeoJSON object to import\n     * @param {Object} [options] - Import options\n     * @returns {boolean} - Success status\n     */\n  fromGeoJSON(_geojson, _options = {}) {\n    throw new Error('Method \\'fromGeoJSON()\\' must be implemented.');\n  }\n    \n  /**\n     * Clone this feature\n     * @returns {FeatureBase} - A new feature instance that is a copy of this one\n     */\n  clone() {\n    throw new Error('Method \\'clone()\\' must be implemented.');\n  }\n    \n  /**\n     * Set the feature's style\n     * @param {Object} style - Style properties\n     * @param {Object} [options] - Options for style application\n     */\n  setStyle(style, options = {}) {\n    this.style = { ...this.style, ...style };\n    this.emit('style-changed', { feature: this, style: this.style, options });\n  }\n    \n  /**\n     * Get the feature's style\n     * @returns {Object} - Style properties\n     */\n  getStyle() {\n    return { ...this.style };\n  }\n    \n  /**\n     * Set the feature's properties\n     * @param {Object} properties - Custom properties\n     */\n  setProperties(properties) {\n    this.properties = { ...this.properties, ...properties };\n    this.emit('properties-changed', { feature: this, properties: this.properties });\n  }\n    \n  /**\n     * Get the feature's properties\n     * @returns {Object} - Custom properties\n     */\n  getProperties() {\n    return { ...this.properties };\n  }\n    \n  /**\n     * Get a specific property\n     * @param {string} name - Property name\n     * @returns {*} - Property value\n     */\n  getProperty(name) {\n    return this.properties[name];\n  }\n    \n  /**\n     * Set a specific property\n     * @param {string} name - Property name\n     * @param {*} value - Property value\n     */\n  setProperty(name, value) {\n    this.properties[name] = value;\n    this.emit('property-changed', { feature: this, name, value });\n  }\n    \n  /**\n     * Set the feature's name\n     * @param {string} name - The new name for the feature\n     */\n  setName(name) {\n    this.name = name;\n    this.emit('name-changed', { feature: this, name });\n  }\n    \n  /**\n     * Get the feature's name\n     * @returns {string} - The feature's name\n     */\n  getName() {\n    return this.name;\n  }\n    \n  /**\n     * Select the feature\n     * @param {Object} [options] - Options for selection\n     */\n  select(options = {}) {\n    if (!this.selected) {\n      this.selected = true;\n      this.emit('selected', { feature: this, options });\n    }\n  }\n    \n  /**\n     * Deselect the feature\n     * @param {Object} [options] - Options for deselection\n     */\n  deselect(options = {}) {\n    if (this.selected) {\n      this.selected = false;\n      this.emit('deselected', { feature: this, options });\n    }\n  }\n    \n  /**\n     * Toggle the feature's selection state\n     * @param {Object} [options] - Options for selection toggling\n     * @returns {boolean} - The new selection state\n     */\n  toggleSelection(options = {}) {\n    if (this.selected) {\n      this.deselect(options);\n    } else {\n      this.select(options);\n    }\n    return this.selected;\n  }\n    \n  /**\n     * Show the feature\n     */\n  show() {\n    if (!this.visible) {\n      this.visible = true;\n      this.emit('visibility-changed', { feature: this, visible: true });\n    }\n  }\n    \n  /**\n     * Hide the feature\n     */\n  hide() {\n    if (this.visible) {\n      this.visible = false;\n      this.emit('visibility-changed', { feature: this, visible: false });\n    }\n  }\n    \n  /**\n     * Toggle the feature's visibility\n     * @returns {boolean} - The new visibility state\n     */\n  toggleVisibility() {\n    this.visible = !this.visible;\n    this.emit('visibility-changed', { feature: this, visible: this.visible });\n    return this.visible;\n  }\n    \n  /**\n     * Make the feature editable\n     */\n  enableEditing() {\n    if (!this.editable) {\n      this.editable = true;\n      this.emit('editable-changed', { feature: this, editable: true });\n    }\n  }\n    \n  /**\n     * Make the feature non-editable\n     */\n  disableEditing() {\n    if (this.editable) {\n      this.editable = false;\n      this.emit('editable-changed', { feature: this, editable: false });\n    }\n  }\n    \n  /**\n     * Register a rendered object with this feature\n     * @param {Object} renderedObject - The rendered object\n     */\n  setRendered(renderedObject) {\n    this.rendered = renderedObject;\n  }\n    \n  /**\n     * Get the rendered object for this feature\n     * @returns {Object|null} - The rendered object or null\n     */\n  getRendered() {\n    return this.rendered;\n  }\n    \n  /**\n     * Check if the feature has a valid rendered object\n     * @returns {boolean} - True if the feature has a rendered object\n     */\n  isRendered() {\n    return this.rendered !== null;\n  }\n}","/**\n * Point feature class for survey points\n * @module gnss/survey/features/PointFeature\n */\nimport { FeatureBase } from './FeatureBase.js';\nimport { Coordinate } from '../core/Coordinate.js';\nimport { GeometryEngine } from '../core/GeometryEngine.js';\n\nexport class PointFeature extends FeatureBase {\n  /**\n     * Initialize a point feature\n     * @param {Coordinate|Object} coordinate - The point's coordinate\n     * @param {Object} [options] - Configuration options\n     * @param {string} [options.id] - Unique identifier\n     * @param {string} [options.name] - Human-readable name\n     * @param {Object} [options.style] - Style properties\n     * @param {Object} [options.properties] - Custom properties\n     * @param {Object} [options.metadata] - Metadata\n     */\n  constructor(coordinate, options = {}) {\n    super(options);\n        \n    this.type = 'point';\n        \n    // Handle different input types\n    if (coordinate instanceof Coordinate) {\n      // Use the Coordinate instance directly\n      this.coordinate = coordinate;\n    } else if (typeof coordinate === 'object') {\n      if (coordinate.latitude !== undefined && coordinate.longitude !== undefined) {\n        // Object with latitude/longitude properties\n        const elevationVal = coordinate.elevation !== undefined ? coordinate.elevation :\n          (coordinate.alt !== undefined ? coordinate.alt : null);\n\n        // Create compatible coordinate object\n        this.coordinate = {\n          lat: coordinate.latitude,\n          lng: coordinate.longitude,\n          elevation: elevationVal,\n          toString: function() { return `${this.lat}, ${this.lng}, ${this.elevation || 0}`; },\n        };\n      } else if (coordinate.lat !== undefined && coordinate.lng !== undefined) {\n        // Google Maps-style object with lat/lng - use directly with minimal modifications\n        const elevationVal = coordinate.elevation !== undefined ? coordinate.elevation :\n          (coordinate.alt !== undefined ? coordinate.alt : null);\n\n        // Ensure it has all expected properties\n        if (!coordinate.toString) {\n          coordinate.toString = function() { return `${this.lat}, ${this.lng}, ${this.elevation || 0}`; };\n        }\n\n        // Store elevation if available\n        if (elevationVal !== null && elevationVal !== undefined) {\n          coordinate.elevation = elevationVal;\n        }\n\n        this.coordinate = coordinate;\n      } else if (Array.isArray(coordinate) && coordinate.length >= 2) {\n        // Array [lng, lat, elevation] (GeoJSON style)\n        const lat = coordinate[1];\n        const lng = coordinate[0];\n        const elevation = coordinate.length > 2 ? coordinate[2] : null;\n                \n        // Create compatible coordinate object\n        this.coordinate = {\n          lat: lat,\n          lng: lng,\n          elevation: elevation,\n          toString: function() { return `${this.lat}, ${this.lng}, ${this.elevation || 0}`; },\n        };\n      } else {\n        console.error('Invalid coordinate format:', coordinate);\n        throw new Error('Invalid coordinate format');\n      }\n    } else {\n      console.error('Invalid coordinate type:', typeof coordinate);\n      throw new Error('Point feature requires a valid coordinate');\n    }\n        \n    // If no name was provided, generate a coordinate-based name\n    if (!options.name) {\n      // Create a name that works with any coordinate format\n      const lat = this.coordinate.lat || this.coordinate.latitude;\n      const lng = this.coordinate.lng || this.coordinate.longitude;\n      this.name = `Point ${lat.toFixed(5)}, ${lng.toFixed(5)}`;\n    }\n        \n    // Store elevation in properties too for easy access\n    const elevation = this.coordinate.elevation;\n    if (elevation !== null && elevation !== undefined) {\n      this.properties.elevation = elevation;\n    }\n  }\n    \n  /**\n     * Get the point's coordinate\n     * @returns {Coordinate|Object} - The coordinate\n     */\n  getCoordinate() {\n    // Return the stored coordinate, which may be a Coordinate instance\n    // or a compatible coordinate-like object\n    return this.coordinate;\n  }\n    \n  /**\n     * Set the point's coordinate\n     * @param {Coordinate|Object} coordinate - The new coordinate\n     */\n  setCoordinate(coordinate) {\n    // Accept either Coordinate instances or coordinate-like objects\n    if (coordinate && (coordinate instanceof Coordinate || \n            (typeof coordinate === 'object' && \n             (coordinate.lat !== undefined || coordinate.latitude !== undefined)))) {\n            \n      // Store the coordinate directly\n      this.coordinate = coordinate;\n            \n      // Extract elevation consistently regardless of coordinate type\n      const elevation = coordinate.elevation !== undefined ? coordinate.elevation :\n        coordinate.alt !== undefined ? coordinate.alt : null;\n            \n      // Update elevation property\n      if (elevation !== null && elevation !== undefined) {\n        this.properties.elevation = elevation;\n      } else {\n        delete this.properties.elevation;\n      }\n            \n      this.emit('geometry-changed', { feature: this, coordinate: this.coordinate });\n    } else {\n      console.error('Invalid coordinate format:', coordinate);\n      throw new Error('Coordinate must be a valid coordinate-like object');\n    }\n  }\n    \n  /**\n     * Get the feature's bounds\n     * @returns {Object} - The bounds object with northEast and southWest coordinates\n     */\n  getBounds() {\n    // For a point, the bounds are the same point\n    return {\n      northEast: this.coordinate.clone(),\n      southWest: this.coordinate.clone(),\n      north: this.coordinate.lat,\n      east: this.coordinate.lng,\n      south: this.coordinate.lat,\n      west: this.coordinate.lng,\n    };\n  }\n    \n  /**\n     * Get the feature's center coordinate\n     * @returns {Coordinate} - The center coordinate\n     */\n  getCenter() {\n    return this.coordinate;\n  }\n    \n  /**\n     * Get the elevation range of the feature\n     * @returns {Object} - Object with min and max elevations\n     */\n  getElevationRange() {\n    const elevation = this.coordinate.elevation || 0;\n    return {\n      min: elevation,\n      max: elevation,\n      range: 0,\n    };\n  }\n    \n  /**\n     * Check if the feature contains a coordinate\n     * @param {Coordinate|Object} coordinate - The coordinate to check\n     * @param {Object} [options] - Tolerance and other options\n     * @param {number} [options.tolerance=0] - Distance tolerance in meters\n     * @param {boolean} [options.includeElevation=false] - Whether to consider elevation\n     * @returns {boolean} - True if the feature contains the coordinate\n     */\n  contains(coordinate, options = {}) {\n    // Check if we have a valid coordinate-like object\n    if (!coordinate || typeof coordinate !== 'object' || \n            (coordinate.lat === undefined && coordinate.latitude === undefined)) {\n      console.error('Invalid coordinate format:', coordinate);\n      return false;\n    }\n        \n    const tolerance = options.tolerance || 0;\n        \n    if (tolerance === 0) {\n      // Exact match only - simple comparison of lat/lng\n      const checkLat = this.coordinate.lat || this.coordinate.latitude;\n      const checkLng = this.coordinate.lng || this.coordinate.longitude;\n      const coordLat = coordinate.lat || coordinate.latitude;\n      const coordLng = coordinate.lng || coordinate.longitude;\n            \n      // Check for exact match\n      return checkLat === coordLat && checkLng === coordLng;\n    } else {\n      // Within tolerance distance - use GeometryEngine with any coordinate-like object\n      try {\n        const distance = GeometryEngine.calculateDistance(\n          this.coordinate, \n          coordinate, \n          { includeElevation: options.includeElevation },\n        );\n        return distance <= tolerance;\n      } catch (error) {\n        console.error('Error calculating distance for contains check:', error);\n        return false;\n      }\n    }\n  }\n    \n  /**\n     * Find the nearest point on the feature to a given coordinate\n     * @param {Coordinate|Object} coordinate - The reference coordinate\n     * @returns {Object} - Object with the nearest point and distance\n     */\n  nearest(coordinate) {\n    // Check if we have a valid coordinate-like object\n    if (!coordinate || typeof coordinate !== 'object' || \n            (coordinate.lat === undefined && coordinate.latitude === undefined)) {\n      console.error('Invalid coordinate format:', coordinate);\n      throw new Error('Coordinate must be a valid coordinate-like object');\n    }\n        \n    try {\n      const distance = GeometryEngine.calculateDistance(\n        this.coordinate, \n        coordinate, \n        { includeElevation: true },\n      );\n            \n      // Return a simple object with the result\n      return {\n        // Just return the original coordinate, no need to clone\n        coordinate: this.coordinate,\n        distance,\n      };\n    } catch (error) {\n      console.error('Error calculating nearest point:', error);\n      return {\n        coordinate: this.coordinate,\n        distance: Infinity,\n      };\n    }\n  }\n    \n  /**\n     * Export the feature to GeoJSON\n     * @param {Object} [options] - Export options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation\n     * @param {boolean} [options.includeProperties=true] - Whether to include properties\n     * @returns {Object} - GeoJSON representation of the feature\n     */\n  toGeoJSON(options = {}) {\n    const includeElevation = options.includeElevation !== false;\n    const includeProperties = options.includeProperties !== false;\n        \n    const geojson = {\n      type: 'Feature',\n      geometry: {\n        type: 'Point',\n        coordinates: [\n          this.coordinate.lng,\n          this.coordinate.lat,\n        ],\n      },\n      id: this.id,\n    };\n        \n    // Include elevation if available and requested\n    if (includeElevation && this.coordinate.elevation !== null && this.coordinate.elevation !== undefined) {\n      geojson.geometry.coordinates.push(this.coordinate.elevation);\n    }\n        \n    // Include properties if requested\n    if (includeProperties) {\n      geojson.properties = {\n        name: this.name,\n        ...this.properties,\n      };\n    }\n        \n    return geojson;\n  }\n    \n  /**\n     * Import feature from GeoJSON\n     * @param {Object} geojson - GeoJSON object to import\n     * @param {Object} [options] - Import options\n     * @returns {boolean} - Success status\n     */\n  fromGeoJSON(geojson, _options = {}) {\n    if (!geojson || geojson.type !== 'Feature' || !geojson.geometry || \n            geojson.geometry.type !== 'Point' || !Array.isArray(geojson.geometry.coordinates)) {\n      return false;\n    }\n        \n    const coords = geojson.geometry.coordinates;\n    if (coords.length < 2) {\n      return false;\n    }\n        \n    // Extract coordinates (GeoJSON format is [longitude, latitude, elevation?])\n    const longitude = coords[0];\n    const latitude = coords[1];\n    const elevation = coords.length > 2 ? coords[2] : null;\n        \n    // Create new coordinate\n    this.coordinate = new Coordinate(latitude, longitude, elevation);\n        \n    // Update properties\n    if (geojson.properties) {\n      if (geojson.properties.name) {\n        this.name = geojson.properties.name;\n        delete geojson.properties.name;\n      }\n            \n      this.properties = { ...geojson.properties };\n    }\n        \n    // Update ID if provided\n    if (geojson.id) {\n      this.id = geojson.id;\n    }\n        \n    // Store elevation in properties too for easy access\n    if (elevation !== null && elevation !== undefined) {\n      this.properties.elevation = elevation;\n    }\n        \n    this.emit('geometry-changed', { feature: this, coordinate: this.coordinate });\n    return true;\n  }\n    \n  /**\n     * Clone this feature\n     * @returns {PointFeature} - A new point feature instance that is a copy of this one\n     */\n  clone() {\n    const cloned = new PointFeature(\n      this.coordinate.clone(),\n      {\n        id: `clone_${this.id}`,\n        name: `${this.name} (copy)`,\n        style: { ...this.style },\n        properties: { ...this.properties },\n        metadata: { ...this.metadata },\n        visible: this.visible,\n        editable: this.editable,\n        interactive: this.interactive,\n      },\n    );\n        \n    return cloned;\n  }\n    \n  /**\n     * Calculate distance to another point\n     * @param {PointFeature|Coordinate} point - The other point\n     * @param {Object} [options] - Distance calculation options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation\n     * @returns {number} - Distance in meters\n     */\n  distanceTo(point, options = {}) {\n    const otherCoord = point instanceof PointFeature ? point.getCoordinate() : point;\n        \n    if (!(otherCoord instanceof Coordinate)) {\n      throw new Error('Point must be a PointFeature or Coordinate');\n    }\n        \n    return GeometryEngine.calculateDistance(\n      this.coordinate, \n      otherCoord, \n      { includeElevation: options.includeElevation !== false },\n    );\n  }\n    \n  /**\n     * Calculate bearing to another point\n     * @param {PointFeature|Coordinate} point - The other point\n     * @returns {number} - Bearing in degrees (0-360)\n     */\n  bearingTo(point) {\n    const otherCoord = point instanceof PointFeature ? point.getCoordinate() : point;\n        \n    if (!(otherCoord instanceof Coordinate)) {\n      throw new Error('Point must be a PointFeature or Coordinate');\n    }\n        \n    return GeometryEngine.calculateBearing(this.coordinate, otherCoord);\n  }\n    \n  /**\n     * Move the point by a specified distance and bearing\n     * @param {number} distance - Distance to move in meters\n     * @param {number} bearing - Bearing in degrees (0 = north, 90 = east, etc.)\n     * @param {Object} [options] - Movement options\n     * @param {boolean} [options.preserveElevation=true] - Keep the same elevation\n     * @returns {PointFeature} - This feature for chaining\n     */\n  moveByDistanceAndBearing(distance, bearing, options = {}) {\n    const preserveElevation = options.preserveElevation !== false;\n    const elevation = preserveElevation ? this.coordinate.elevation : null;\n        \n    const newCoord = GeometryEngine.destinationCoordinate(\n      this.coordinate, \n      distance, \n      bearing,\n    );\n        \n    if (preserveElevation && elevation !== null && elevation !== undefined) {\n      newCoord.elevation = elevation;\n    }\n        \n    this.setCoordinate(newCoord);\n    return this;\n  }\n    \n  /**\n     * Move the point to a specific coordinate\n     * @param {Coordinate} coordinate - The new coordinate\n     * @returns {PointFeature} - This feature for chaining\n     */\n  moveTo(coordinate) {\n    this.setCoordinate(coordinate);\n    return this;\n  }\n}","/**\n * Line feature class for survey lines and polylines\n * @module gnss/survey/features/LineFeature\n */\nimport { FeatureBase } from './FeatureBase.js';\nimport { Coordinate } from '../core/Coordinate.js';\nimport { GeometryEngine } from '../core/GeometryEngine.js';\n\nexport class LineFeature extends FeatureBase {\n  /**\n     * Initialize a line feature\n     * @param {Array<Coordinate>} coordinates - The line's coordinates\n     * @param {Object} [options] - Configuration options\n     * @param {string} [options.id] - Unique identifier\n     * @param {string} [options.name] - Human-readable name\n     * @param {Object} [options.style] - Style properties\n     * @param {Object} [options.properties] - Custom properties\n     * @param {Object} [options.metadata] - Metadata\n     * @param {boolean} [options.closed=false] - Whether the line forms a closed loop\n     */\n  constructor(coordinates = [], options = {}) {\n    super(options);\n        \n    this.type = 'line';\n    this.closed = options.closed || false;\n        \n    // Validate and convert coordinates\n    this.coordinates = this._validateCoordinates(coordinates);\n        \n    // Update properties with metadata about the line\n    this._updateProperties();\n        \n    // If no name was provided, generate a default name\n    if (!options.name) {\n      this.name = this.closed ? \n        `Closed Line (${this.coordinates.length} vertices)` : \n        `Line (${this.coordinates.length} vertices)`;\n    }\n  }\n    \n  /**\n     * Validate and convert coordinate array\n     * @param {Array} coordinates - Array of coordinates in various formats\n     * @returns {Array<Coordinate>} - Array of Coordinate objects\n     * @private\n     */\n  _validateCoordinates(coordinates) {\n    if (!Array.isArray(coordinates)) {\n      throw new Error('Coordinates must be an array');\n    }\n        \n    return coordinates.map(coord => {\n      if (coord instanceof Coordinate) {\n        return coord;\n      } else if (typeof coord === 'object') {\n        if (coord.latitude !== undefined && coord.longitude !== undefined) {\n          // Object with lat/lng properties\n          const elevation = coord.elevation !== undefined ? coord.elevation : \n            (coord.alt !== undefined ? coord.alt : null);\n          return new Coordinate(coord.latitude, coord.longitude, elevation);\n        } else if (coord.lat !== undefined && coord.lng !== undefined) {\n          // Google Maps-style object\n          const elevation = coord.elevation !== undefined ? coord.elevation : \n            (coord.alt !== undefined ? coord.alt : null);\n          return new Coordinate(coord.lat, coord.lng, elevation);\n        } else if (Array.isArray(coord) && coord.length >= 2) {\n          // Array [lng, lat, elevation] (GeoJSON style)\n          return new Coordinate(coord[1], coord[0], coord[2] || null);\n        }\n      }\n            \n      throw new Error('Invalid coordinate format in array');\n    });\n  }\n    \n  /**\n     * Update internal properties with metadata about the line\n     * @private\n     */\n  _updateProperties() {\n    if (this.coordinates.length < 2) {\n      this.properties.length = 0;\n      return;\n    }\n        \n    // Calculate length\n    this.properties.length = GeometryEngine.calculatePathLength(this.coordinates, { includeElevation: true });\n        \n    // Get elevation statistics\n    const elevations = this.coordinates\n      .map(coord => coord.elevation)\n      .filter(elev => elev !== null && elev !== undefined);\n        \n    if (elevations.length > 0) {\n      this.properties.minElevation = Math.min(...elevations);\n      this.properties.maxElevation = Math.max(...elevations);\n      this.properties.elevationGain = GeometryEngine.calculateElevationGain(this.coordinates);\n      this.properties.elevationLoss = GeometryEngine.calculateElevationLoss(this.coordinates);\n    }\n  }\n    \n  /**\n     * Get the line's coordinates\n     * @returns {Array<Coordinate>} - Array of coordinates\n     */\n  getCoordinates() {\n    return [...this.coordinates];\n  }\n    \n  /**\n     * Set the line's coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates\n     */\n  setCoordinates(coordinates) {\n    this.coordinates = this._validateCoordinates(coordinates);\n    this._updateProperties();\n    this.emit('geometry-changed', { feature: this, coordinates: this.coordinates });\n  }\n    \n  /**\n     * Add a coordinate to the line\n     * @param {Coordinate} coordinate - The coordinate to add\n     * @param {number} [index] - Optional index to insert at (default: end of line)\n     */\n  addCoordinate(coordinate, index = null) {\n    if (!(coordinate instanceof Coordinate)) {\n      throw new Error('Coordinate must be an instance of Coordinate class');\n    }\n        \n    if (index === null) {\n      // Add to end\n      this.coordinates.push(coordinate);\n    } else {\n      // Insert at specific index\n      this.coordinates.splice(index, 0, coordinate);\n    }\n        \n    this._updateProperties();\n    this.emit('geometry-changed', { \n      feature: this, \n      coordinates: this.coordinates,\n      action: 'add',\n      coordinate,\n      index: index === null ? this.coordinates.length - 1 : index,\n    });\n  }\n    \n  /**\n     * Remove a coordinate from the line\n     * @param {number} index - Index of the coordinate to remove\n     * @returns {Coordinate|null} - The removed coordinate or null if index was invalid\n     */\n  removeCoordinate(index) {\n    if (index < 0 || index >= this.coordinates.length) {\n      return null;\n    }\n        \n    const removed = this.coordinates.splice(index, 1)[0];\n    this._updateProperties();\n        \n    this.emit('geometry-changed', { \n      feature: this, \n      coordinates: this.coordinates,\n      action: 'remove',\n      coordinate: removed,\n      index,\n    });\n        \n    return removed;\n  }\n    \n  /**\n     * Update a coordinate at a specific index\n     * @param {number} index - Index of the coordinate to update\n     * @param {Coordinate} coordinate - The new coordinate\n     * @returns {boolean} - Success status\n     */\n  updateCoordinate(index, coordinate) {\n    if (index < 0 || index >= this.coordinates.length) {\n      return false;\n    }\n        \n    if (!(coordinate instanceof Coordinate)) {\n      throw new Error('Coordinate must be an instance of Coordinate class');\n    }\n        \n    const oldCoord = this.coordinates[index];\n    this.coordinates[index] = coordinate;\n    this._updateProperties();\n        \n    this.emit('geometry-changed', { \n      feature: this, \n      coordinates: this.coordinates,\n      action: 'update',\n      oldCoordinate: oldCoord,\n      newCoordinate: coordinate,\n      index,\n    });\n        \n    return true;\n  }\n    \n  /**\n     * Get the number of vertices in the line\n     * @returns {number} - Vertex count\n     */\n  getVertexCount() {\n    return this.coordinates.length;\n  }\n    \n  /**\n     * Get a specific vertex by index\n     * @param {number} index - Index of the vertex\n     * @returns {Coordinate|null} - The coordinate or null if index is invalid\n     */\n  getVertex(index) {\n    if (index < 0 || index >= this.coordinates.length) {\n      return null;\n    }\n        \n    return this.coordinates[index];\n  }\n    \n  /**\n     * Toggle the closed state of the line\n     * @returns {boolean} - The new closed state\n     */\n  toggleClosed() {\n    this.closed = !this.closed;\n    this._updateProperties();\n        \n    this.emit('closed-changed', { \n      feature: this, \n      closed: this.closed, \n    });\n        \n    return this.closed;\n  }\n    \n  /**\n     * Set the closed state of the line\n     * @param {boolean} closed - Whether the line should be closed\n     */\n  setClosed(closed) {\n    if (this.closed !== closed) {\n      this.closed = closed;\n      this._updateProperties();\n            \n      this.emit('closed-changed', { \n        feature: this, \n        closed: this.closed, \n      });\n    }\n  }\n    \n  /**\n     * Check if the line is closed\n     * @returns {boolean} - True if the line is closed\n     */\n  isClosed() {\n    return this.closed;\n  }\n    \n  /**\n     * Get the feature's bounds\n     * @returns {Object} - The bounds object with northEast and southWest coordinates\n     */\n  getBounds() {\n    if (this.coordinates.length === 0) {\n      return null;\n    }\n        \n    let north = -90;\n    let south = 90;\n    let east = -180;\n    let west = 180;\n        \n    for (const coord of this.coordinates) {\n      north = Math.max(north, coord.lat);\n      south = Math.min(south, coord.lat);\n      east = Math.max(east, coord.lng);\n      west = Math.min(west, coord.lng);\n    }\n        \n    return {\n      north,\n      south,\n      east,\n      west,\n      northEast: new Coordinate(north, east),\n      southWest: new Coordinate(south, west),\n    };\n  }\n    \n  /**\n     * Get the feature's center coordinate\n     * @returns {Coordinate} - The center coordinate\n     */\n  getCenter() {\n    if (this.coordinates.length === 0) {\n      return null;\n    } else if (this.coordinates.length === 1) {\n      return this.coordinates[0];\n    }\n        \n    // Use the GeometryEngine to calculate the center\n    return GeometryEngine.calculatePathCenter(this.coordinates);\n  }\n    \n  /**\n     * Get the elevation range of the feature\n     * @returns {Object} - Object with min, max, and range elevations\n     */\n  getElevationRange() {\n    if (this.coordinates.length === 0) {\n      return { min: 0, max: 0, range: 0 };\n    }\n        \n    const elevations = this.coordinates\n      .map(coord => coord.elevation)\n      .filter(elev => elev !== null && elev !== undefined);\n        \n    if (elevations.length === 0) {\n      return { min: 0, max: 0, range: 0 };\n    }\n        \n    const min = Math.min(...elevations);\n    const max = Math.max(...elevations);\n        \n    return {\n      min,\n      max,\n      range: max - min,\n    };\n  }\n    \n  /**\n     * Check if the feature contains a coordinate\n     * @param {Coordinate} coordinate - The coordinate to check\n     * @param {Object} [options] - Tolerance and other options\n     * @param {number} [options.tolerance=0] - Distance tolerance in meters\n     * @param {boolean} [options.includeElevation=false] - Whether to consider elevation\n     * @returns {boolean} - True if the feature contains the coordinate\n     */\n  contains(coordinate, options = {}) {\n    if (this.coordinates.length < 2) {\n      return false;\n    }\n        \n    if (!(coordinate instanceof Coordinate)) {\n      throw new Error('Coordinate must be an instance of Coordinate class');\n    }\n        \n    const tolerance = options.tolerance || 0;\n        \n    // Check if the coordinate is on the line within tolerance\n    const nearest = this.nearest(coordinate);\n        \n    return nearest.distance <= tolerance;\n  }\n    \n  /**\n     * Find the nearest point on the feature to a given coordinate\n     * @param {Coordinate} coordinate - The reference coordinate\n     * @returns {Object} - Object with the nearest point, distance, and segment index\n     */\n  nearest(coordinate) {\n    if (this.coordinates.length < 2) {\n      if (this.coordinates.length === 1) {\n        const distance = GeometryEngine.calculateDistance(\n          this.coordinates[0], \n          coordinate, \n          { includeElevation: true },\n        );\n                \n        return {\n          coordinate: this.coordinates[0].clone(),\n          distance,\n          segmentIndex: 0,\n          segmentFraction: 0,\n        };\n      }\n            \n      return {\n        coordinate: null,\n        distance: Infinity,\n        segmentIndex: -1,\n        segmentFraction: 0,\n      };\n    }\n        \n    if (!(coordinate instanceof Coordinate)) {\n      throw new Error('Coordinate must be an instance of Coordinate class');\n    }\n        \n    // Use the GeometryEngine to find the nearest point on the path\n    return GeometryEngine.calculateNearestPointOnPath(this.coordinates, coordinate, { closed: this.closed });\n  }\n    \n  /**\n     * Export the feature to GeoJSON\n     * @param {Object} [options] - Export options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation\n     * @param {boolean} [options.includeProperties=true] - Whether to include properties\n     * @returns {Object} - GeoJSON representation of the feature\n     */\n  toGeoJSON(options = {}) {\n    const includeElevation = options.includeElevation !== false;\n    const includeProperties = options.includeProperties !== false;\n        \n    // Determine if this should be a LineString or a Polygon\n    const type = this.closed ? 'Polygon' : 'LineString';\n        \n    let coordinates;\n        \n    if (type === 'LineString') {\n      // LineString - array of coordinates\n      coordinates = this.coordinates.map(coord => {\n        // Use lng/lat instead of longitude/latitude as that's how they're stored in Coordinate\n        const point = [coord.lng, coord.lat];\n        if (includeElevation && coord.elevation !== null && coord.elevation !== undefined) {\n          point.push(coord.elevation);\n        }\n        return point;\n      });\n    } else {\n      // Polygon - array of linear rings (arrays of coordinates)\n      // Make a copy of coordinates that closes the ring if needed\n      const ring = [...this.coordinates];\n      if (ring.length > 0 && \n                (ring[0].lat !== ring[ring.length - 1].lat || \n                 ring[0].lng !== ring[ring.length - 1].lng)) {\n        ring.push(ring[0]);\n      }\n            \n      coordinates = [ring.map(coord => {\n        // Use lng/lat instead of longitude/latitude as that's how they're stored in Coordinate\n        const point = [coord.lng, coord.lat];\n        if (includeElevation && coord.elevation !== null && coord.elevation !== undefined) {\n          point.push(coord.elevation);\n        }\n        return point;\n      })];\n    }\n        \n    const geojson = {\n      type: 'Feature',\n      geometry: {\n        type,\n        coordinates,\n      },\n      id: this.id,\n    };\n        \n    // Include properties if requested\n    if (includeProperties) {\n      geojson.properties = {\n        name: this.name,\n        ...this.properties,\n      };\n    }\n        \n    return geojson;\n  }\n    \n  /**\n     * Import feature from GeoJSON\n     * @param {Object} geojson - GeoJSON object to import\n     * @param {Object} [options] - Import options\n     * @returns {boolean} - Success status\n     */\n  fromGeoJSON(geojson, _options = {}) {\n    if (!geojson || geojson.type !== 'Feature' || !geojson.geometry) {\n      return false;\n    }\n        \n    const geometryType = geojson.geometry.type;\n    let newCoordinates = [];\n    let isClosed = false;\n        \n    if (geometryType === 'LineString') {\n      if (!Array.isArray(geojson.geometry.coordinates)) {\n        return false;\n      }\n            \n      // Process LineString coordinates\n      newCoordinates = geojson.geometry.coordinates.map(coords => {\n        if (!Array.isArray(coords) || coords.length < 2) {\n          throw new Error('Invalid GeoJSON LineString coordinates');\n        }\n                \n        return new Coordinate(\n          coords[1], \n          coords[0], \n          coords.length > 2 ? coords[2] : null,\n        );\n      });\n            \n      // Check if the line is closed\n      const first = newCoordinates[0];\n      const last = newCoordinates[newCoordinates.length - 1];\n            \n      if (first && last && \n                first.lat === last.lat && \n                first.lng === last.lng) {\n        isClosed = true;\n      }\n            \n    } else if (geometryType === 'Polygon') {\n      if (!Array.isArray(geojson.geometry.coordinates) || \n                !Array.isArray(geojson.geometry.coordinates[0])) {\n        return false;\n      }\n            \n      // Process Polygon coordinates (use the exterior ring only)\n      const ring = geojson.geometry.coordinates[0];\n            \n      newCoordinates = ring.map(coords => {\n        if (!Array.isArray(coords) || coords.length < 2) {\n          throw new Error('Invalid GeoJSON Polygon coordinates');\n        }\n                \n        return new Coordinate(\n          coords[1], \n          coords[0], \n          coords.length > 2 ? coords[2] : null,\n        );\n      });\n            \n      // Polygons should be closed, but we'll check anyway\n      const first = newCoordinates[0];\n      const last = newCoordinates[newCoordinates.length - 1];\n            \n      if (first && last && \n                first.latitude === last.latitude && \n                first.longitude === last.longitude) {\n        // Remove the duplicate closing point\n        newCoordinates.pop();\n      }\n            \n      isClosed = true;\n            \n    } else {\n      return false;\n    }\n        \n    // Update the feature\n    this.coordinates = newCoordinates;\n    this.closed = isClosed;\n        \n    // Update properties\n    if (geojson.properties) {\n      if (geojson.properties.name) {\n        this.name = geojson.properties.name;\n        delete geojson.properties.name;\n      }\n            \n      this.properties = { ...geojson.properties };\n    }\n        \n    // Update ID if provided\n    if (geojson.id) {\n      this.id = geojson.id;\n    }\n        \n    this._updateProperties();\n    this.emit('geometry-changed', { feature: this, coordinates: this.coordinates });\n        \n    return true;\n  }\n    \n  /**\n     * Clone this feature\n     * @returns {LineFeature} - A new line feature instance that is a copy of this one\n     */\n  clone() {\n    const clonedCoordinates = this.coordinates.map(coord => coord.clone());\n        \n    const cloned = new LineFeature(\n      clonedCoordinates,\n      {\n        id: `clone_${this.id}`,\n        name: `${this.name} (copy)`,\n        style: { ...this.style },\n        properties: { ...this.properties },\n        metadata: { ...this.metadata },\n        visible: this.visible,\n        editable: this.editable,\n        interactive: this.interactive,\n        closed: this.closed,\n      },\n    );\n        \n    return cloned;\n  }\n    \n  /**\n     * Calculate the length of the line\n     * @param {Object} [options] - Calculation options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation\n     * @returns {number} - Length in meters\n     */\n  calculateLength(options = {}) {\n    if (this.coordinates.length < 2) {\n      return 0;\n    }\n        \n    return GeometryEngine.calculatePathLength(\n      this.coordinates, \n      { \n        includeElevation: options.includeElevation !== false,\n        closed: this.closed,\n      },\n    );\n  }\n    \n  /**\n     * Calculate the area of the closed line\n     * @param {Object} [options] - Calculation options\n     * @returns {number} - Area in square meters\n     */\n  calculateArea(options = {}) {\n    if (!this.closed || this.coordinates.length < 3) {\n      return 0;\n    }\n        \n    return GeometryEngine.calculateArea(this.coordinates, options);\n  }\n    \n  /**\n     * Create an elevation profile for the line\n     * @returns {Array<Object>} - Array of {distance, elevation} points\n     */\n  createElevationProfile() {\n    if (this.coordinates.length < 2) {\n      return [];\n    }\n        \n    return GeometryEngine.createElevationProfile(this.coordinates);\n  }\n    \n  /**\n     * Calculate the elevation gain and loss\n     * @returns {Object} - Object with gain and loss in meters\n     */\n  calculateElevationChange() {\n    if (this.coordinates.length < 2) {\n      return { gain: 0, loss: 0 };\n    }\n        \n    return {\n      gain: GeometryEngine.calculateElevationGain(this.coordinates),\n      loss: GeometryEngine.calculateElevationLoss(this.coordinates),\n    };\n  }\n    \n  /**\n     * Create offset line parallel to this line\n     * @param {number} distance - Offset distance in meters (positive = right, negative = left)\n     * @param {Object} [options] - Offset options\n     * @returns {LineFeature} - New line feature with the offset coordinates\n     */\n  createOffsetLine(distance, options = {}) {\n    if (this.coordinates.length < 2) {\n      return this.clone();\n    }\n        \n    const offsetCoords = GeometryEngine.createOffsetLine(\n      this.coordinates, \n      distance, \n      { \n        closed: this.closed,\n        ...options,\n      },\n    );\n        \n    return new LineFeature(\n      offsetCoords,\n      {\n        name: `${this.name} (offset ${distance}m)`,\n        style: { ...this.style },\n        closed: this.closed,\n      },\n    );\n  }\n    \n  /**\n     * Simplify the line by removing redundant points\n     * @param {number} tolerance - Tolerance distance in meters\n     * @returns {LineFeature} - This feature for chaining\n     */\n  simplify(tolerance) {\n    if (this.coordinates.length < 3 || tolerance <= 0) {\n      return this;\n    }\n        \n    const simplified = GeometryEngine.simplifyPath(this.coordinates, tolerance);\n    this.setCoordinates(simplified);\n        \n    return this;\n  }\n    \n  /**\n     * Create points at regular intervals along the line\n     * @param {number} interval - Distance between points in meters\n     * @param {Object} [options] - Interpolation options\n     * @returns {Array<Coordinate>} - Array of coordinates\n     */\n  createRegularPoints(interval, options = {}) {\n    if (this.coordinates.length < 2 || interval <= 0) {\n      return [];\n    }\n        \n    return GeometryEngine.createRegularPointsAlongPath(\n      this.coordinates, \n      interval, \n      { \n        closed: this.closed,\n        ...options,\n      },\n    );\n  }\n    \n  /**\n     * Get a point at a specific percentage along the line\n     * @param {number} percentage - Percentage along the line (0-100)\n     * @returns {Coordinate} - The coordinate at that percentage\n     */\n  getPointAtPercentage(percentage) {\n    if (this.coordinates.length < 2) {\n      return null;\n    }\n        \n    if (percentage < 0) percentage = 0;\n    if (percentage > 100) percentage = 100;\n        \n    const distance = (percentage / 100) * this.calculateLength();\n    return this.getPointAtDistance(distance);\n  }\n    \n  /**\n     * Get a point at a specific distance along the line\n     * @param {number} distance - Distance along the line in meters\n     * @returns {Coordinate} - The coordinate at that distance\n     */\n  getPointAtDistance(distance) {\n    if (this.coordinates.length < 2) {\n      return null;\n    }\n        \n    return GeometryEngine.getPointAtDistance(this.coordinates, distance, { closed: this.closed });\n  }\n    \n  /**\n     * Split the line at a specific vertex\n     * @param {number} index - Index of the vertex to split at\n     * @returns {Array<LineFeature>} - Array of two line features\n     */\n  splitAtVertex(index) {\n    if (index <= 0 || index >= this.coordinates.length - 1) {\n      return [this.clone()];\n    }\n        \n    const part1 = new LineFeature(\n      this.coordinates.slice(0, index + 1),\n      {\n        name: `${this.name} (part 1)`,\n        style: { ...this.style },\n        closed: false,\n      },\n    );\n        \n    const part2 = new LineFeature(\n      this.coordinates.slice(index),\n      {\n        name: `${this.name} (part 2)`,\n        style: { ...this.style },\n        closed: false,\n      },\n    );\n        \n    return [part1, part2];\n  }\n    \n  /**\n     * Reverse the order of coordinates\n     * @returns {LineFeature} - This feature for chaining\n     */\n  reverse() {\n    this.coordinates.reverse();\n    this.emit('geometry-changed', { feature: this, coordinates: this.coordinates });\n    return this;\n  }\n}","/**\n * Polygon feature class for survey areas\n * @module gnss/survey/features/PolygonFeature\n */\nimport { FeatureBase } from './FeatureBase.js';\nimport { LineFeature } from './LineFeature.js';\nimport { Coordinate } from '../core/Coordinate.js';\nimport { GeometryEngine } from '../core/GeometryEngine.js';\n\nexport class PolygonFeature extends FeatureBase {\n  /**\n     * Initialize a polygon feature\n     * @param {Array<Coordinate>} coordinates - The polygon's exterior ring coordinates\n     * @param {Object} [options] - Configuration options\n     * @param {string} [options.id] - Unique identifier\n     * @param {string} [options.name] - Human-readable name\n     * @param {Object} [options.style] - Style properties\n     * @param {Object} [options.properties] - Custom properties\n     * @param {Object} [options.metadata] - Metadata\n     * @param {Array<Array<Coordinate>>} [options.holes=[]] - Arrays of coordinates for interior rings (holes)\n     */\n  constructor(coordinates = [], options = {}) {\n    super(options);\n        \n    this.type = 'polygon';\n        \n    // Create with internal LineFeature objects for ring management\n    this.exteriorRing = new LineFeature(coordinates, { closed: true });\n        \n    // Interior rings (holes)\n    this.interiorRings = [];\n        \n    if (options.holes && Array.isArray(options.holes)) {\n      for (const holeCoords of options.holes) {\n        this.interiorRings.push(\n          new LineFeature(holeCoords, { closed: true }),\n        );\n      }\n    }\n        \n    // Update properties with metadata about the polygon\n    this._updateProperties();\n        \n    // If no name was provided, generate a default name\n    if (!options.name) {\n      this.name = `Polygon (${this.exteriorRing.getVertexCount()} vertices)`;\n    }\n        \n    // Set up event forwarding from rings\n    this._setupEventForwarding();\n  }\n    \n  /**\n     * Set up event forwarding from the rings to this polygon\n     * @private\n     */\n  _setupEventForwarding() {\n    // Forward events from exterior ring\n    this.exteriorRing.on('geometry-changed', event => {\n      this._updateProperties();\n      this.emit('geometry-changed', { \n        feature: this, \n        ring: 'exterior',\n        ringIndex: -1,\n        ...event,\n      });\n    });\n        \n    // Set up forwarding for interior rings too\n    for (let i = 0; i < this.interiorRings.length; i++) {\n      const ring = this.interiorRings[i];\n            \n      ring.on('geometry-changed', event => {\n        this._updateProperties();\n        this.emit('geometry-changed', { \n          feature: this, \n          ring: 'interior',\n          ringIndex: i,\n          ...event,\n        });\n      });\n    }\n  }\n    \n  /**\n     * Update internal properties with metadata about the polygon\n     * @private\n     */\n  _updateProperties() {\n    // Make sure we have enough coordinates before calculating properties\n    const exteriorCoords = this.exteriorRing.getCoordinates();\n    if (exteriorCoords.length < 3) {\n      // Set default values for incomplete polygons\n      this.properties.area = 0;\n      this.properties.perimeter = 0;\n      return;\n    }\n        \n    // Calculate area\n    this.properties.area = this.calculateArea();\n        \n    // Calculate perimeter (exterior ring length)\n    this.properties.perimeter = this.exteriorRing.calculateLength();\n        \n    // Get elevation statistics\n    const elevations = exteriorCoords\n      .map(coord => coord.elevation)\n      .filter(elev => elev !== null && elev !== undefined);\n        \n    if (elevations.length > 0) {\n      this.properties.minElevation = Math.min(...elevations);\n      this.properties.maxElevation = Math.max(...elevations);\n      this.properties.averageElevation = elevations.reduce((sum, elev) => sum + elev, 0) / elevations.length;\n    }\n        \n    // Update approximate centroid\n    try {\n      const center = this.calculateCentroid();\n      if (center) {\n        this.properties.centroid = {\n          lat: center.lat,\n          lng: center.lng,\n        };\n      }\n    } catch (error) {\n      console.warn(`Could not calculate centroid: ${error.message}`);\n    }\n  }\n    \n  /**\n     * Get the polygon's exterior ring coordinates\n     * @returns {Array<Coordinate>} - Array of coordinates\n     */\n  getCoordinates() {\n    return this.exteriorRing.getCoordinates();\n  }\n    \n  /**\n     * Set the polygon's exterior ring coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates\n     */\n  setCoordinates(coordinates) {\n    this.exteriorRing.setCoordinates(coordinates);\n    // _updateProperties is called via event forwarding\n  }\n    \n  /**\n     * Get all interior rings (holes)\n     * @returns {Array<Array<Coordinate>>} - Array of coordinate arrays\n     */\n  getHoles() {\n    return this.interiorRings.map(ring => ring.getCoordinates());\n  }\n    \n  /**\n     * Get all rings (exterior and interior)\n     * @returns {Array<Array<Coordinate>>} - Array of coordinate arrays, where first array is exterior ring\n     */\n  getRings() {\n    const rings = [this.exteriorRing.getCoordinates()];\n    return rings.concat(this.getHoles());\n  }\n    \n  /**\n     * Set all rings (exterior and interior)\n     * @param {Array<Array<Coordinate>>} rings - Array of coordinate arrays where first array is exterior ring\n     */\n  setRings(rings) {\n    if (!rings || !Array.isArray(rings) || rings.length === 0) {\n      throw new Error('Invalid rings: must provide a non-empty array of coordinate arrays');\n    }\n        \n    // Set exterior ring (first ring)\n    this.exteriorRing.setCoordinates(rings[0]);\n        \n    // Clear existing interior rings\n    this.interiorRings = [];\n        \n    // Add interior rings (if any)\n    for (let i = 1; i < rings.length; i++) {\n      this.addHole(rings[i]);\n    }\n        \n    // Update properties\n    this._updateProperties();\n  }\n    \n  /**\n     * Get a specific interior ring\n     * @param {number} index - Index of the ring\n     * @returns {Array<Coordinate>|null} - Array of coordinates or null if index is invalid\n     */\n  getHole(index) {\n    if (index < 0 || index >= this.interiorRings.length) {\n      return null;\n    }\n        \n    return this.interiorRings[index].getCoordinates();\n  }\n    \n  /**\n     * Add a new hole to the polygon\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the hole\n     * @returns {number} - Index of the new hole\n     */\n  addHole(coordinates) {\n    const hole = new LineFeature(coordinates, { closed: true });\n        \n    // Set up event forwarding\n    const holeIndex = this.interiorRings.length;\n        \n    hole.on('geometry-changed', event => {\n      this._updateProperties();\n      this.emit('geometry-changed', { \n        feature: this, \n        ring: 'interior',\n        ringIndex: holeIndex,\n        ...event,\n      });\n    });\n        \n    this.interiorRings.push(hole);\n    this._updateProperties();\n        \n    this.emit('hole-added', { \n      feature: this, \n      holeIndex, \n      coordinates: hole.getCoordinates(), \n    });\n        \n    return holeIndex;\n  }\n    \n  /**\n     * Remove a hole from the polygon\n     * @param {number} index - Index of the hole to remove\n     * @returns {boolean} - Success status\n     */\n  removeHole(index) {\n    if (index < 0 || index >= this.interiorRings.length) {\n      return false;\n    }\n        \n    const removed = this.interiorRings.splice(index, 1)[0];\n    this._updateProperties();\n        \n    this.emit('hole-removed', { \n      feature: this, \n      holeIndex: index, \n      coordinates: removed.getCoordinates(), \n    });\n        \n    return true;\n  }\n    \n  /**\n     * Update a hole's coordinates\n     * @param {number} index - Index of the hole\n     * @param {Array<Coordinate>} coordinates - New coordinates\n     * @returns {boolean} - Success status\n     */\n  updateHole(index, coordinates) {\n    if (index < 0 || index >= this.interiorRings.length) {\n      return false;\n    }\n        \n    this.interiorRings[index].setCoordinates(coordinates);\n    // _updateProperties is called via event forwarding\n        \n    return true;\n  }\n    \n  /**\n     * Get the number of holes in the polygon\n     * @returns {number} - Hole count\n     */\n  getHoleCount() {\n    return this.interiorRings.length;\n  }\n    \n  /**\n     * Add a vertex to the exterior ring\n     * @param {Coordinate} coordinate - The coordinate to add\n     * @param {number} [index] - Optional index to insert at (default: end of ring)\n     */\n  addVertex(coordinate, index = null) {\n    this.exteriorRing.addCoordinate(coordinate, index);\n    // _updateProperties is called via event forwarding\n  }\n    \n  /**\n     * Remove a vertex from the exterior ring\n     * @param {number} index - Index of the vertex to remove\n     * @returns {Coordinate|null} - The removed coordinate or null if index was invalid\n     */\n  removeVertex(index) {\n    return this.exteriorRing.removeCoordinate(index);\n    // _updateProperties is called via event forwarding\n  }\n    \n  /**\n     * Update a vertex in the exterior ring\n     * @param {number} index - Index of the vertex to update\n     * @param {Coordinate} coordinate - The new coordinate\n     * @returns {boolean} - Success status\n     */\n  updateVertex(index, coordinate) {\n    return this.exteriorRing.updateCoordinate(index, coordinate);\n    // _updateProperties is called via event forwarding\n  }\n    \n  /**\n     * Get the number of vertices in the exterior ring\n     * @returns {number} - Vertex count\n     */\n  getVertexCount() {\n    return this.exteriorRing.getVertexCount();\n  }\n    \n  /**\n     * Get a specific vertex from the exterior ring\n     * @param {number} index - Index of the vertex\n     * @returns {Coordinate|null} - The coordinate or null if index is invalid\n     */\n  getVertex(index) {\n    return this.exteriorRing.getVertex(index);\n  }\n    \n  /**\n     * Get the feature's bounds\n     * @returns {Object} - The bounds object with northEast and southWest coordinates\n     */\n  getBounds() {\n    return this.exteriorRing.getBounds();\n  }\n    \n  /**\n     * Get the feature's center coordinate\n     * @returns {Coordinate} - The center coordinate\n     */\n  getCenter() {\n    return this.calculateCentroid();\n  }\n    \n  /**\n     * Calculate the centroid of the polygon\n     * @returns {Coordinate} - The centroid coordinate\n     */\n  calculateCentroid() {\n    return GeometryEngine.calculatePolygonCentroid(\n      this.exteriorRing.getCoordinates(),\n      this.getHoles(),\n    );\n  }\n    \n  /**\n     * Get the elevation range of the feature\n     * @returns {Object} - Object with min, max, and range elevations\n     */\n  getElevationRange() {\n    // First get elevation range from exterior ring\n    const exteriorRange = this.exteriorRing.getElevationRange();\n        \n    // If there are no interior rings, just return exterior range\n    if (this.interiorRings.length === 0) {\n      return exteriorRange;\n    }\n        \n    // Otherwise, combine with interior rings\n    let min = exteriorRange.min;\n    let max = exteriorRange.max;\n        \n    for (const ring of this.interiorRings) {\n      const ringRange = ring.getElevationRange();\n            \n      if (ringRange.min < min) min = ringRange.min;\n      if (ringRange.max > max) max = ringRange.max;\n    }\n        \n    return {\n      min,\n      max,\n      range: max - min,\n    };\n  }\n    \n  /**\n     * Check if the polygon contains a coordinate\n     * @param {Coordinate} coordinate - The coordinate to check\n     * @param {Object} [options] - Tolerance and other options\n     * @returns {boolean} - True if the polygon contains the coordinate\n     */\n  contains(coordinate, _options = {}) {\n    if (!(coordinate instanceof Coordinate)) {\n      throw new Error('Coordinate must be an instance of Coordinate class');\n    }\n        \n    const exteriorCoords = this.exteriorRing.getCoordinates();\n    if (exteriorCoords.length < 3) {\n      return false;\n    }\n        \n    // First check if the point is in the exterior ring\n    const inExterior = GeometryEngine.pointInPolygon(coordinate, exteriorCoords);\n        \n    // If not in exterior, definitely not in polygon\n    if (!inExterior) {\n      return false;\n    }\n        \n    // If in exterior, check if it's in any holes\n    for (const hole of this.interiorRings) {\n      if (GeometryEngine.pointInPolygon(coordinate, hole.getCoordinates())) {\n        // If in a hole, not in the polygon\n        return false;\n      }\n    }\n        \n    // In exterior but not in any holes\n    return true;\n  }\n    \n  /**\n     * Find the nearest point on the feature to a given coordinate\n     * @param {Coordinate} coordinate - The reference coordinate\n     * @returns {Object} - Object with the nearest point and distance\n     */\n  nearest(coordinate) {\n    if (!(coordinate instanceof Coordinate)) {\n      throw new Error('Coordinate must be an instance of Coordinate class');\n    }\n        \n    // First check if the point is inside the polygon\n    if (this.contains(coordinate)) {\n      // If inside, distance is 0\n      return {\n        coordinate: coordinate.clone(),\n        distance: 0,\n        isInterior: true,\n      };\n    }\n        \n    // Otherwise, find nearest point on exterior ring\n    const exteriorNearest = this.exteriorRing.nearest(coordinate);\n        \n    // Find nearest points on all holes too\n    let minDistance = exteriorNearest.distance;\n    let nearestPoint = exteriorNearest.coordinate;\n        \n    for (const hole of this.interiorRings) {\n      const holeNearest = hole.nearest(coordinate);\n            \n      if (holeNearest.distance < minDistance) {\n        minDistance = holeNearest.distance;\n        nearestPoint = holeNearest.coordinate;\n      }\n    }\n        \n    return {\n      coordinate: nearestPoint,\n      distance: minDistance,\n      isInterior: false,\n    };\n  }\n    \n  /**\n     * Export the feature to GeoJSON\n     * @param {Object} [options] - Export options\n     * @param {boolean} [options.includeElevation=true] - Whether to include elevation\n     * @param {boolean} [options.includeProperties=true] - Whether to include properties\n     * @returns {Object} - GeoJSON representation of the feature\n     */\n  toGeoJSON(options = {}) {\n    const includeElevation = options.includeElevation !== false;\n    const includeProperties = options.includeProperties !== false;\n        \n    // Get exterior ring and ensure it's closed\n    const exteriorCoords = this.exteriorRing.getCoordinates();\n    const exteriorRing = [...exteriorCoords];\n        \n    // Ensure exterior ring is closed as required by GeoJSON\n    if (exteriorRing.length > 0 && \n            (exteriorRing[0].lat !== exteriorRing[exteriorRing.length - 1].lat || \n             exteriorRing[0].lng !== exteriorRing[exteriorRing.length - 1].lng)) {\n      exteriorRing.push(exteriorRing[0]);\n    }\n        \n    // Convert exterior ring to GeoJSON format\n    const exteriorRingGeoJSON = exteriorRing.map(coord => {\n      // Use lng/lat instead of longitude/latitude as that's how they're stored in Coordinate\n      const point = [coord.lng, coord.lat];\n      if (includeElevation && coord.elevation !== null && coord.elevation !== undefined) {\n        point.push(coord.elevation);\n      }\n      return point;\n    });\n        \n    // Convert interior rings to GeoJSON format\n    const interiorRingsGeoJSON = this.interiorRings.map(ring => {\n      let holeCoords = ring.getCoordinates();\n            \n      // Ensure hole is closed as required by GeoJSON\n      if (holeCoords.length > 0 && \n                (holeCoords[0].lat !== holeCoords[holeCoords.length - 1].lat || \n                 holeCoords[0].lng !== holeCoords[holeCoords.length - 1].lng)) {\n        holeCoords = [...holeCoords, holeCoords[0]];\n      }\n            \n      return holeCoords.map(coord => {\n        // Use lng/lat instead of longitude/latitude as that's how they're stored in Coordinate\n        const point = [coord.lng, coord.lat];\n        if (includeElevation && coord.elevation !== null && coord.elevation !== undefined) {\n          point.push(coord.elevation);\n        }\n        return point;\n      });\n    });\n        \n    // Create the GeoJSON object\n    const geojson = {\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [exteriorRingGeoJSON, ...interiorRingsGeoJSON],\n      },\n      id: this.id,\n    };\n        \n    // Include properties if requested\n    if (includeProperties) {\n      geojson.properties = {\n        name: this.name,\n        ...this.properties,\n      };\n    }\n        \n    return geojson;\n  }\n    \n  /**\n     * Import feature from GeoJSON\n     * @param {Object} geojson - GeoJSON object to import\n     * @param {Object} [options] - Import options\n     * @returns {boolean} - Success status\n     */\n  fromGeoJSON(geojson, _options = {}) {\n    if (!geojson || geojson.type !== 'Feature' || !geojson.geometry || \n            geojson.geometry.type !== 'Polygon' || !Array.isArray(geojson.geometry.coordinates)) {\n      return false;\n    }\n        \n    const rings = geojson.geometry.coordinates;\n    if (rings.length === 0 || !Array.isArray(rings[0])) {\n      return false;\n    }\n        \n    // Process exterior ring (first ring)\n    const exteriorRingCoords = rings[0].map(coords => {\n      if (!Array.isArray(coords) || coords.length < 2) {\n        throw new Error('Invalid GeoJSON Polygon coordinates');\n      }\n            \n      return new Coordinate(\n        coords[1], \n        coords[0], \n        coords.length > 2 ? coords[2] : null,\n      );\n    });\n        \n    // Ensure exterior ring is not closed for internal representation\n    // (GeoJSON has explicit closing point, but we handle closing automatically)\n    if (exteriorRingCoords.length > 0 && \n            exteriorRingCoords[0].equals(exteriorRingCoords[exteriorRingCoords.length - 1])) {\n      exteriorRingCoords.pop();\n    }\n        \n    // Set exterior ring\n    this.exteriorRing.setCoordinates(exteriorRingCoords);\n        \n    // Remove all existing holes\n    this.interiorRings = [];\n        \n    // Process interior rings (holes)\n    for (let i = 1; i < rings.length; i++) {\n      const ring = rings[i];\n            \n      const holeCoords = ring.map(coords => {\n        if (!Array.isArray(coords) || coords.length < 2) {\n          throw new Error('Invalid GeoJSON Polygon hole coordinates');\n        }\n                \n        return new Coordinate(\n          coords[1], \n          coords[0], \n          coords.length > 2 ? coords[2] : null,\n        );\n      });\n            \n      // Ensure hole is not closed for internal representation\n      if (holeCoords.length > 0 && \n                holeCoords[0].equals(holeCoords[holeCoords.length - 1])) {\n        holeCoords.pop();\n      }\n            \n      // Add new hole\n      this.addHole(holeCoords);\n    }\n        \n    // Update properties\n    if (geojson.properties) {\n      if (geojson.properties.name) {\n        this.name = geojson.properties.name;\n        delete geojson.properties.name;\n      }\n            \n      this.properties = { ...geojson.properties };\n    }\n        \n    // Update ID if provided\n    if (geojson.id) {\n      this.id = geojson.id;\n    }\n        \n    this._updateProperties();\n    this.emit('geometry-changed', { feature: this });\n        \n    return true;\n  }\n    \n  /**\n     * Clone this feature\n     * @returns {PolygonFeature} - A new polygon feature instance that is a copy of this one\n     */\n  clone() {\n    const clonedExteriorCoords = this.exteriorRing.getCoordinates().map(coord => coord.clone());\n        \n    const clonedHoles = this.interiorRings.map(ring => \n      ring.getCoordinates().map(coord => coord.clone()),\n    );\n        \n    const cloned = new PolygonFeature(\n      clonedExteriorCoords,\n      {\n        id: `clone_${this.id}`,\n        name: `${this.name} (copy)`,\n        style: { ...this.style },\n        properties: { ...this.properties },\n        metadata: { ...this.metadata },\n        visible: this.visible,\n        editable: this.editable,\n        interactive: this.interactive,\n        holes: clonedHoles,\n      },\n    );\n        \n    return cloned;\n  }\n    \n  /**\n     * Calculate the area of the polygon\n     * @param {Object} [options] - Calculation options\n     * @param {boolean} [options.includeHoles=true] - Whether to subtract hole areas\n     * @returns {number} - Area in square meters\n     */\n  calculateArea(options = {}) {\n    const includeHoles = options.includeHoles !== false;\n        \n    const exteriorCoords = this.exteriorRing.getCoordinates();\n    if (exteriorCoords.length < 3) {\n      return 0;\n    }\n        \n    // Calculate exterior area\n    let area = GeometryEngine.calculateArea(exteriorCoords);\n        \n    // Subtract hole areas if requested\n    if (includeHoles && this.interiorRings.length > 0) {\n      for (const hole of this.interiorRings) {\n        const holeCoords = hole.getCoordinates();\n        if (holeCoords.length < 3) continue;\n                \n        const holeArea = GeometryEngine.calculateArea(holeCoords);\n        area -= holeArea;\n      }\n    }\n        \n    return area;\n  }\n    \n  /**\n     * Calculate the perimeter of the polygon\n     * @param {Object} [options] - Calculation options\n     * @param {boolean} [options.includeHoles=true] - Whether to include hole perimeters\n     * @returns {number} - Perimeter in meters\n     */\n  calculatePerimeter(options = {}) {\n    const includeHoles = options.includeHoles !== false;\n        \n    // Calculate exterior perimeter\n    let perimeter = this.exteriorRing.calculateLength();\n        \n    // Add hole perimeters if requested\n    if (includeHoles && this.interiorRings.length > 0) {\n      for (const hole of this.interiorRings) {\n        perimeter += hole.calculateLength();\n      }\n    }\n        \n    return perimeter;\n  }\n    \n  /**\n     * Create a simplified version of the polygon\n     * @param {number} tolerance - Tolerance distance in meters\n     * @returns {PolygonFeature} - A new simplified polygon feature\n     */\n  simplify(tolerance) {\n    if (tolerance <= 0) {\n      return this.clone();\n    }\n        \n    const simplifiedExterior = GeometryEngine.simplifyPath(\n      this.exteriorRing.getCoordinates(), \n      tolerance,\n    );\n        \n    const simplifiedHoles = this.interiorRings.map(ring => \n      GeometryEngine.simplifyPath(ring.getCoordinates(), tolerance),\n    );\n        \n    return new PolygonFeature(\n      simplifiedExterior,\n      {\n        name: `${this.name} (simplified)`,\n        style: { ...this.style },\n        holes: simplifiedHoles,\n      },\n    );\n  }\n    \n  /**\n     * Create a buffered polygon around this polygon\n     * @param {number} distance - Buffer distance in meters\n     * @param {Object} [options] - Buffer options\n     * @returns {PolygonFeature} - A new polygon feature representing the buffer\n     */\n  buffer(distance, options = {}) {\n    const exteriorCoords = this.exteriorRing.getCoordinates();\n    if (exteriorCoords.length < 3) {\n      return this.clone();\n    }\n        \n    const bufferedExterior = GeometryEngine.bufferPolygon(\n      exteriorCoords, \n      distance, \n      options,\n    );\n        \n    // Buffering with negative distance could create multiple polygons\n    // For simplicity, we just return the first one\n    return new PolygonFeature(\n      bufferedExterior,\n      {\n        name: `${this.name} (buffer ${distance}m)`,\n        style: { ...this.style },\n      },\n    );\n  }\n    \n  /**\n     * Check if the polygon is valid (no self-intersections)\n     * @returns {boolean} - True if the polygon is valid\n     */\n  isValid() {\n    const exteriorCoords = this.exteriorRing.getCoordinates();\n    if (exteriorCoords.length < 3) {\n      return false;\n    }\n        \n    // Check exterior ring for self-intersections\n    if (GeometryEngine.hasSelfIntersections(exteriorCoords)) {\n      return false;\n    }\n        \n    // Check each hole for self-intersections\n    for (const hole of this.interiorRings) {\n      const holeCoords = hole.getCoordinates();\n      if (holeCoords.length < 3) continue;\n            \n      if (GeometryEngine.hasSelfIntersections(holeCoords)) {\n        return false;\n      }\n            \n      // Check if hole is inside the exterior ring\n      const holeCenter = GeometryEngine.calculatePathCenter(holeCoords);\n      if (!GeometryEngine.pointInPolygon(holeCenter, exteriorCoords)) {\n        return false;\n      }\n            \n      // Check if hole intersects with exterior ring\n      if (GeometryEngine.doPathsIntersect(exteriorCoords, holeCoords)) {\n        return false;\n      }\n            \n      // Check if hole intersects with other holes\n      for (const otherHole of this.interiorRings) {\n        if (hole === otherHole) continue;\n                \n        const otherHoleCoords = otherHole.getCoordinates();\n        if (GeometryEngine.doPathsIntersect(holeCoords, otherHoleCoords)) {\n          return false;\n        }\n      }\n    }\n        \n    return true;\n  }\n    \n  /**\n     * Calculate the surface of the polygon considering elevation\n     * @returns {number} - Surface area in square meters\n     */\n  calculate3DSurfaceArea() {\n    // Implement using TIN (Triangulated Irregular Network)\n    // This is a simplified implementation\n    return GeometryEngine.calculate3DPolygonSurfaceArea(\n      this.exteriorRing.getCoordinates(),\n      this.getHoles(),\n    );\n  }\n    \n  /**\n     * Calculate the volume of the polygon\n     * @param {Object} [options] - Calculation options\n     * @param {number} [options.baseElevation] - Base elevation in meters\n     * @returns {number} - Volume in cubic meters\n     */\n  calculateVolume(options = {}) {\n    let baseElevation;\n        \n    if (options.baseElevation !== undefined) {\n      baseElevation = options.baseElevation;\n    } else {\n      // Use minimum elevation as base\n      const elevRange = this.getElevationRange();\n      baseElevation = elevRange.min;\n    }\n        \n    return GeometryEngine.calculatePolygonVolume(\n      this.exteriorRing.getCoordinates(),\n      this.getHoles(),\n      baseElevation,\n    );\n  }\n}","/**\n * Feature collection for managing groups of features\n * @module gnss/survey/features/FeatureCollection\n */\nimport { EventEmitter } from '../core/event-emitter.js';\nimport { FeatureBase } from './FeatureBase.js';\nimport { PointFeature } from './PointFeature.js';\nimport { LineFeature } from './LineFeature.js';\nimport { PolygonFeature } from './PolygonFeature.js';\nimport { Coordinate } from '../core/Coordinate.js';\n\n/**\n * Class for managing collections of features\n */\nexport class FeatureCollection extends EventEmitter {\n  /**\n     * Initialize a feature collection\n     * @param {Array<FeatureBase>} [features=[]] - Initial features\n     * @param {Object} [options] - Configuration options\n     * @param {string} [options.id] - Unique identifier for the collection\n     * @param {string} [options.name] - Human-readable name for the collection\n     */\n  constructor(features = [], options = {}) {\n    super();\n        \n    this.id = options.id || `collection_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n    this.name = options.name || `Collection ${this.id.substr(-4)}`;\n    this.features = new Map();\n        \n    // Add initial features\n    if (Array.isArray(features)) {\n      features.forEach(feature => this.addFeature(feature));\n    }\n  }\n    \n  /**\n     * Add a feature to the collection\n     * @param {FeatureBase} feature - The feature to add\n     * @returns {string} - The feature ID\n     */\n  addFeature(feature) {\n    if (!(feature instanceof FeatureBase)) {\n      throw new Error('Feature must be an instance of FeatureBase');\n    }\n        \n    this.features.set(feature.id, feature);\n        \n    // Listen for feature events\n    feature.on('geometry-changed', event => {\n      this.emit('feature-geometry-changed', { ...event, collection: this });\n    });\n        \n    feature.on('properties-changed', event => {\n      this.emit('feature-properties-changed', { ...event, collection: this });\n    });\n        \n    feature.on('style-changed', event => {\n      this.emit('feature-style-changed', { ...event, collection: this });\n    });\n        \n    feature.on('selected', event => {\n      this.emit('feature-selected', { ...event, collection: this });\n    });\n        \n    feature.on('deselected', event => {\n      this.emit('feature-deselected', { ...event, collection: this });\n    });\n        \n    feature.on('visibility-changed', event => {\n      this.emit('feature-visibility-changed', { ...event, collection: this });\n    });\n        \n    this.emit('feature-added', { feature, collection: this });\n        \n    return feature.id;\n  }\n    \n  /**\n     * Remove a feature from the collection\n     * @param {string|FeatureBase} featureOrId - The feature or its ID to remove\n     * @returns {boolean} - Success status\n     */\n  removeFeature(featureOrId) {\n    const featureId = featureOrId instanceof FeatureBase ? featureOrId.id : featureOrId;\n        \n    if (!this.features.has(featureId)) {\n      return false;\n    }\n        \n    const feature = this.features.get(featureId);\n    this.features.delete(featureId);\n        \n    // Remove all listeners\n    feature.removeAllListeners();\n        \n    this.emit('feature-removed', { feature, collection: this });\n        \n    return true;\n  }\n    \n  /**\n     * Get a feature by ID\n     * @param {string} id - The feature ID\n     * @returns {FeatureBase|undefined} - The feature or undefined if not found\n     */\n  getFeature(id) {\n    return this.features.get(id);\n  }\n    \n  /**\n     * Check if the collection contains a specific feature\n     * @param {string|FeatureBase} featureOrId - The feature or its ID to check\n     * @returns {boolean} - True if the feature is in the collection\n     */\n  hasFeature(featureOrId) {\n    const featureId = featureOrId instanceof FeatureBase ? featureOrId.id : featureOrId;\n    return this.features.has(featureId);\n  }\n    \n  /**\n     * Get all features in the collection\n     * @returns {Array<FeatureBase>} - Array of features\n     */\n  getAllFeatures() {\n    return Array.from(this.features.values());\n  }\n    \n  /**\n     * Get features of a specific type\n     * @param {string} type - Feature type ('point', 'line', 'polygon', etc.)\n     * @returns {Array<FeatureBase>} - Array of features of the specified type\n     */\n  getFeaturesByType(type) {\n    return this.getAllFeatures().filter(feature => feature.type === type);\n  }\n    \n  /**\n     * Get features that match a predicate function\n     * @param {Function} predicate - Function that returns true for features to include\n     * @returns {Array<FeatureBase>} - Array of matching features\n     */\n  findFeatures(predicate) {\n    return this.getAllFeatures().filter(predicate);\n  }\n    \n  /**\n     * Get the number of features in the collection\n     * @returns {number} - Feature count\n     */\n  getFeatureCount() {\n    return this.features.size;\n  }\n    \n  /**\n     * Get the count of features by type\n     * @returns {Object} - Object with type counts\n     */\n  getFeatureCountsByType() {\n    const counts = {};\n        \n    this.getAllFeatures().forEach(feature => {\n      counts[feature.type] = (counts[feature.type] || 0) + 1;\n    });\n        \n    return counts;\n  }\n    \n  /**\n     * Clear all features from the collection\n     */\n  clear() {\n    const featuresToRemove = this.getAllFeatures();\n        \n    featuresToRemove.forEach(feature => {\n      this.removeFeature(feature);\n    });\n        \n    this.emit('collection-cleared', { collection: this });\n  }\n    \n  /**\n     * Select all features in the collection\n     * @param {Object} [options] - Selection options\n     */\n  selectAll(options = {}) {\n    this.getAllFeatures().forEach(feature => {\n      if (!feature.selected) {\n        feature.select(options);\n      }\n    });\n  }\n    \n  /**\n     * Deselect all features in the collection\n     * @param {Object} [options] - Deselection options\n     */\n  deselectAll(options = {}) {\n    this.getAllFeatures().forEach(feature => {\n      if (feature.selected) {\n        feature.deselect(options);\n      }\n    });\n  }\n    \n  /**\n     * Get selected features\n     * @returns {Array<FeatureBase>} - Array of selected features\n     */\n  getSelectedFeatures() {\n    return this.getAllFeatures().filter(feature => feature.selected);\n  }\n    \n  /**\n     * Set visibility for all features\n     * @param {boolean} visible - Whether features should be visible\n     */\n  setAllVisible(visible) {\n    this.getAllFeatures().forEach(feature => {\n      if (feature.visible !== visible) {\n        if (visible) {\n          feature.show();\n        } else {\n          feature.hide();\n        }\n      }\n    });\n  }\n    \n  /**\n     * Get visible features\n     * @returns {Array<FeatureBase>} - Array of visible features\n     */\n  getVisibleFeatures() {\n    return this.getAllFeatures().filter(feature => feature.visible);\n  }\n    \n  /**\n     * Export the collection to GeoJSON\n     * @param {Object} [options] - Export options\n     * @returns {Object} - GeoJSON FeatureCollection\n     */\n  toGeoJSON(options = {}) {\n    console.log('Exporting FeatureCollection to GeoJSON, feature count:', this.features.size);\n        \n    const features = this.getAllFeatures()\n      .filter(feature => options.includeHidden || feature.visible)\n      .map(feature => {\n        console.log(`Processing feature for export: ${feature.id}, type: ${feature.type}`);\n        if (feature.type === 'line' || feature.type === 'polygon') {\n          console.log(`  Coordinates count: ${feature.getCoordinates().length}`);\n        }\n        const geojson = feature.toGeoJSON(options);\n                \n        // Validate the created GeoJSON feature\n        if (geojson.geometry) {\n          if (geojson.geometry.type === 'LineString' && Array.isArray(geojson.geometry.coordinates)) {\n            console.log(`  LineString exported with ${geojson.geometry.coordinates.length} coordinates`);\n          } else if (geojson.geometry.type === 'Polygon' && Array.isArray(geojson.geometry.coordinates) && \n                              geojson.geometry.coordinates.length > 0) {\n            console.log(`  Polygon exported with ${geojson.geometry.coordinates[0].length} coordinates in exterior ring`);\n          }\n        } else {\n          console.warn(`  Warning: No geometry in exported feature ${feature.id}`);\n        }\n                \n        return geojson;\n      });\n        \n    return {\n      type: 'FeatureCollection',\n      features,\n    };\n  }\n    \n  /**\n     * Import features from GeoJSON\n     * @param {Object} geojson - GeoJSON object\n     * @param {Object} [options] - Import options\n     * @returns {number} - Number of features imported\n     */\n  fromGeoJSON(geojson, options = {}) {\n    if (!geojson) {\n      return 0;\n    }\n        \n    let features = [];\n        \n    // Handle feature collection\n    if (geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)) {\n      features = geojson.features;\n    } \n    // Handle single feature\n    else if (geojson.type === 'Feature') {\n      features = [geojson];\n    }\n        \n    // Import all valid features\n    let importCount = 0;\n        \n    for (const featureJson of features) {\n      if (!featureJson || !featureJson.geometry || !featureJson.geometry.type) {\n        continue;\n      }\n            \n      try {\n        // Create the appropriate feature type\n        let feature;\n                \n        switch (featureJson.geometry.type) {\n        case 'Point':\n          feature = new PointFeature(featureJson.geometry.coordinates, { id: featureJson.id });\n          break;\n        case 'LineString':\n          // Pass the coordinates from GeoJSON directly to LineFeature constructor \n          feature = new LineFeature(\n            featureJson.geometry.coordinates.map(coords => \n              new Coordinate(coords[1], coords[0], coords.length > 2 ? coords[2] : null),\n            ),\n            { id: featureJson.id },\n          );\n          break;\n        case 'Polygon':\n          // For polygons, use the first ring (exterior) as constructor coordinates\n          if (featureJson.geometry.coordinates && featureJson.geometry.coordinates.length > 0) {\n            const exteriorRing = featureJson.geometry.coordinates[0].map(coords =>\n              new Coordinate(coords[1], coords[0], coords.length > 2 ? coords[2] : null),\n            );\n                            \n            // Create holes array for additional rings if they exist\n            const holes = [];\n            for (let i = 1; i < featureJson.geometry.coordinates.length; i++) {\n              holes.push(\n                featureJson.geometry.coordinates[i].map(coords =>\n                  new Coordinate(coords[1], coords[0], coords.length > 2 ? coords[2] : null),\n                ),\n              );\n            }\n                            \n            feature = new PolygonFeature(exteriorRing, { \n              id: featureJson.id,\n              holes: holes,\n            });\n          } else {\n            feature = new PolygonFeature([], { id: featureJson.id });\n          }\n          break;\n        default:\n          console.warn(`Unsupported GeoJSON geometry type: ${featureJson.geometry.type}`);\n          continue;\n        }\n                \n        // Directly add the feature if we constructed it with coordinates already\n        if (featureJson.geometry.type === 'LineString' || featureJson.geometry.type === 'Polygon') {\n          // Need to handle properties\n          if (featureJson.properties) {\n            if (featureJson.properties.name) {\n              feature.name = featureJson.properties.name;\n            }\n            // Copy all properties\n            feature.properties = { ...featureJson.properties };\n          }\n                    \n          this.addFeature(feature);\n          importCount++;\n        }\n        // Let the feature handle import itself for other types\n        else if (feature.fromGeoJSON(featureJson, options)) {\n          this.addFeature(feature);\n          importCount++;\n        }\n      } catch (err) {\n        console.error('Error importing GeoJSON feature:', err);\n      }\n    }\n        \n    if (importCount > 0) {\n      this.emit('features-imported', { \n        count: importCount, \n        collection: this, \n      });\n    }\n        \n    return importCount;\n  }\n    \n  /**\n     * Get the combined bounds of all features\n     * @returns {Object|null} - Bounds object or null if collection is empty\n     */\n  getBounds() {\n    const features = this.getAllFeatures();\n        \n    if (features.length === 0) {\n      return null;\n    }\n        \n    // Start with the bounds of the first feature\n    const firstBounds = features[0].getBounds();\n    if (!firstBounds) {\n      return null;\n    }\n        \n    let north = firstBounds.north;\n    let south = firstBounds.south;\n    let east = firstBounds.east;\n    let west = firstBounds.west;\n        \n    // Expand to include all other features\n    for (let i = 1; i < features.length; i++) {\n      const bounds = features[i].getBounds();\n      if (!bounds) continue;\n            \n      if (bounds.north > north) north = bounds.north;\n      if (bounds.south < south) south = bounds.south;\n      if (bounds.east > east) east = bounds.east;\n      if (bounds.west < west) west = bounds.west;\n    }\n        \n    // Coordinate is already imported at the top of the file\n        \n    return {\n      north,\n      south,\n      east,\n      west,\n      northEast: new Coordinate(north, east),\n      southWest: new Coordinate(south, west),\n    };\n  }\n    \n  /**\n     * Apply a style to all features\n     * @param {Object} style - Style properties\n     * @param {Object} [options] - Style application options\n     */\n  applyStyleToAll(style, options = {}) {\n    this.getAllFeatures().forEach(feature => {\n      feature.setStyle(style, options);\n    });\n  }\n    \n  /**\n     * Find features at a coordinate\n     * @param {Coordinate} coordinate - The coordinate to search at\n     * @param {Object} [options] - Search options\n     * @param {number} [options.tolerance=0] - Distance tolerance in meters\n     * @returns {Array<FeatureBase>} - Features at the coordinate\n     */\n  findFeaturesAt(coordinate, options = {}) {\n    return this.getAllFeatures().filter(feature => \n      feature.visible && feature.contains(coordinate, options),\n    );\n  }\n    \n  /**\n     * Get features at a position, considering screen coordinates if needed\n     * @param {Coordinate} coordinate - The coordinate to search at\n     * @param {Object} [options] - Search options\n     * @param {number} [options.tolerance=10] - Pixel tolerance for selection\n     * @param {Array<number>} [options.screenPosition] - Screen position [x,y] if available\n     * @param {Object} [options.mapInterface] - Map interface for coordinate conversion if needed\n     * @returns {Array<FeatureBase>} - Features at the position\n     */\n  getFeaturesAtPosition(coordinate, options = {}) {\n    const tolerance = options.tolerance || 10; // Default to 10px tolerance\n    const screenPosition = options.screenPosition;\n    const mapInterface = options.mapInterface;\n        \n    // If we have screen coordinates and a map interface, use that for more precise selection\n    if (screenPosition && mapInterface) {\n      return this.getAllFeatures().filter(feature => {\n        // Skip hidden features\n        if (!feature.visible) return false;\n                \n        // For points, check distance in screen coordinates\n        if (feature.type === 'point') {\n          const featureCoord = feature.getCoordinate();\n          if (!featureCoord) return false;\n                    \n          try {\n            const featureScreenPos = mapInterface.coordinateToPixel(featureCoord);\n            if (!featureScreenPos) return false;\n                        \n            const distance = Math.sqrt(\n              Math.pow(featureScreenPos[0] - screenPosition[0], 2) +\n                            Math.pow(featureScreenPos[1] - screenPosition[1], 2),\n            );\n                        \n            return distance <= tolerance;\n          } catch (e) {\n            console.warn('Error calculating screen distance:', e);\n            return false;\n          }\n        }\n                \n        // For lines and polygons, check if coordinate is contained with tolerance\n        return feature.contains(coordinate, { tolerance });\n      });\n    }\n        \n    // Fall back to regular coordinate-based selection\n    return this.findFeaturesAt(coordinate, { tolerance });\n  }\n    \n  /**\n     * Find the nearest feature to a coordinate\n     * @param {Coordinate} coordinate - The reference coordinate\n     * @param {Object} [options] - Search options\n     * @param {number} [options.maxDistance] - Maximum distance to consider\n     * @param {string} [options.featureType] - Filter by feature type\n     * @returns {Object|null} - Object with feature and distance, or null if none found\n     */\n  findNearestFeature(coordinate, options = {}) {\n    let features = this.getAllFeatures().filter(feature => feature.visible);\n        \n    if (options.featureType) {\n      features = features.filter(feature => feature.type === options.featureType);\n    }\n        \n    if (features.length === 0) {\n      return null;\n    }\n        \n    let nearestFeature = null;\n    let minDistance = Infinity;\n        \n    features.forEach(feature => {\n      const nearest = feature.nearest(coordinate);\n            \n      if (nearest && nearest.distance < minDistance) {\n        if (!options.maxDistance || nearest.distance <= options.maxDistance) {\n          nearestFeature = feature;\n          minDistance = nearest.distance;\n        }\n      }\n    });\n        \n    if (nearestFeature) {\n      return {\n        feature: nearestFeature,\n        distance: minDistance,\n      };\n    }\n        \n    return null;\n  }\n    \n  /**\n     * Update an existing feature in the collection\n     * @param {FeatureBase} feature - The feature to update\n     * @returns {boolean} - Success status\n     */\n  updateFeature(feature) {\n    if (!(feature instanceof FeatureBase)) {\n      throw new Error('Feature must be an instance of FeatureBase');\n    }\n        \n    // Make sure the feature exists in the collection\n    if (!this.features.has(feature.id)) {\n      return false;\n    }\n        \n    // Update the feature reference\n    this.features.set(feature.id, feature);\n        \n    // Emit update event\n    this.emit('feature-updated', { feature, collection: this });\n        \n    return true;\n  }\n}","/**\n * ToolBase.js\n * Base class for all survey tools\n * Part of the RTK Surveyor 3D-first implementation\n */\n\nimport { EventEmitter } from '../core/event-emitter.js';\n\n/**\n * @typedef {Object} ToolBaseOptions\n * @property {Object} manager - The survey manager instance\n * @property {Object} mapInterface - The map interface instance\n */\n\n/**\n * Base class for all survey tools\n * Defines common functionality and interface requirements\n */\nexport class ToolBase extends EventEmitter {\n  /**\n   * Create a new tool instance\n   * @param {ToolBaseOptions} options - Tool configuration options\n   */\n  constructor(options = {}) {\n    super();\n    \n    if (!options.manager) {\n      throw new Error('Manager instance is required for tool initialization');\n    }\n    \n    if (!options.mapInterface) {\n      throw new Error('Map interface is required for tool initialization');\n    }\n    \n    // Store references\n    this.manager = options.manager;\n    this.mapInterface = options.mapInterface;\n    this.geometryEngine = options.geometryEngine || this.manager.geometryEngine;\n    \n    // Initialize state variables\n    this.isActive = false;\n    this.options = options;\n    this.workingData = {};\n    \n    // Setup event listeners\n    this._setupEventListeners();\n  }\n  \n  /**\n   * Set up tool-specific event listeners\n   * Override in derived classes\n   * @protected\n   */\n  _setupEventListeners() {\n    // Base implementation does nothing\n    // Override in specific tool implementations\n  }\n  \n  /**\n   * Activate the tool\n   * @param {Object} [options] - Tool-specific activation options\n   */\n  activate(options = {}) {\n    if (this.isActive) {\n      return; // Already active\n    }\n    \n    // Store activation options\n    this.activationOptions = Object.assign({}, options);\n    \n    // CRITICAL FIX: Update this.options with the new values\n    // This ensures derived tools use the updated options in their _activate method\n    this.options = Object.assign({}, this.options, options);\n    \n    console.log('ToolBase.activate: Updating options', options);\n    console.log('ToolBase.activate: Combined options are now', this.options);\n    \n    // Mark as active\n    this.isActive = true;\n    \n    // Tool-specific activation logic\n    this._activate();\n    \n    // Emit activation event\n    this.emit('activated', this.activationOptions);\n  }\n  \n  /**\n   * Tool-specific activation logic\n   * Override in derived classes\n   * @protected\n   */\n  _activate() {\n    throw new Error('_activate() must be implemented by derived classes');\n  }\n  \n  /**\n   * Deactivate the tool\n   */\n  deactivate() {\n    if (!this.isActive) {\n      return; // Already inactive\n    }\n    \n    // Mark as inactive\n    this.isActive = false;\n    \n    // Tool-specific deactivation logic\n    this._deactivate();\n    \n    // We don't completely reset working data here anymore\n    // as it can cause issues with derived classes that rely on its structure\n    // Instead, derived classes should handle clearing their state in _deactivate()\n    \n    // Emit deactivation event\n    this.emit('deactivated');\n  }\n  \n  /**\n   * Tool-specific deactivation logic\n   * Override in derived classes\n   * @protected\n   */\n  _deactivate() {\n    throw new Error('_deactivate() must be implemented by derived classes');\n  }\n  \n  /**\n   * Handle tool reset\n   * Clears current operation but keeps the tool active\n   */\n  reset() {\n    // Tool-specific reset logic\n    this._reset();\n    \n    // We don't completely reset working data here anymore\n    // as it can cause issues with derived classes that rely on its structure\n    // Instead, derived classes should handle clearing their state in _reset()\n    \n    // Emit reset event\n    this.emit('reset');\n  }\n  \n  /**\n   * Tool-specific reset logic\n   * Override in derived classes\n   * @protected\n   */\n  _reset() {\n    // Base implementation does nothing\n    // Override in specific tool implementations\n  }\n  \n  /**\n   * Update tool options\n   * @param {Object} options - The new options to apply\n   */\n  updateOptions(options = {}) {\n    this.options = Object.assign(this.options, options);\n    \n    // Tool-specific option update handling\n    this._optionsUpdated();\n    \n    // Emit options updated event\n    this.emit('optionsUpdated', this.options);\n  }\n  \n  /**\n   * Tool-specific options update handling\n   * Override in derived classes if needed\n   * @protected\n   */\n  _optionsUpdated() {\n    // Base implementation does nothing\n    // Override in specific tool implementations\n  }\n  \n  /**\n   * Clean up resources used by the tool\n   */\n  destroy() {\n    // Deactivate first if needed\n    if (this.isActive) {\n      this.deactivate();\n    }\n    \n    // Tool-specific destroy logic\n    this._destroy();\n    \n    // Remove all event listeners\n    this.removeAllListeners();\n    \n    // Clear references\n    this.manager = null;\n    this.mapInterface = null;\n    this.geometryEngine = null;\n  }\n  \n  /**\n   * Tool-specific destroy logic\n   * Override in derived classes if needed\n   * @protected\n   */\n  _destroy() {\n    // Base implementation does nothing\n    // Override in specific tool implementations\n  }\n}","/**\n * MeasurementTool.js\n * Tool for measuring distances, areas, and volumes\n * Part of the RTK Surveyor 3D-first implementation\n */\n\nimport { ToolBase } from './ToolBase.js';\nimport { LineFeature } from '../features/LineFeature.js';\nimport { PolygonFeature } from '../features/PolygonFeature.js';\nimport { PointFeature } from '../features/PointFeature.js';\nimport { GeometryEngine } from '../core/GeometryEngine.js';\n\n/**\n * @typedef {Object} MeasurementToolOptions\n * @property {string} [mode='distance'] - Measurement mode (distance, area, or volume)\n * @property {string} [units='meters'] - Units for distance (meters, feet, kilometers, miles)\n * @property {string} [areaUnits='square-meters'] - Units for area (square-meters, square-feet, hectares, acres)\n * @property {string} [volumeUnits='cubic-meters'] - Units for volume (cubic-meters, cubic-feet)\n * @property {boolean} [enable3D=true] - Whether to use 3D measurements\n * @property {boolean} [continuousMeasure=false] - Whether to continuously measure while moving\n * @property {boolean} [showSegmentLengths=true] - Whether to show individual segment lengths\n * @property {boolean} [showTotalLength=true] - Whether to show accumulated total length\n * @property {Object} [lineSymbol] - Symbol for measurement lines\n * @property {Object} [pointSymbol] - Symbol for measurement points\n * @property {Object} [labelStyle] - Style for measurement labels\n */\n\n/**\n * Tool for distance, area, and volume measurements\n * Supports both 2D and 3D measurements with multiple unit options\n */\nexport class MeasurementTool extends ToolBase {\n  /**\n   * Create a new MeasurementTool instance\n   * @param {Object} options - Tool configuration options\n   */\n  constructor(options = {}) {\n    super(options);\n    \n    // Initialize tool-specific options with defaults\n    this.options = Object.assign({\n      mode: 'distance',\n      units: 'meters',\n      areaUnits: 'square-meters',\n      volumeUnits: 'cubic-meters',\n      enable3D: true,\n      continuousMeasure: false,\n      showSegmentLengths: true,\n      showTotalLength: true,\n      lineSymbol: this.manager.settings.defaultLineSymbol,\n      pointSymbol: this.manager.settings.defaultPointSymbol,\n      labelStyle: {\n        font: '12px Arial',\n        fillColor: 'black',\n        strokeColor: 'white',\n        strokeWidth: 3,\n      },\n    }, options);\n    \n    // Initialize internal state\n    this.workingData = {\n      activeMeasurement: null,\n      measurements: [],\n      points: [],\n      mousePosition: null,\n      hoverCoordinate: null,\n      measurementLabels: [],\n      segmentLabels: [],\n    };\n    \n    // Use direct imported GeometryEngine instead of relying on manager\n    // This ensures we always have the required methods available\n    this.geometryEngine = GeometryEngine;\n    \n    // Bind event handlers to maintain 'this' context\n    this._handleMapClick = this._handleMapClick.bind(this);\n    this._handleMapMouseMove = this._handleMapMouseMove.bind(this);\n    this._handleMapDoubleClick = this._handleMapDoubleClick.bind(this);\n    this._handleMapRightClick = this._handleMapRightClick.bind(this);\n    this._handleKeyDown = this._handleKeyDown.bind(this);\n  }\n  \n  /**\n   * Set up tool-specific event listeners\n   * @protected\n   * @override\n   */\n  _setupEventListeners() {\n    // Implement specific event listeners if needed\n  }\n  \n  /**\n   * Tool-specific activation logic\n   * @protected\n   * @override\n   */\n  _activate() {\n    // Activate the appropriate measurement mode\n    this._activateMeasurementMode(this.options.mode);\n    \n    // Add map event listeners\n    this.mapInterface.addEventListener('click', this._handleMapClick);\n    this.mapInterface.addEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.addEventListener('dblclick', this._handleMapDoubleClick);\n    this.mapInterface.addEventListener('contextmenu', this._handleMapRightClick);\n    \n    // Add keyboard event listeners\n    document.addEventListener('keydown', this._handleKeyDown);\n    \n    // Create a new working feature based on mode\n    this._createNewMeasurement();\n  }\n  \n  /**\n   * Tool-specific deactivation logic\n   * @protected\n   * @override\n   */\n  _deactivate() {\n    // Remove map event listeners\n    this.mapInterface.removeEventListener('click', this._handleMapClick);\n    this.mapInterface.removeEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.removeEventListener('dblclick', this._handleMapDoubleClick);\n    this.mapInterface.removeEventListener('contextmenu', this._handleMapRightClick);\n    \n    // Remove keyboard event listeners\n    document.removeEventListener('keydown', this._handleKeyDown);\n    \n    // Clear any temporary features\n    this._clearTemporaryMeasurements();\n  }\n  \n  /**\n   * Tool-specific reset logic\n   * @protected\n   * @override\n   */\n  _reset() {\n    // Clear any active measurement\n    this._clearActiveMeasurement();\n    \n    // Create a new measurement\n    this._createNewMeasurement();\n  }\n  \n  /**\n   * Activate a specific measurement mode\n   * @param {string} mode - The measurement mode (distance, area, volume)\n   * @private\n   */\n  _activateMeasurementMode(mode) {\n    // Validate the mode\n    if (!['distance', 'area', 'volume'].includes(mode)) {\n      console.error(`Invalid measurement mode: ${mode}`);\n      mode = 'distance';\n    }\n    \n    // Update the current mode\n    this.options.mode = mode;\n    \n    // If already active, reset the measurement for the new mode\n    if (this.isActive) {\n      this._reset();\n    }\n    \n    // Emit mode change event\n    this.emit('mode-changed', { mode });\n  }\n  \n  /**\n   * Create a new measurement feature based on current mode\n   * @private\n   */\n  _createNewMeasurement() {\n    // Clear any existing active measurement\n    this._clearActiveMeasurement();\n    \n    // Create appropriate feature type based on mode\n    switch (this.options.mode) {\n    case 'distance':\n      this.workingData.activeMeasurement = new LineFeature([], {\n        id: `measurement-${Date.now()}`,\n        properties: {\n          type: 'measurement',\n          measurementType: 'distance',\n          temporary: true,\n        },\n        style: this.options.lineSymbol,\n      });\n      break;\n        \n    case 'area':\n    case 'volume':\n      // Create a polygon with empty rings\n      this.workingData.activeMeasurement = new PolygonFeature([[]], {\n        id: `measurement-${Date.now()}`,\n        properties: {\n          type: 'measurement',\n          measurementType: this.options.mode,\n          temporary: true,\n        },\n        style: Object.assign({}, this.manager.settings.defaultPolygonSymbol, {\n          outlineColor: this.options.lineSymbol.color,\n          outlineWidth: this.options.lineSymbol.width,\n        }),\n      });\n      break;\n    }\n    \n    // Add the feature to the manager's working features\n    this.manager.workingFeatures.addFeature(this.workingData.activeMeasurement);\n    \n    // Reset points array\n    this.workingData.points = [];\n    this.workingData.measurementLabels = [];\n    this.workingData.segmentLabels = [];\n  }\n  \n  /**\n   * Clear the active measurement\n   * @private\n   */\n  _clearActiveMeasurement() {\n    if (this.workingData.activeMeasurement) {\n      // Remove from manager's working features\n      this.manager.workingFeatures.removeFeature(this.workingData.activeMeasurement);\n      this.workingData.activeMeasurement = null;\n    }\n    \n    // Clear points and labels\n    this.workingData.points.forEach(point => {\n      this.manager.workingFeatures.removeFeature(point);\n    });\n    \n    this.workingData.points = [];\n    \n    // Clear labels\n    this._clearMeasurementLabels();\n  }\n  \n  /**\n   * Clear all temporary measurements\n   * @private\n   */\n  _clearTemporaryMeasurements() {\n    // Clear active measurement\n    this._clearActiveMeasurement();\n    \n    // Clear saved measurements from working features\n    this.workingData.measurements.forEach(measurement => {\n      this.manager.workingFeatures.removeFeature(measurement);\n    });\n    \n    this.workingData.measurements = [];\n  }\n  \n  /**\n   * Clear measurement labels\n   * @private\n   */\n  _clearMeasurementLabels() {\n    // Remove labels from map\n    this.workingData.measurementLabels.forEach(label => {\n      this.mapInterface.removeLabel(label);\n    });\n    \n    this.workingData.segmentLabels.forEach(label => {\n      this.mapInterface.removeLabel(label);\n    });\n    \n    this.workingData.measurementLabels = [];\n    this.workingData.segmentLabels = [];\n  }\n  \n  /**\n   * Handle map click events\n   * @param {Object} event - The map click event\n   * @private\n   */\n  _handleMapClick(event) {\n    // Get clicked coordinate\n    const coordinate = event.coordinate;\n    \n    // Skip if no coordinate or no active measurement\n    if (!coordinate || !this.workingData.activeMeasurement) {\n      return;\n    }\n    \n    // Add point to the measurement\n    this._addPointToMeasurement(coordinate);\n    \n    // Update the measurement display\n    this._updateMeasurementDisplay();\n  }\n  \n  /**\n   * Handle map mouse move events\n   * @param {Object} event - The map mousemove event\n   * @private\n   */\n  _handleMapMouseMove(event) {\n    // Store current mouse position\n    this.workingData.mousePosition = event.coordinate;\n    this.workingData.hoverCoordinate = event.coordinate;\n    \n    // Update the measurement preview if we have at least one point\n    if (this.workingData.activeMeasurement && this.workingData.points.length > 0) {\n      this._updateMeasurementPreview();\n    }\n    \n    // Handle continuous measurement mode\n    if (this.options.continuousMeasure && \n        this.workingData.activeMeasurement && \n        this.workingData.points.length > 0) {\n      // Only add points that are a certain distance apart\n      const lastPoint = this.workingData.points[this.workingData.points.length - 1];\n      const lastCoord = lastPoint.getCoordinate();\n      const distance = this.geometryEngine.calculateDistance(lastCoord, event.coordinate, \n        { includeElevation: this.options.enable3D },\n      );\n      \n      // Add point if it's more than 5 meters away from the last point\n      if (distance > 5) {\n        this._addPointToMeasurement(event.coordinate);\n        this._updateMeasurementDisplay();\n      }\n    }\n  }\n  \n  /**\n   * Handle map double click events\n   * @param {Object} event - The map double click event\n   * @private\n   */\n  _handleMapDoubleClick(event) {\n    // Prevent default browser behavior\n    if (event.originalEvent) {\n      event.originalEvent.preventDefault();\n    }\n    \n    // Complete the current measurement\n    this._completeMeasurement();\n  }\n  \n  /**\n   * Handle map right click events\n   * @param {Object} event - The map right click event\n   * @private\n   */\n  _handleMapRightClick(event) {\n    // Prevent default context menu\n    if (event.originalEvent) {\n      event.originalEvent.preventDefault();\n    }\n    \n    // If we have points, complete the measurement\n    if (this.workingData.points.length > 0) {\n      this._completeMeasurement();\n    } else {\n      // Otherwise, cancel the measurement\n      this._reset();\n    }\n  }\n  \n  /**\n   * Handle keyboard events\n   * @param {KeyboardEvent} event - The keyboard event\n   * @private\n   */\n  _handleKeyDown(event) {\n    // Handle Escape key\n    if (event.key === 'Escape') {\n      if (this.workingData.points.length > 0) {\n        // Remove the last point\n        this._removeLastPoint();\n      } else {\n        // No points, reset the measurement\n        this._reset();\n      }\n    }\n    \n    // Handle Enter key\n    if (event.key === 'Enter') {\n      // Complete the measurement\n      this._completeMeasurement();\n    }\n  }\n  \n  /**\n   * Add a point to the current measurement\n   * @param {Object} coordinate - The coordinate to add\n   * @private\n   */\n  _addPointToMeasurement(coordinate) {\n    // Create a point feature for the vertex\n    const pointFeature = new PointFeature(coordinate, {\n      id: `measurement-point-${Date.now()}-${this.workingData.points.length}`,\n      properties: {\n        type: 'measurement-point',\n        measurementId: this.workingData.activeMeasurement.id,\n        index: this.workingData.points.length,\n        temporary: true,\n      },\n      style: this.options.pointSymbol,\n    });\n    \n    // Apply 3D elevation if enabled\n    if (this.options.enable3D) {\n      this.manager.applyElevationData(pointFeature);\n    }\n    \n    // Add to working features and points array\n    this.manager.workingFeatures.addFeature(pointFeature);\n    this.workingData.points.push(pointFeature);\n    \n    // Update the measurement feature geometry\n    this._updateMeasurementGeometry();\n  }\n  \n  /**\n   * Remove the last point from the measurement\n   * @private\n   */\n  _removeLastPoint() {\n    if (this.workingData.points.length === 0) {\n      return;\n    }\n    \n    // Remove the last point\n    const lastPoint = this.workingData.points.pop();\n    this.manager.workingFeatures.removeFeature(lastPoint);\n    \n    // Update the measurement feature geometry\n    this._updateMeasurementGeometry();\n    \n    // Update the display\n    this._updateMeasurementDisplay();\n  }\n  \n  /**\n   * Update the measurement feature geometry based on collected points\n   * @private\n   */\n  _updateMeasurementGeometry() {\n    if (!this.workingData.activeMeasurement) {\n      return;\n    }\n    \n    // Extract coordinates from point features\n    const coordinates = this.workingData.points.map(point => point.getCoordinate());\n    \n    // Update the geometry based on measurement type\n    switch (this.options.mode) {\n    case 'distance':\n      this.workingData.activeMeasurement.setCoordinates(coordinates);\n      break;\n        \n    case 'area':\n    case 'volume':\n      // For area and volume, we need a polygon\n      if (coordinates.length >= 3) {\n        // Close the polygon if needed\n        const polygonCoordinates = [...coordinates];\n          \n        // Don't explicitly close it - the polygon feature will handle this\n        this.workingData.activeMeasurement.setRings([polygonCoordinates]);\n      } else {\n        // Not enough points for a polygon yet, use empty geometry\n        this.workingData.activeMeasurement.setRings([coordinates]);\n      }\n      break;\n    }\n  }\n  \n  /**\n   * Update the measurement preview with the current mouse position\n   * @private\n   */\n  _updateMeasurementPreview() {\n    if (!this.workingData.activeMeasurement || !this.workingData.mousePosition) {\n      return;\n    }\n    \n    // Create a preview with existing points plus mouse position\n    const coordinates = this.workingData.points.map(point => point.getCoordinate());\n    const previewCoordinates = [...coordinates, this.workingData.mousePosition];\n    \n    // Update preview based on measurement type\n    switch (this.options.mode) {\n    case 'distance':\n      this.workingData.activeMeasurement.setCoordinates(previewCoordinates);\n      break;\n        \n    case 'area':\n    case 'volume':\n      if (previewCoordinates.length >= 3) {\n        this.workingData.activeMeasurement.setRings([previewCoordinates]);\n      } else {\n        this.workingData.activeMeasurement.setRings([previewCoordinates]);\n      }\n      break;\n    }\n    \n    // Update display including preview\n    this._updateMeasurementDisplay(true);\n  }\n  \n  /**\n   * Update measurement display with labels and values\n   * @param {boolean} [preview=false] - Whether this is a preview update\n   * @private\n   */\n  _updateMeasurementDisplay(preview = false) {\n    // Clear existing labels\n    this._clearMeasurementLabels();\n    \n    if (!this.workingData.activeMeasurement) {\n      return;\n    }\n    \n    // Calculate measurement values based on mode\n    let measurementValue = 0;\n    let measurementUnit = '';\n    let segmentValues = [];\n    \n    switch (this.options.mode) {\n    case 'distance':\n      // Get coordinates including potential preview point\n      const lineCoordinates = this.workingData.points.map(point => point.getCoordinate());\n      if (preview && this.workingData.mousePosition) {\n        lineCoordinates.push(this.workingData.mousePosition);\n      }\n        \n      // Calculate total distance\n      if (lineCoordinates.length >= 2) {\n        measurementValue = this._calculateDistance(lineCoordinates);\n        measurementUnit = this.options.units;\n          \n        // Calculate individual segment distances\n        if (this.options.showSegmentLengths) {\n          segmentValues = this._calculateSegmentDistances(lineCoordinates);\n        }\n      }\n      break;\n        \n    case 'area':\n      // Get coordinates including potential preview point\n      const areaCoordinates = this.workingData.points.map(point => point.getCoordinate());\n      if (preview && this.workingData.mousePosition) {\n        areaCoordinates.push(this.workingData.mousePosition);\n      }\n        \n      // Calculate area\n      if (areaCoordinates.length >= 3) {\n        measurementValue = this._calculateArea(areaCoordinates);\n        measurementUnit = this.options.areaUnits;\n          \n        // Also calculate perimeter if showing segment lengths\n        if (this.options.showSegmentLengths) {\n          // Add a copy of the first point to close the polygon\n          const perimeterCoords = [...areaCoordinates, areaCoordinates[0]];\n          segmentValues = this._calculateSegmentDistances(perimeterCoords);\n        }\n      }\n      break;\n        \n    case 'volume':\n      // Get coordinates including potential preview point\n      const volumeCoordinates = this.workingData.points.map(point => point.getCoordinate());\n      if (preview && this.workingData.mousePosition) {\n        volumeCoordinates.push(this.workingData.mousePosition);\n      }\n        \n      // Calculate volume (requires at least 3 points and 3D data)\n      if (volumeCoordinates.length >= 3 && this.options.enable3D) {\n        measurementValue = this._calculateVolume(volumeCoordinates);\n        measurementUnit = this.options.volumeUnits;\n          \n        // Also calculate perimeter if showing segment lengths\n        if (this.options.showSegmentLengths) {\n          // Add a copy of the first point to close the polygon\n          const perimeterCoords = [...volumeCoordinates, volumeCoordinates[0]];\n          segmentValues = this._calculateSegmentDistances(perimeterCoords);\n        }\n      }\n      break;\n    }\n    \n    // Create and display measurement labels\n    if (measurementValue > 0) {\n      // Format the value\n      const formattedValue = this._formatMeasurementValue(measurementValue, measurementUnit);\n      \n      // Emit measurement updated event to notify components\n      this.emit('measurement-updated', {\n        type: this.options.mode,\n        value: measurementValue,\n        unit: measurementUnit,\n        formattedValue: formattedValue,\n        segments: segmentValues.length,\n        vertices: this.workingData.points.length,\n        preview: preview,\n      });\n      \n      // Create overall measurement label\n      if (this.options.showTotalLength) {\n        const labelPosition = this._calculateLabelPosition();\n        \n        const measurementLabel = this.mapInterface.createLabel({\n          position: labelPosition,\n          text: formattedValue,\n          style: this.options.labelStyle,\n        });\n        \n        this.workingData.measurementLabels.push(measurementLabel);\n      }\n      \n      // Create segment labels if enabled\n      if (this.options.showSegmentLengths && segmentValues.length > 0) {\n        segmentValues.forEach((segment, _index) => {\n          // Skip if segment value is 0\n          if (segment.value <= 0) {\n            return;\n          }\n          \n          // Format the segment value\n          const formattedSegment = this._formatMeasurementValue(segment.value, measurementUnit);\n          \n          // Create segment label\n          const segmentLabel = this.mapInterface.createLabel({\n            position: segment.midpoint,\n            text: formattedSegment,\n            style: Object.assign({}, this.options.labelStyle, {\n              font: '10px Arial',\n            }),\n          });\n          \n          this.workingData.segmentLabels.push(segmentLabel);\n        });\n      }\n    }\n  }\n  \n  /**\n   * Calculate label position for the measurement\n   * @returns {Object} The position for the label\n   * @private\n   */\n  _calculateLabelPosition() {\n    switch (this.options.mode) {\n    case 'distance':\n      // For distance, place label near the last point\n      if (this.workingData.points.length > 0) {\n        const lastPoint = this.workingData.points[this.workingData.points.length - 1];\n        return lastPoint.getCoordinate();\n      }\n      break;\n        \n    case 'area':\n    case 'volume':\n      // For area/volume, place label at centroid\n      if (this.workingData.activeMeasurement) {\n        return this.workingData.activeMeasurement.getCentroid();\n      }\n      break;\n    }\n    \n    // Fallback to first point if available\n    if (this.workingData.points.length > 0) {\n      return this.workingData.points[0].getCoordinate();\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Complete the current measurement\n   * @private\n   */\n  _completeMeasurement() {\n    // Require at least 2 points for distance, 3 for area/volume\n    const minPoints = this.options.mode === 'distance' ? 2 : 3;\n    \n    if (!this.workingData.activeMeasurement || this.workingData.points.length < minPoints) {\n      // Not enough points, just reset\n      this._reset();\n      return;\n    }\n    \n    // Finalize the measurement\n    const finalMeasurement = this.workingData.activeMeasurement;\n    \n    // Complete the geometry (no preview point)\n    this._updateMeasurementGeometry();\n    \n    // Calculate the final measurement value\n    let measurementValue = 0;\n    let measurementUnit = '';\n    \n    switch (this.options.mode) {\n    case 'distance':\n      const coordinates = finalMeasurement.getCoordinates();\n      measurementValue = this._calculateDistance(coordinates);\n      measurementUnit = this.options.units;\n      break;\n        \n    case 'area':\n      const areaRings = finalMeasurement.getRings();\n      if (areaRings.length > 0) {\n        measurementValue = this._calculateArea(areaRings[0]);\n        measurementUnit = this.options.areaUnits;\n      }\n      break;\n        \n    case 'volume':\n      const volumeRings = finalMeasurement.getRings();\n      if (volumeRings.length > 0) {\n        measurementValue = this._calculateVolume(volumeRings[0]);\n        measurementUnit = this.options.volumeUnits;\n      }\n      break;\n    }\n    \n    // Format and store the measurement value\n    const formattedValue = this._formatMeasurementValue(measurementValue, measurementUnit);\n    \n    // Update feature properties with measurement info\n    finalMeasurement.setProperty('measurementValue', measurementValue);\n    finalMeasurement.setProperty('measurementUnit', measurementUnit);\n    finalMeasurement.setProperty('measurementFormatted', formattedValue);\n    finalMeasurement.setProperty('temporary', false);\n    \n    // Update point features to be non-temporary\n    this.workingData.points.forEach(point => {\n      point.setProperty('temporary', false);\n    });\n    \n    // Move to completed measurements collection\n    this.workingData.measurements.push(finalMeasurement);\n    \n    // Create a new measurement\n    this._createNewMeasurement();\n    \n    // Emit measurement completed event\n    this.emit('measurement-completed', {\n      feature: finalMeasurement,\n      value: measurementValue,\n      unit: measurementUnit,\n      formattedValue: formattedValue,\n      mode: this.options.mode,\n    });\n  }\n  \n  /**\n   * Calculate total distance of a line\n   * @param {Array} coordinates - Array of coordinates\n   * @returns {number} The distance in meters\n   * @private\n   */\n  _calculateDistance(coordinates) {\n    if (coordinates.length < 2) {\n      return 0;\n    }\n    \n    let totalDistance = 0;\n    \n    for (let i = 0; i < coordinates.length - 1; i++) {\n      const segmentDistance = this.geometryEngine.calculateDistance(\n        coordinates[i],\n        coordinates[i + 1],\n        { includeElevation: this.options.enable3D },\n      );\n      \n      totalDistance += segmentDistance;\n    }\n    \n    // Convert to requested units\n    return this._convertDistance(totalDistance, 'meters', this.options.units);\n  }\n  \n  /**\n   * Calculate distances for each segment\n   * @param {Array} coordinates - Array of coordinates\n   * @returns {Array} Array of segment distances with midpoints\n   * @private\n   */\n  _calculateSegmentDistances(coordinates) {\n    if (coordinates.length < 2) {\n      return [];\n    }\n    \n    const segments = [];\n    \n    for (let i = 0; i < coordinates.length - 1; i++) {\n      const start = coordinates[i];\n      const end = coordinates[i + 1];\n      \n      const segmentDistance = this.geometryEngine.calculateDistance(\n        start,\n        end,\n        { includeElevation: this.options.enable3D },\n      );\n      \n      // Calculate midpoint for label placement\n      // Create a simple midpoint calculation since GeometryEngine doesn't have interpolate\n      const midpoint = {\n        lat: (start.lat + end.lat) / 2,\n        lng: (start.lng + end.lng) / 2,\n        elevation: (start.elevation !== undefined && end.elevation !== undefined) ? \n          (start.elevation + end.elevation) / 2 : 0,\n      };\n      \n      // Convert to requested units\n      const convertedDistance = this._convertDistance(segmentDistance, 'meters', this.options.units);\n      \n      segments.push({\n        value: convertedDistance,\n        midpoint: midpoint,\n      });\n    }\n    \n    return segments;\n  }\n  \n  /**\n   * Calculate area of a polygon\n   * @param {Array} coordinates - Array of coordinates forming a polygon ring\n   * @returns {number} The area in square meters\n   * @private\n   */\n  _calculateArea(coordinates) {\n    if (coordinates.length < 3) {\n      return 0;\n    }\n    \n    // Ensure polygon is properly closed\n    const closedCoordinates = [...coordinates];\n    \n    // Simple check to see if first and last points are equal\n    const first = closedCoordinates[0];\n    const last = closedCoordinates[closedCoordinates.length - 1];\n    const areEqual = first.lat === last.lat && first.lng === last.lng;\n    \n    if (!areEqual) {\n      closedCoordinates.push(closedCoordinates[0]);\n    }\n    \n    // Calculate area using GeometryEngine static method\n    const area = this.geometryEngine.calculateArea(closedCoordinates, {\n      includeElevation: this.options.enable3D,\n    });\n    \n    // Convert to requested units\n    return this._convertArea(area, 'square-meters', this.options.areaUnits);\n  }\n  \n  /**\n   * Calculate volume enclosed by a polygon base and elevation\n   * @param {Array} coordinates - Array of coordinates forming a polygon ring\n   * @returns {number} The volume in cubic meters\n   * @private\n   */\n  _calculateVolume(coordinates) {\n    if (coordinates.length < 3 || !this.options.enable3D) {\n      return 0;\n    }\n    \n    // Ensure polygon is properly closed\n    const closedCoordinates = [...coordinates];\n    \n    // Simple check to see if first and last points are equal\n    const first = closedCoordinates[0];\n    const last = closedCoordinates[closedCoordinates.length - 1];\n    const areEqual = first.lat === last.lat && first.lng === last.lng;\n    \n    if (!areEqual) {\n      closedCoordinates.push(closedCoordinates[0]);\n    }\n    \n    // Calculate volume using GeometryEngine\n    const volume = this.geometryEngine.calculateVolume ? \n      this.geometryEngine.calculateVolume(closedCoordinates) :\n      this._calculateVolumeDirectly(closedCoordinates);\n    \n    // Convert to requested units\n    return this._convertVolume(volume, 'cubic-meters', this.options.volumeUnits);\n  }\n  \n  /**\n   * Direct implementation of volume calculation if GeometryEngine.calculateVolume is not available\n   * @param {Array} coordinates - Array of coordinates forming a polygon ring\n   * @returns {number} The volume in cubic meters\n   * @private\n   */\n  _calculateVolumeDirectly(coordinates) {\n    // Calculate the base area using the _calculateArea method\n    const baseArea = this._calculateArea(coordinates);\n    \n    // Calculate average height (elevation) of the polygon vertices\n    let totalHeight = 0;\n    let validPoints = 0;\n    \n    for (const coord of coordinates) {\n      if (coord.elevation !== undefined && coord.elevation !== null) {\n        totalHeight += coord.elevation;\n        validPoints++;\n      }\n    }\n    \n    // If we have valid elevation data, calculate the volume\n    if (validPoints > 0) {\n      const avgHeight = totalHeight / validPoints;\n      return baseArea * avgHeight;\n    }\n    \n    return 0;\n  }\n  \n  /**\n   * Convert distance between different units\n   * @param {number} distance - The distance to convert\n   * @param {string} fromUnit - The source unit\n   * @param {string} toUnit - The target unit\n   * @returns {number} The converted distance\n   * @private\n   */\n  _convertDistance(distance, fromUnit, toUnit) {\n    if (fromUnit === toUnit) {\n      return distance;\n    }\n    \n    // Convert from source unit to meters\n    let meters = distance;\n    if (fromUnit !== 'meters') {\n      switch (fromUnit) {\n      case 'feet':\n        meters = distance * 0.3048;\n        break;\n      case 'kilometers':\n        meters = distance * 1000;\n        break;\n      case 'miles':\n        meters = distance * 1609.344;\n        break;\n      }\n    }\n    \n    // Convert from meters to target unit\n    switch (toUnit) {\n    case 'meters':\n      return meters;\n    case 'feet':\n      return meters / 0.3048;\n    case 'kilometers':\n      return meters / 1000;\n    case 'miles':\n      return meters / 1609.344;\n    default:\n      return meters;\n    }\n  }\n  \n  /**\n   * Convert area between different units\n   * @param {number} area - The area to convert\n   * @param {string} fromUnit - The source unit\n   * @param {string} toUnit - The target unit\n   * @returns {number} The converted area\n   * @private\n   */\n  _convertArea(area, fromUnit, toUnit) {\n    if (fromUnit === toUnit) {\n      return area;\n    }\n    \n    // Convert from source unit to square meters\n    let squareMeters = area;\n    if (fromUnit !== 'square-meters') {\n      switch (fromUnit) {\n      case 'square-feet':\n        squareMeters = area * 0.092903;\n        break;\n      case 'hectares':\n        squareMeters = area * 10000;\n        break;\n      case 'acres':\n        squareMeters = area * 4046.856;\n        break;\n      }\n    }\n    \n    // Convert from square meters to target unit\n    switch (toUnit) {\n    case 'square-meters':\n      return squareMeters;\n    case 'square-feet':\n      return squareMeters / 0.092903;\n    case 'hectares':\n      return squareMeters / 10000;\n    case 'acres':\n      return squareMeters / 4046.856;\n    default:\n      return squareMeters;\n    }\n  }\n  \n  /**\n   * Convert volume between different units\n   * @param {number} volume - The volume to convert\n   * @param {string} fromUnit - The source unit\n   * @param {string} toUnit - The target unit\n   * @returns {number} The converted volume\n   * @private\n   */\n  _convertVolume(volume, fromUnit, toUnit) {\n    if (fromUnit === toUnit) {\n      return volume;\n    }\n    \n    // Convert from source unit to cubic meters\n    let cubicMeters = volume;\n    if (fromUnit !== 'cubic-meters') {\n      switch (fromUnit) {\n      case 'cubic-feet':\n        cubicMeters = volume * 0.0283168;\n        break;\n      }\n    }\n    \n    // Convert from cubic meters to target unit\n    switch (toUnit) {\n    case 'cubic-meters':\n      return cubicMeters;\n    case 'cubic-feet':\n      return cubicMeters / 0.0283168;\n    default:\n      return cubicMeters;\n    }\n  }\n  \n  /**\n   * Format measurement value for display\n   * @param {number} value - The measurement value\n   * @param {string} unit - The measurement unit\n   * @returns {string} Formatted measurement string\n   * @private\n   */\n  _formatMeasurementValue(value, unit) {\n    // Handle different unit display formats\n    let formattedValue;\n    let unitDisplay;\n    \n    // Format to appropriate precision based on unit\n    switch (unit) {\n    case 'meters':\n      formattedValue = value < 10 ? value.toFixed(2) : Math.round(value).toString();\n      unitDisplay = 'm';\n      break;\n    case 'feet':\n      formattedValue = value < 10 ? value.toFixed(2) : Math.round(value).toString();\n      unitDisplay = 'ft';\n      break;\n    case 'kilometers':\n      formattedValue = value.toFixed(3);\n      unitDisplay = 'km';\n      break;\n    case 'miles':\n      formattedValue = value.toFixed(3);\n      unitDisplay = 'mi';\n      break;\n    case 'square-meters':\n      formattedValue = value < 10 ? value.toFixed(2) : Math.round(value).toString();\n      unitDisplay = 'm²';\n      break;\n    case 'square-feet':\n      formattedValue = value < 10 ? value.toFixed(2) : Math.round(value).toString();\n      unitDisplay = 'ft²';\n      break;\n    case 'hectares':\n      formattedValue = value.toFixed(4);\n      unitDisplay = 'ha';\n      break;\n    case 'acres':\n      formattedValue = value.toFixed(4);\n      unitDisplay = 'ac';\n      break;\n    case 'cubic-meters':\n      formattedValue = value < 10 ? value.toFixed(2) : Math.round(value).toString();\n      unitDisplay = 'm³';\n      break;\n    case 'cubic-feet':\n      formattedValue = value < 10 ? value.toFixed(2) : Math.round(value).toString();\n      unitDisplay = 'ft³';\n      break;\n    default:\n      formattedValue = value.toString();\n      unitDisplay = unit;\n    }\n    \n    return `${formattedValue} ${unitDisplay}`;\n  }\n  \n  /**\n   * Set the measurement mode\n   * @param {string} mode - The measurement mode (distance, area, volume)\n   * @returns {boolean} Success of mode change\n   */\n  setMode(mode) {\n    if (!['distance', 'area', 'volume'].includes(mode)) {\n      console.error(`Invalid measurement mode: ${mode}`);\n      return false;\n    }\n    \n    // Update the mode\n    this.options.mode = mode;\n    \n    // If tool is active, reset it for the new mode\n    if (this.isActive) {\n      this._reset();\n    }\n    \n    // Emit mode change event\n    this.emit('mode-changed', { mode });\n    \n    return true;\n  }\n  \n  /**\n   * Set the measurement units\n   * @param {Object} units - The units to set\n   * @param {string} [units.distance] - Distance unit\n   * @param {string} [units.area] - Area unit\n   * @param {string} [units.volume] - Volume unit\n   * @returns {boolean} Success of units change\n   */\n  setUnits(units = {}) {\n    // Validate units\n    if (units.distance && !['meters', 'feet', 'kilometers', 'miles'].includes(units.distance)) {\n      console.error(`Invalid distance unit: ${units.distance}`);\n      return false;\n    }\n    \n    if (units.area && !['square-meters', 'square-feet', 'hectares', 'acres'].includes(units.area)) {\n      console.error(`Invalid area unit: ${units.area}`);\n      return false;\n    }\n    \n    if (units.volume && !['cubic-meters', 'cubic-feet'].includes(units.volume)) {\n      console.error(`Invalid volume unit: ${units.volume}`);\n      return false;\n    }\n    \n    // Update units\n    if (units.distance) this.options.units = units.distance;\n    if (units.area) this.options.areaUnits = units.area;\n    if (units.volume) this.options.volumeUnits = units.volume;\n    \n    // Update display if active\n    if (this.isActive && this.workingData.activeMeasurement) {\n      this._updateMeasurementDisplay();\n    }\n    \n    // Emit units changed event\n    this.emit('units-changed', {\n      distance: this.options.units,\n      area: this.options.areaUnits,\n      volume: this.options.volumeUnits,\n    });\n    \n    return true;\n  }\n  \n  /**\n   * Toggle 3D measurement mode\n   * @param {boolean} enable - Whether to enable 3D measurements\n   * @returns {boolean} New state of 3D mode\n   */\n  setEnable3D(enable) {\n    this.options.enable3D = !!enable;\n    \n    // Update display if active\n    if (this.isActive && this.workingData.activeMeasurement) {\n      this._updateMeasurementDisplay();\n    }\n    \n    // Emit 3D mode changed event\n    this.emit('enable-3d-changed', {\n      enable3D: this.options.enable3D,\n    });\n    \n    return this.options.enable3D;\n  }\n  \n  /**\n   * Complete the current measurement and return it\n   * @returns {Object} The completed measurement feature or null\n   */\n  completeMeasurement() {\n    this._completeMeasurement();\n    \n    // Return the most recently completed measurement\n    if (this.workingData.measurements.length > 0) {\n      return this.workingData.measurements[this.workingData.measurements.length - 1];\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Get all completed measurements\n   * @returns {Array} Array of completed measurement features\n   */\n  getMeasurements() {\n    return this.workingData.measurements;\n  }\n  \n  /**\n   * Clear all measurements\n   */\n  clearAllMeasurements() {\n    // Clear temporary and working measurements\n    this._clearTemporaryMeasurements();\n    \n    // Reset tool\n    this._reset();\n    \n    // Emit event\n    this.emit('measurements-cleared');\n  }\n}","/**\n * OffsetTool.js\n * Tool for creating offset points, lines and features\n * Part of the RTK Surveyor 3D-first implementation\n */\n\nimport { ToolBase } from './ToolBase.js';\nimport { PointFeature } from '../features/PointFeature.js';\nimport { LineFeature } from '../features/LineFeature.js';\nimport { Coordinate } from '../core/Coordinate.js';\nimport { GeometryEngine } from '../core/GeometryEngine.js';\n\n/**\n * @typedef {Object} OffsetToolOptions\n * @property {string} [mode='point'] - Offset mode (point, line, perpendicular)\n * @property {string} [units='meters'] - Distance units (meters, feet, etc.)\n * @property {boolean} [enable3D=true] - Whether to use 3D offsets\n * @property {number} [defaultDistance=5] - Default offset distance\n * @property {number} [defaultBearing=0] - Default offset bearing (degrees)\n * @property {Object} [sourceSymbol] - Symbol for source features\n * @property {Object} [targetSymbol] - Symbol for offset features\n * @property {Object} [previewSymbol] - Symbol for preview features\n */\n\n/**\n * Tool for creating offset features\n * Supports point-based, line-based, and perpendicular offsets\n */\nexport class OffsetTool extends ToolBase {\n  /**\n   * Create a new OffsetTool instance\n   * @param {Object} options - Tool configuration options\n   */\n  constructor(options = {}) {\n    super(options);\n    \n    // Initialize tool-specific options with defaults\n    this.options = Object.assign({\n      mode: 'point',\n      units: 'meters',\n      enable3D: true,\n      defaultDistance: 5,\n      defaultBearing: 0,\n      distanceSnap: 1,\n      bearingSnap: 5,\n      sourceSymbol: {\n        type: 'circle',\n        size: 8,\n        color: '#3388FF',\n      },\n      targetSymbol: {\n        type: 'circle',\n        size: 8,\n        color: '#FF5733',\n      },\n      lineSymbol: {\n        width: 2,\n        color: '#FF5733',\n        dashArray: '5,5',\n      },\n      previewSymbol: {\n        type: 'circle',\n        size: 8,\n        color: 'rgba(255, 87, 51, 0.5)',\n        outlineWidth: 1,\n        outlineColor: '#FF5733',\n      },\n    }, options);\n    \n    // Initialize internal state\n    this.workingData = {\n      sourceFeature: null,\n      targetFeature: null,\n      previewFeature: null,\n      offsetLine: null,\n      offsetDistance: this.options.defaultDistance,\n      offsetBearing: this.options.defaultBearing,\n      mousePosition: null,\n      selectedPoint: null,\n      snapEnabled: true,\n    };\n    \n    // Bind event handlers to maintain 'this' context\n    this._handleMapClick = this._handleMapClick.bind(this);\n    this._handleMapMouseMove = this._handleMapMouseMove.bind(this);\n    this._handleMapDoubleClick = this._handleMapDoubleClick.bind(this);\n    this._handleKeyDown = this._handleKeyDown.bind(this);\n    this._handleFeatureSelected = this._handleFeatureSelected.bind(this);\n  }\n  \n  /**\n   * Set up tool-specific event listeners\n   * @protected\n   * @override\n   */\n  _setupEventListeners() {\n    // Listen for feature selection from the manager\n    this.manager.on('featureSelected', this._handleFeatureSelected);\n  }\n  \n  /**\n   * Tool-specific activation logic\n   * @protected\n   * @override\n   */\n  _activate() {\n    // Add map event listeners\n    this.mapInterface.addEventListener('click', this._handleMapClick);\n    this.mapInterface.addEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.addEventListener('dblclick', this._handleMapDoubleClick);\n    \n    // Add keyboard event listeners\n    document.addEventListener('keydown', this._handleKeyDown);\n    \n    // Set the initial mode\n    this._setOffsetMode(this.options.mode);\n    \n    // Initialize offset values\n    this.workingData.offsetDistance = this.options.defaultDistance;\n    this.workingData.offsetBearing = this.options.defaultBearing;\n    \n    // Emit activation event with additional info\n    this.emit('activated', {\n      mode: this.options.mode,\n      offsetDistance: this.workingData.offsetDistance,\n      offsetBearing: this.workingData.offsetBearing,\n    });\n  }\n  \n  /**\n   * Tool-specific deactivation logic\n   * @protected\n   * @override\n   */\n  _deactivate() {\n    // Remove map event listeners\n    this.mapInterface.removeEventListener('click', this._handleMapClick);\n    this.mapInterface.removeEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.removeEventListener('dblclick', this._handleMapDoubleClick);\n    \n    // Remove keyboard event listeners\n    document.removeEventListener('keydown', this._handleKeyDown);\n    \n    // Clear any preview features\n    this._clearPreviewFeatures();\n    \n    // Clear working data\n    this.workingData = {\n      sourceFeature: null,\n      targetFeature: null,\n      previewFeature: null,\n      offsetLine: null,\n      offsetDistance: this.options.defaultDistance,\n      offsetBearing: this.options.defaultBearing,\n      mousePosition: null,\n      selectedPoint: null,\n      snapEnabled: true,\n    };\n  }\n  \n  /**\n   * Tool-specific reset logic\n   * @protected\n   * @override\n   */\n  _reset() {\n    // Clear any preview features\n    this._clearPreviewFeatures();\n    \n    // Reset working data but keep offset values\n    const currentDistance = this.workingData.offsetDistance;\n    const currentBearing = this.workingData.offsetBearing;\n    const currentMode = this.options.mode;\n    \n    this.workingData = {\n      sourceFeature: null,\n      targetFeature: null,\n      previewFeature: null,\n      offsetLine: null,\n      offsetDistance: currentDistance,\n      offsetBearing: currentBearing,\n      mousePosition: null,\n      selectedPoint: null,\n      snapEnabled: true,\n    };\n    \n    // Emit reset event\n    this.emit('reset', {\n      mode: currentMode,\n      offsetDistance: currentDistance,\n      offsetBearing: currentBearing,\n    });\n  }\n  \n  /**\n   * Set the offset mode\n   * @param {string} mode - The offset mode (point, line, perpendicular)\n   * @private\n   */\n  _setOffsetMode(mode) {\n    // Validate mode\n    if (!['point', 'line', 'perpendicular'].includes(mode)) {\n      console.error(`Invalid offset mode: ${mode}`);\n      mode = 'point';\n    }\n    \n    // Update the mode\n    this.options.mode = mode;\n    \n    // Reset the tool for the new mode\n    this._reset();\n    \n    // Emit mode change event\n    this.emit('modeChanged', { mode });\n  }\n  \n  /**\n   * Clear preview features\n   * @private\n   */\n  _clearPreviewFeatures() {\n    // Remove preview features from working features\n    if (this.workingData.previewFeature) {\n      this.manager.workingFeatures.removeFeature(this.workingData.previewFeature);\n      this.workingData.previewFeature = null;\n    }\n    \n    if (this.workingData.offsetLine) {\n      this.manager.workingFeatures.removeFeature(this.workingData.offsetLine);\n      this.workingData.offsetLine = null;\n    }\n  }\n  \n  /**\n   * Handle map click events\n   * @param {Object} event - The map click event\n   * @private\n   */\n  _handleMapClick(event) {\n    // Handle click based on current mode and state\n    switch (this.options.mode) {\n    case 'point':\n      if (!this.workingData.sourceFeature) {\n        // First click: select or create source point\n        if (this.workingData.selectedPoint) {\n          // Use the selected point as source\n          this.workingData.sourceFeature = this.workingData.selectedPoint;\n          this._updatePointOffsetPreview();\n        } else {\n          // Create a new source point at click location\n          this._createSourcePoint(event.coordinate);\n        }\n      } else {\n        // Second click: create offset point\n        this._createOffsetPoint();\n      }\n      break;\n        \n    case 'line':\n    case 'perpendicular':\n      if (!this.workingData.sourceFeature) {\n        // First click: select or create source line\n        const selectedFeatures = this.manager.getSelectedFeatures();\n        const selectedLine = selectedFeatures.find(f => f.type === 'line');\n          \n        if (selectedLine) {\n          // Use the selected line as source\n          this.workingData.sourceFeature = selectedLine;\n          this._updateLineOffsetPreview();\n        } else {\n          // Start creating a new line\n          this._startCreatingSourceLine(event.coordinate);\n        }\n      } else if (this.workingData.sourceFeature && this.workingData.sourceFeature.type === 'line') {\n        if (this.workingData.sourceFeature.isTemporary) {\n          // Add point to temporary source line\n          this._addPointToSourceLine(event.coordinate);\n        } else {\n          // Create offset from existing line\n          this._createOffsetFromLine();\n        }\n      }\n      break;\n    }\n  }\n  \n  /**\n   * Handle map mouse move events\n   * @param {Object} event - The map mousemove event\n   * @private\n   */\n  _handleMapMouseMove(event) {\n    // Store current mouse position\n    this.workingData.mousePosition = event.coordinate;\n    \n    // Update preview based on current mode and state\n    if (this.workingData.sourceFeature) {\n      switch (this.options.mode) {\n      case 'point':\n        this._updatePointOffsetPreview();\n        break;\n          \n      case 'line':\n      case 'perpendicular':\n        if (this.workingData.sourceFeature.isTemporary) {\n          // Update the temporary source line\n          this._updateTemporarySourceLine();\n        } else {\n          // Update the offset preview\n          this._updateLineOffsetPreview();\n        }\n        break;\n      }\n    }\n  }\n  \n  /**\n   * Handle map double click events\n   * @param {Object} event - The map double click event\n   * @private\n   */\n  _handleMapDoubleClick(event) {\n    // Prevent default browser behavior\n    if (event.originalEvent) {\n      event.originalEvent.preventDefault();\n    }\n    \n    // Complete line creation for line modes\n    if (['line', 'perpendicular'].includes(this.options.mode) && \n        this.workingData.sourceFeature && \n        this.workingData.sourceFeature.isTemporary) {\n      this._completeSourceLine();\n    }\n  }\n  \n  /**\n   * Handle keyboard events\n   * @param {KeyboardEvent} event - The keyboard event\n   * @private\n   */\n  _handleKeyDown(event) {\n    // Handle Escape key\n    if (event.key === 'Escape') {\n      if (['line', 'perpendicular'].includes(this.options.mode) && \n          this.workingData.sourceFeature && \n          this.workingData.sourceFeature.isTemporary) {\n        // Cancel line creation\n        this._cancelSourceLine();\n      } else {\n        // Reset the tool\n        this._reset();\n      }\n    }\n    \n    // Handle Enter key\n    if (event.key === 'Enter') {\n      if (['line', 'perpendicular'].includes(this.options.mode) && \n          this.workingData.sourceFeature && \n          this.workingData.sourceFeature.isTemporary) {\n        // Complete line creation\n        this._completeSourceLine();\n      } else if (this.workingData.sourceFeature) {\n        // Create offset\n        if (this.options.mode === 'point') {\n          this._createOffsetPoint();\n        } else {\n          this._createOffsetFromLine();\n        }\n      }\n    }\n    \n    // Handle number keys for quick distance changes\n    if (event.key >= '1' && event.key <= '9') {\n      const distance = parseInt(event.key) * (event.shiftKey ? 10 : 1);\n      this.setOffsetDistance(distance);\n    }\n    \n    // Handle arrow keys for bearing adjustments\n    if (event.key === 'ArrowLeft') {\n      this.adjustOffsetBearing(-15);\n      event.preventDefault();\n    } else if (event.key === 'ArrowRight') {\n      this.adjustOffsetBearing(15);\n      event.preventDefault();\n    } else if (event.key === 'ArrowUp') {\n      this.adjustOffsetDistance(1);\n      event.preventDefault();\n    } else if (event.key === 'ArrowDown') {\n      this.adjustOffsetDistance(-1);\n      event.preventDefault();\n    }\n  }\n  \n  /**\n   * Handle feature selection events\n   * @param {Object} feature - The selected feature\n   * @private\n   */\n  _handleFeatureSelected(feature) {\n    if (!this.isActive) {\n      return;\n    }\n    \n    // Store selected point for point mode\n    if (feature.type === 'point' && this.options.mode === 'point') {\n      this.workingData.selectedPoint = feature;\n      \n      // If no source feature yet, use this as source\n      if (!this.workingData.sourceFeature) {\n        this.workingData.sourceFeature = feature;\n        this._updatePointOffsetPreview();\n      }\n    }\n    \n    // Store selected line for line modes\n    if (feature.type === 'line' && ['line', 'perpendicular'].includes(this.options.mode)) {\n      // If no source feature yet, use this as source\n      if (!this.workingData.sourceFeature) {\n        this.workingData.sourceFeature = feature;\n        this._updateLineOffsetPreview();\n      }\n    }\n  }\n  \n  /**\n   * Create a source point at the specified coordinate\n   * @param {Object} coordinate - The coordinate for the source point\n   * @private\n   */\n  _createSourcePoint(coordinate) {\n    // Create a new point feature\n    const sourcePoint = new PointFeature(coordinate,{\n      id: `offset-source-${Date.now()}`,\n      properties: {\n        type: 'offset-source',\n        temporary: false,\n      },\n      style: this.options.sourceSymbol,\n    });\n    \n    // Apply 3D elevation if enabled\n    if (this.options.enable3D) {\n      this.manager.applyElevationData(sourcePoint);\n    }\n    \n    // Add to features collection\n    this.manager.features.addFeature(sourcePoint);\n    \n    // Set as source feature\n    this.workingData.sourceFeature = sourcePoint;\n    \n    // Create preview\n    this._updatePointOffsetPreview();\n    \n    // Emit event\n    this.emit('sourcePointCreated', sourcePoint);\n  }\n  \n  /**\n   * Update the point offset preview\n   * @private\n   */\n  _updatePointOffsetPreview() {\n    // Clear any existing preview\n    this._clearPreviewFeatures();\n    \n    if (!this.workingData.sourceFeature || this.workingData.sourceFeature.type !== 'point') {\n      return;\n    }\n    \n    // Get source point coordinate\n    const sourceCoord = this.workingData.sourceFeature.getCoordinate();\n    \n    // Calculate bearing\n    let bearing = this.workingData.offsetBearing;\n    \n    // If mouse position is available, calculate dynamic bearing\n    if (this.workingData.mousePosition) {\n      const mouseBearing = sourceCoord.bearingTo(new Coordinate(this.workingData.mousePosition));\n      \n      if (this.workingData.snapEnabled) {\n        // Snap to increments\n        bearing = Math.round(mouseBearing / this.options.bearingSnap) * this.options.bearingSnap;\n      } else {\n        bearing = mouseBearing;\n      }\n      \n      // Update stored bearing\n      this.workingData.offsetBearing = bearing;\n    }\n    \n    // Calculate offset point\n    const offsetCoord = GeometryEngine.destinationCoordinate(\n      sourceCoord,\n      this.workingData.offsetDistance,\n      bearing,\n    );\n    \n    // Create preview point\n    this.workingData.previewFeature = new PointFeature(offsetCoord,{\n      id: `offset-preview-${Date.now()}`,\n      properties: {\n        type: 'offset-preview',\n        temporary: true,\n      },\n      style: this.options.previewSymbol,\n    });\n    \n    // Create preview line\n    this.workingData.offsetLine = new LineFeature([sourceCoord, offsetCoord],{\n      id: `offset-line-${Date.now()}`,\n      properties: {\n        type: 'offset-line',\n        temporary: true,\n      },\n      style: this.options.lineSymbol,\n    });\n    \n    // Add to working features\n    this.manager.workingFeatures.addFeature(this.workingData.previewFeature);\n    this.manager.workingFeatures.addFeature(this.workingData.offsetLine);\n    \n    // Emit preview update event\n    this.emit('previewUpdated', {\n      distance: this.workingData.offsetDistance,\n      bearing: this.workingData.offsetBearing,\n      sourceCoordinate: sourceCoord,\n      targetCoordinate: offsetCoord,\n    });\n  }\n  \n  /**\n   * Create the offset point from the current preview\n   * @private\n   */\n  _createOffsetPoint() {\n    if (!this.workingData.sourceFeature || !this.workingData.previewFeature) {\n      return;\n    }\n    \n    // Get preview coordinate\n    const offsetCoord = this.workingData.previewFeature.getCoordinate();\n    \n    // Create the actual offset point\n    const offsetPoint = new PointFeature(offsetCoord, {\n      id: `offset-target-${Date.now()}`,\n      properties: {\n        type: 'offset-target',\n        offsetDistance: this.workingData.offsetDistance,\n        offsetBearing: this.workingData.offsetBearing,\n        sourceFeatureId: this.workingData.sourceFeature.id,\n        temporary: false,\n      },\n      style: this.options.targetSymbol,\n    });\n    \n    // Add to features collection\n    this.manager.features.addFeature(offsetPoint);\n    \n    // Store as target feature\n    this.workingData.targetFeature = offsetPoint;\n    \n    // Clear preview\n    this._clearPreviewFeatures();\n    \n    // Reset source feature but keep distance and bearing\n    this.workingData.sourceFeature = null;\n    \n    // Emit event\n    this.emit('offsetPointCreated', {\n      sourceFeature: this.workingData.sourceFeature,\n      targetFeature: offsetPoint,\n      distance: this.workingData.offsetDistance,\n      bearing: this.workingData.offsetBearing,\n    });\n    \n    // Reset for next operation\n    this._reset();\n  }\n  \n  /**\n   * Start creating a source line for line-based offset\n   * @param {Object} coordinate - The first coordinate of the line\n   * @private\n   */\n  _startCreatingSourceLine(coordinate) {\n    // Create a new line feature\n    const sourceLine = new LineFeature([coordinate], {\n      id: `offset-source-line-${Date.now()}`,\n      properties: {\n        type: 'offset-source',\n        temporary: true,\n      },\n      style: this.options.sourceSymbol,\n    });\n    \n    // Apply 3D elevation if enabled\n    if (this.options.enable3D) {\n      this.manager.applyElevationData(sourceLine);\n    }\n    \n    // Add to working features collection\n    this.manager.workingFeatures.addFeature(sourceLine);\n    \n    // Set as source feature\n    this.workingData.sourceFeature = sourceLine;\n    \n    // Emit event\n    this.emit('sourceLineStarted', sourceLine);\n  }\n  \n  /**\n   * Add a point to the source line being created\n   * @param {Object} coordinate - The coordinate to add\n   * @private\n   */\n  _addPointToSourceLine(coordinate) {\n    if (!this.workingData.sourceFeature || this.workingData.sourceFeature.type !== 'line') {\n      return;\n    }\n    \n    // Get existing coordinates\n    const coordinates = this.workingData.sourceFeature.getCoordinates();\n    \n    // Add the new coordinate\n    coordinates.push(coordinate);\n    \n    // Update the line\n    this.workingData.sourceFeature.setCoordinates(coordinates);\n    \n    // Apply 3D elevation if enabled\n    if (this.options.enable3D) {\n      this.manager.applyElevationData(this.workingData.sourceFeature);\n    }\n    \n    // Update preview if this is the second point (first segment)\n    if (coordinates.length === 2) {\n      this._updateLineOffsetPreview();\n    }\n    \n    // Emit event\n    this.emit('sourceLinePointAdded', {\n      line: this.workingData.sourceFeature,\n      coordinate: coordinate,\n      pointIndex: coordinates.length - 1,\n    });\n  }\n  \n  /**\n   * Update the temporary source line with mouse position\n   * @private\n   */\n  _updateTemporarySourceLine() {\n    if (!this.workingData.sourceFeature || \n        this.workingData.sourceFeature.type !== 'line' ||\n        !this.workingData.sourceFeature.isTemporary ||\n        !this.workingData.mousePosition) {\n      return;\n    }\n    \n    // Get existing coordinates\n    const coordinates = this.workingData.sourceFeature.getCoordinates();\n    \n    // Need at least one point\n    if (coordinates.length === 0) {\n      return;\n    }\n    \n    // Create preview coordinates with mouse position as last point\n    const previewCoords = [...coordinates.slice(0, -1), this.workingData.mousePosition];\n    \n    // Update the line\n    this.workingData.sourceFeature.setCoordinates(previewCoords);\n    \n    // Update offset preview if we have at least one segment\n    if (previewCoords.length >= 2) {\n      this._updateLineOffsetPreview();\n    }\n  }\n  \n  /**\n   * Complete the source line creation\n   * @private\n   */\n  _completeSourceLine() {\n    if (!this.workingData.sourceFeature || \n        this.workingData.sourceFeature.type !== 'line' ||\n        !this.workingData.sourceFeature.isTemporary) {\n      return;\n    }\n    \n    // Get coordinates\n    const coordinates = this.workingData.sourceFeature.getCoordinates();\n    \n    // Need at least two points for a valid line\n    if (coordinates.length < 2) {\n      this._cancelSourceLine();\n      return;\n    }\n    \n    // Create the final line\n    const sourceLine = new LineFeature(coordinates, {\n      id: `offset-source-line-${Date.now()}`,\n      properties: {\n        type: 'offset-source',\n        temporary: false,\n      },\n      style: this.options.sourceSymbol,\n    });\n    \n    // Apply 3D elevation if enabled\n    if (this.options.enable3D) {\n      this.manager.applyElevationData(sourceLine);\n    }\n    \n    // Add to features collection\n    this.manager.features.addFeature(sourceLine);\n    \n    // Remove temporary line\n    this.manager.workingFeatures.removeFeature(this.workingData.sourceFeature);\n    \n    // Set as source feature\n    this.workingData.sourceFeature = sourceLine;\n    \n    // Update preview\n    this._updateLineOffsetPreview();\n    \n    // Emit event\n    this.emit('sourceLineCompleted', sourceLine);\n  }\n  \n  /**\n   * Cancel source line creation\n   * @private\n   */\n  _cancelSourceLine() {\n    if (!this.workingData.sourceFeature || !this.workingData.sourceFeature.isTemporary) {\n      return;\n    }\n    \n    // Remove temporary line\n    this.manager.workingFeatures.removeFeature(this.workingData.sourceFeature);\n    \n    // Clear working data\n    this.workingData.sourceFeature = null;\n    this._clearPreviewFeatures();\n    \n    // Emit event\n    this.emit('sourceLineCancelled');\n  }\n  \n  /**\n   * Update the line offset preview\n   * @private\n   */\n  _updateLineOffsetPreview() {\n    // Clear any existing preview\n    this._clearPreviewFeatures();\n    \n    if (!this.workingData.sourceFeature || this.workingData.sourceFeature.type !== 'line') {\n      return;\n    }\n    \n    // Get source line coordinates\n    const sourceCoords = this.workingData.sourceFeature.getCoordinates();\n    \n    // Need at least two points for a valid line\n    if (sourceCoords.length < 2) {\n      return;\n    }\n    \n    let offsetCoords;\n\n    if (this.options.mode === 'line') {\n      // Parallel offset line\n      offsetCoords = this.geometryEngine.createOffsetLine(\n        sourceCoords,\n        this.workingData.offsetDistance,\n        { enable3D: this.options.enable3D },\n      );\n      \n      // Create preview line\n      this.workingData.previewFeature = new LineFeature(offsetCoords,{\n        id: `offset-preview-${Date.now()}`,\n        properties: {\n          type: 'offset-preview',\n          temporary: true,\n        },\n        style: Object.assign({}, this.options.lineSymbol, {\n          dashArray: '5,5',\n        }),\n      });\n      \n    } else if (this.options.mode === 'perpendicular') {\n      // Find closest point on line to mouse position\n      if (this.workingData.mousePosition) {\n        // Find nearest point on line to mouse position\n        const nearestInfo = this.workingData.sourceFeature.nearest(this.workingData.mousePosition);\n        \n        if (nearestInfo) {\n          // Calculate perpendicular offset\n          const perpendicular = this.geometryEngine.calculatePerpendicularOffset(\n            sourceCoords,\n            nearestInfo.pointIndex,\n            nearestInfo.segmentPosition,\n            this.workingData.offsetDistance,\n            { enable3D: this.options.enable3D },\n          );\n          \n          // Create preview point\n          this.workingData.previewFeature = new PointFeature(perpendicular.offsetPoint,{\n            id: `offset-preview-${Date.now()}`,\n            properties: {\n              type: 'offset-preview',\n              temporary: true,\n            },\n            style: this.options.previewSymbol,\n          });\n          \n          // Create preview line (perpendicular segment)\n          this.workingData.offsetLine = new LineFeature([nearestInfo.nearestPoint, perpendicular.offsetPoint], {\n            id: `offset-line-${Date.now()}`,\n            properties: {\n              type: 'offset-line',\n              temporary: true,\n            },\n            style: this.options.lineSymbol,\n          });\n          \n          // Store segment info for offset creation\n          this.workingData.perpendicularInfo = {\n            pointIndex: nearestInfo.pointIndex,\n            segmentPosition: nearestInfo.segmentPosition,\n            nearestPoint: nearestInfo.nearestPoint,\n            offsetPoint: perpendicular.offsetPoint,\n          };\n        }\n      }\n    }\n    \n    // Add to working features\n    if (this.workingData.previewFeature) {\n      this.manager.workingFeatures.addFeature(this.workingData.previewFeature);\n    }\n    \n    if (this.workingData.offsetLine) {\n      this.manager.workingFeatures.addFeature(this.workingData.offsetLine);\n    }\n    \n    // Emit preview update event\n    this.emit('previewUpdated', {\n      distance: this.workingData.offsetDistance,\n      sourceFeature: this.workingData.sourceFeature,\n      previewFeature: this.workingData.previewFeature,\n    });\n  }\n  \n  /**\n   * Create the offset feature from the current preview\n   * @private\n   */\n  _createOffsetFromLine() {\n    if (!this.workingData.sourceFeature || !this.workingData.previewFeature) {\n      return;\n    }\n    \n    let offsetFeature;\n    \n    if (this.options.mode === 'line') {\n      // Get preview coordinates\n      const offsetCoords = this.workingData.previewFeature.getCoordinates();\n      \n      // Create the actual offset line\n      offsetFeature = new LineFeature(offsetCoords, {\n        id: `offset-target-${Date.now()}`,\n        properties: {\n          type: 'offset-target',\n          offsetDistance: this.workingData.offsetDistance,\n          sourceFeatureId: this.workingData.sourceFeature.id,\n          temporary: false,\n        },\n        style: Object.assign({}, this.options.lineSymbol, {\n          dashArray: null,\n        }),\n      });\n      \n    } else if (this.options.mode === 'perpendicular') {\n      // Get preview coordinate\n      const offsetCoord = this.workingData.previewFeature.getCoordinate();\n      \n      // Create the actual offset point\n      offsetFeature = new PointFeature(offsetCoord, {\n        id: `offset-target-${Date.now()}`,\n        properties: {\n          type: 'offset-target',\n          offsetDistance: this.workingData.offsetDistance,\n          sourceFeatureId: this.workingData.sourceFeature.id,\n          pointIndex: this.workingData.perpendicularInfo.pointIndex,\n          segmentPosition: this.workingData.perpendicularInfo.segmentPosition,\n          temporary: false,\n        },\n        style: this.options.targetSymbol,\n      });\n    }\n    \n    if (offsetFeature) {\n      // Add to features collection\n      this.manager.features.addFeature(offsetFeature);\n      \n      // Store as target feature\n      this.workingData.targetFeature = offsetFeature;\n      \n      // Emit event\n      this.emit('offsetFeatureCreated', {\n        sourceFeature: this.workingData.sourceFeature,\n        targetFeature: offsetFeature,\n        distance: this.workingData.offsetDistance,\n        mode: this.options.mode,\n      });\n    }\n    \n    // Clear preview\n    this._clearPreviewFeatures();\n    \n    // Reset source feature but keep distance\n    this.workingData.sourceFeature = null;\n    \n    // Reset for next operation\n    this._reset();\n  }\n  \n  /**\n   * Set the offset distance\n   * @param {number} distance - The offset distance\n   * @returns {number} The updated distance\n   */\n  setOffsetDistance(distance) {\n    // Validate distance\n    if (isNaN(distance) || distance <= 0) {\n      console.error('Invalid offset distance. Must be a positive number.');\n      return this.workingData.offsetDistance;\n    }\n    \n    // Update distance\n    this.workingData.offsetDistance = distance;\n    \n    // Update preview if active\n    if (this.workingData.sourceFeature) {\n      if (this.options.mode === 'point') {\n        this._updatePointOffsetPreview();\n      } else {\n        this._updateLineOffsetPreview();\n      }\n    }\n    \n    // Emit event\n    this.emit('offsetDistanceChanged', {\n      distance: this.workingData.offsetDistance,\n    });\n    \n    return this.workingData.offsetDistance;\n  }\n  \n  /**\n   * Set the offset bearing (for point mode)\n   * @param {number} bearing - The offset bearing in degrees\n   * @returns {number} The updated bearing\n   */\n  setOffsetBearing(bearing) {\n    // Validate bearing\n    if (isNaN(bearing)) {\n      console.error('Invalid offset bearing. Must be a number.');\n      return this.workingData.offsetBearing;\n    }\n    \n    // Normalize bearing to 0-360 range\n    bearing = (bearing % 360 + 360) % 360;\n    \n    // Update bearing\n    this.workingData.offsetBearing = bearing;\n    \n    // Update preview if active in point mode\n    if (this.workingData.sourceFeature && this.options.mode === 'point') {\n      this._updatePointOffsetPreview();\n    }\n    \n    // Emit event\n    this.emit('offsetBearingChanged', {\n      bearing: this.workingData.offsetBearing,\n    });\n    \n    return this.workingData.offsetBearing;\n  }\n  \n  /**\n   * Adjust the offset distance by the specified amount\n   * @param {number} amount - The amount to adjust the distance by\n   * @returns {number} The updated distance\n   */\n  adjustOffsetDistance(amount) {\n    // Calculate new distance with snap\n    const newDistance = Math.max(\n      1,\n      Math.round((this.workingData.offsetDistance + amount) / this.options.distanceSnap) * this.options.distanceSnap,\n    );\n    \n    return this.setOffsetDistance(newDistance);\n  }\n  \n  /**\n   * Adjust the offset bearing by the specified amount\n   * @param {number} amount - The amount to adjust the bearing by (in degrees)\n   * @returns {number} The updated bearing\n   */\n  adjustOffsetBearing(amount) {\n    // Calculate new bearing with snap\n    const newBearing = Math.round((this.workingData.offsetBearing + amount) / this.options.bearingSnap) * this.options.bearingSnap;\n    \n    return this.setOffsetBearing(newBearing);\n  }\n  \n  /**\n   * Toggle snapping functionality\n   * @param {boolean} [enable] - Whether to enable snapping\n   * @returns {boolean} The updated snap state\n   */\n  toggleSnap(enable) {\n    if (typeof enable === 'boolean') {\n      this.workingData.snapEnabled = enable;\n    } else {\n      this.workingData.snapEnabled = !this.workingData.snapEnabled;\n    }\n    \n    // Emit event\n    this.emit('snapToggled', {\n      snapEnabled: this.workingData.snapEnabled,\n    });\n    \n    return this.workingData.snapEnabled;\n  }\n  \n  /**\n   * Set the offset mode\n   * @param {string} mode - The offset mode (point, line, perpendicular)\n   * @returns {boolean} Success of mode change\n   */\n  setMode(mode) {\n    if (!['point', 'line', 'perpendicular'].includes(mode)) {\n      console.error(`Invalid offset mode: ${mode}`);\n      return false;\n    }\n    \n    // Set the mode\n    this._setOffsetMode(mode);\n    \n    return true;\n  }\n  \n  /**\n   * Get the current offset settings\n   * @returns {Object} Current offset settings\n   */\n  getSettings() {\n    return {\n      mode: this.options.mode,\n      distance: this.workingData.offsetDistance,\n      bearing: this.workingData.offsetBearing,\n      enable3D: this.options.enable3D,\n      snapEnabled: this.workingData.snapEnabled,\n    };\n  }\n}","/**\n * DrawingTool.js\n * Tool for drawing points, lines, and polygons\n * Part of the RTK Surveyor 3D-first implementation\n * \n * Usage Notes:\n * - Points are created with a single click\n * - Lines require at least 2 vertices and can be completed by:\n *   1. Double-clicking\n *   2. Pressing Enter\n *   3. Right-clicking\n *   4. Clicking the line tool button again\n * - Polygons require at least 3 vertices and can be completed by:\n *   1. Double-clicking\n *   2. Pressing Enter\n *   3. Right-clicking\n *   4. Clicking the polygon tool button again (recommended)\n * - Press Escape to cancel drawing\n * - Press Backspace/Delete to remove the last vertex\n */\n\nimport { ToolBase } from './ToolBase.js';\nimport { PointFeature } from '../features/PointFeature.js';\nimport { LineFeature } from '../features/LineFeature.js';\nimport { PolygonFeature } from '../features/PolygonFeature.js';\nimport { Coordinate } from '../core/Coordinate.js';\n\n/**\n * @typedef {Object} DrawingToolOptions\n * @property {string} [mode='point'] - Drawing mode (point, line, polygon, freehand)\n * @property {boolean} [enable3D=true] - Whether to enable 3D drawing\n * @property {boolean} [continuousDrawing=false] - Whether to continue drawing after feature completion\n * @property {number} [freehandSamplingInterval=5] - Meters between points in freehand mode\n * @property {Object} [pointSymbol] - Symbol for points\n * @property {Object} [lineSymbol] - Symbol for lines\n * @property {Object} [polygonSymbol] - Symbol for polygons\n * @property {Object} [vertexSymbol] - Symbol for vertices\n */\n\n/**\n * Tool for drawing survey features\n * Supports point, line, polygon, and freehand drawing modes\n */\nexport class DrawingTool extends ToolBase {\n  /**\n   * Create a new DrawingTool instance\n   * @param {Object} options - Tool configuration options\n   */\n  constructor(options = {}) {\n    super(options);\n    \n    // Initialize tool-specific options with defaults\n    this.options = Object.assign({\n      mode: 'point',\n      enable3D: true,\n      continuousDrawing: false,\n      freehandSamplingInterval: 5, // meters\n      pointSymbol: Object.assign({\n        size: 32, // Larger size for better visibility\n        color: '#FF5733', // Orange color\n        outlineWidth: 2,\n        outlineColor: 'white',\n        useDualMarker: true, // Use the pin+dot style for better positioning feedback\n      }, this.manager.settings.defaultPointSymbol || {}),\n      lineSymbol: this.manager.settings.defaultLineSymbol,\n      // Enhanced lineSymbol with style for preview line\n      previewLineSymbol: {\n        color: '#3388FF', \n        width: 2,\n        opacity: 0.8,\n        dashArray: [5, 5],  // Dashed line for preview\n      },\n      polygonSymbol: this.manager.settings.defaultPolygonSymbol,\n      // Enhanced polygonSymbol with style for preview polygon\n      previewPolygonSymbol: {\n        fillColor: 'rgba(51, 136, 255, 0.1)',  // More transparent fill\n        outlineColor: '#3388FF',\n        outlineWidth: 2,\n        dashArray: [5, 5],  // Dashed outline for preview\n      },\n      vertexSymbol: {\n        type: 'circle',\n        size: 8,\n        color: '#3388FF',\n        outlineWidth: 2,\n        outlineColor: 'white',\n        // Don't use dual marker for vertices - use centered circle for precision\n        useDualMarker: false,\n      },\n      // Enhanced vertexSymbol with style for active vertices\n      activeVertexSymbol: {\n        type: 'circle',\n        size: 10,\n        color: '#3388FF',\n        outlineWidth: 2,\n        outlineColor: 'white',\n        // Don't use dual marker for vertices - use centered circle for precision\n        useDualMarker: false,\n      },\n    }, options);\n    \n    // Initialize internal state\n    this.workingData = {\n      activeFeature: null,\n      vertices: [],\n      mousePosition: null,\n      isDragging: false,\n      lastFreehandPoint: null,\n    };\n    \n    // Bind event handlers to maintain 'this' context\n    this._handleMapClick = this._handleMapClick.bind(this);\n    this._handleMapMouseMove = this._handleMapMouseMove.bind(this);\n    this._handleMapDoubleClick = this._handleMapDoubleClick.bind(this);\n    this._handleMapRightClick = this._handleMapRightClick.bind(this);\n    this._handleKeyDown = this._handleKeyDown.bind(this);\n    this._handleMapMouseDown = this._handleMapMouseDown.bind(this);\n    this._handleMapMouseUp = this._handleMapMouseUp.bind(this);\n  }\n  \n  /**\n   * Set up tool-specific event listeners\n   * @protected\n   * @override\n   */\n  _setupEventListeners() {\n    // Implement specific event listeners if needed\n  }\n  \n  /**\n   * Tool-specific activation logic\n   * @protected\n   * @override\n   */\n  _activate() {\n    console.log(`Activating DrawingTool in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`);\n    \n    // Ensure workingData is properly initialized\n    if (!this.workingData || typeof this.workingData !== 'object') {\n      this.workingData = {\n        activeFeature: null,\n        vertices: [],\n        mousePosition: null,\n        isDragging: false,\n        lastFreehandPoint: null,\n      };\n    }\n    \n    try {\n      // Add map event listeners\n      this.mapInterface.addEventListener('click', this._handleMapClick);\n      this.mapInterface.addEventListener('mousemove', this._handleMapMouseMove);\n      this.mapInterface.addEventListener('dblclick', this._handleMapDoubleClick);\n      this.mapInterface.addEventListener('contextmenu', this._handleMapRightClick);\n      this.mapInterface.addEventListener('mousedown', this._handleMapMouseDown);\n      this.mapInterface.addEventListener('mouseup', this._handleMapMouseUp);\n      \n      // Add keyboard event listeners\n      document.addEventListener('keydown', this._handleKeyDown);\n      \n      // Create a new drawing based on the current mode\n      this._startNewDrawing();\n\n      // Emit activation event with mode\n      this.emit('activated', {\n        mode: this.options.mode,\n        continuousDrawing: this.options.continuousDrawing,\n      });\n    } catch (error) {\n      console.error('Error activating DrawingTool:', error);\n    }\n  }\n  \n  /**\n   * Tool-specific deactivation logic\n   * @protected\n   * @override\n   */\n  _deactivate() {\n    // Remove map event listeners\n    this.mapInterface.removeEventListener('click', this._handleMapClick);\n    this.mapInterface.removeEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.removeEventListener('dblclick', this._handleMapDoubleClick);\n    this.mapInterface.removeEventListener('contextmenu', this._handleMapRightClick);\n    this.mapInterface.removeEventListener('mousedown', this._handleMapMouseDown);\n    this.mapInterface.removeEventListener('mouseup', this._handleMapMouseUp);\n    \n    // Remove keyboard event listeners\n    document.removeEventListener('keydown', this._handleKeyDown);\n    \n    // Clear any active drawing\n    this._clearActiveDrawing();\n    \n    // Reset working data but preserve structure\n    this.workingData = {\n      activeFeature: null,\n      vertices: [],\n      mousePosition: null,\n      isDragging: false,\n      lastFreehandPoint: null,\n    };\n  }\n  \n  /**\n   * Tool-specific reset logic\n   * @protected\n   * @override\n   */\n  _reset() {\n    // Ensure workingData is initialized\n    if (!this.workingData) {\n      this.workingData = {\n        activeFeature: null,\n        vertices: [],\n        mousePosition: null,\n        isDragging: false,\n        lastFreehandPoint: null,\n      };\n    } else {\n      // Finish current drawing if any and start a new one\n      if (this.workingData.activeFeature) {\n        this._completeDrawing();\n      }\n    }\n    \n    // Start a new drawing\n    this._startNewDrawing();\n  }\n  \n  /**\n   * Start a new drawing based on current mode\n   * @private\n   */\n  _startNewDrawing() {\n    // Clear any existing drawing\n    this._clearActiveDrawing();\n    \n    // Create appropriate feature based on mode\n    switch (this.options.mode) {\n    case 'point':\n      // For points, we don't create a feature until click\n      break;\n        \n    case 'line':\n      // Fix: Pass empty array directly as first parameter, not in options\n      this.workingData.activeFeature = new LineFeature([], {\n        id: `drawing-${Date.now()}`,\n        properties: {\n          type: 'drawing',\n          drawingType: 'line',\n          temporary: true,\n          isPreview: true,\n        },\n        style: this.options.previewLineSymbol || this.options.lineSymbol,\n      });\n      break;\n        \n    case 'polygon':\n      try {\n        // Create a minimal polygon with initial vertices to avoid centroid calculation error\n        // Use a tiny \"invisible\" triangle as a starter polygon that will be replaced\n        const initialCoords = [\n          new Coordinate(0, 0, 0),\n          new Coordinate(0, 0.000001, 0),\n          new Coordinate(0.000001, 0, 0),\n          new Coordinate(0, 0, 0), // Close the polygon\n        ];\n          \n        this.workingData.activeFeature = new PolygonFeature(initialCoords, {\n          id: `drawing-${Date.now()}`,\n          properties: {\n            type: 'drawing',\n            drawingType: 'polygon',\n            temporary: true,\n            isPreview: true,\n          },\n          style: this.options.previewPolygonSymbol || this.options.polygonSymbol,\n        });\n      } catch (error) {\n        console.error('Error creating polygon feature:', error);\n        // If polygon creation fails, create a line instead as fallback\n        this.workingData.activeFeature = new LineFeature([], {\n          id: `drawing-${Date.now()}`,\n          properties: {\n            type: 'drawing',\n            drawingType: 'line',\n            temporary: true,\n            isPreview: true,\n          },\n          style: this.options.previewLineSymbol || this.options.lineSymbol,\n        });\n        console.warn('Fallback to LineFeature for drawing');\n      }\n      break;\n        \n    case 'freehand':\n      // Fix: Pass empty array directly as first parameter, not in options\n      this.workingData.activeFeature = new LineFeature([], {\n        id: `drawing-${Date.now()}`,\n        properties: {\n          type: 'drawing',\n          drawingType: 'freehand',\n          temporary: true,\n          isPreview: true,\n        },\n        style: this.options.previewLineSymbol || this.options.lineSymbol,\n      });\n      break;\n    }\n    \n    // Add feature to working features if created\n    if (this.workingData.activeFeature) {\n      this.manager.workingFeatures.addFeature(this.workingData.activeFeature);\n    }\n    \n    // Reset vertices array\n    this.workingData.vertices = [];\n    this.workingData.lastFreehandPoint = null;\n  }\n  \n  /**\n   * Clear the active drawing\n   * @private\n   */\n  _clearActiveDrawing() {\n    // Ensure workingData exists and has required properties\n    if (!this.workingData) {\n      this.workingData = {\n        activeFeature: null,\n        vertices: [],\n        mousePosition: null,\n        isDragging: false,\n        lastFreehandPoint: null,\n      };\n      return;\n    }\n    \n    // Remove active feature from working features\n    if (this.workingData.activeFeature) {\n      this.manager.workingFeatures.removeFeature(this.workingData.activeFeature);\n      this.workingData.activeFeature = null;\n    }\n    \n    // Remove vertex features - with defensive check for vertices array\n    if (Array.isArray(this.workingData.vertices)) {\n      this.workingData.vertices.forEach(vertex => {\n        this.manager.workingFeatures.removeFeature(vertex);\n      });\n      \n      // Reset vertices array\n      this.workingData.vertices = [];\n    } else {\n      // Initialize vertices if it doesn't exist\n      this.workingData.vertices = [];\n    }\n  }\n  \n  /**\n   * Handle map click events\n   * @param {Object} event - The map click event\n   * @private\n   */\n  _handleMapClick(event) {\n    // Enhanced logging for debugging click issues\n    console.log('======== MAP CLICK EVENT ========');\n    console.log(`DrawingTool._handleMapClick called in ${this.options.mode} mode`);\n    console.log('Click event object:', {\n      type: event.type,\n      hasCoordinate: !!event.coordinate,\n      hasLatLng: !!event.latLng,\n      hasOriginalEvent: !!event.originalEvent,\n      hasPixel: !!event.pixel,\n      pixel: event.pixel ? `[${event.pixel[0]}, ${event.pixel[1]}]` : 'N/A',\n    });\n\n    // Skip freehand mode (handled by mousedown/mouseup)\n    if (this.options.mode === 'freehand') {\n      console.log('Skipping click in freehand mode');\n      return;\n    }\n    \n    // Extract coordinate from the event with error handling\n    let coordinate;\n    \n    // Check if there's an active snap point from the snapping manager\n    if (this.manager.snappingManager && this.manager.snappingManager.getSnapPoint()) {\n      // Use the snapped coordinate instead of the raw click coordinate\n      const snap = this.manager.snappingManager.getSnapPoint();\n      coordinate = snap.coordinate;\n    } else if (event.coordinate) {\n      coordinate = event.coordinate;\n    } else if (event.originalEvent && event.latLng) {\n      // Handle Google Maps native events if adapter didn't convert properly\n      coordinate = {\n        lat: event.latLng.lat(),\n        lng: event.latLng.lng(),\n        elevation: 0,\n      };\n    } else {\n      console.error('❌ ERROR: Invalid click event, no coordinate found', event);\n      return;\n    }\n    \n    try {\n      // Handle based on mode\n      switch (this.options.mode) {\n      case 'point':\n        // Create a point at the clicked location\n        this._createPoint(coordinate);\n        break;\n          \n      case 'line':\n      case 'polygon':\n        // Add vertex to the feature\n        this._addVertex(coordinate);\n        break;\n      }\n      \n    } catch (error) {\n      console.error(`❌ ERROR handling map click in ${this.options.mode} mode:`, error);\n      \n      // On error, try to recover by starting a new drawing\n      // This prevents the tool from getting stuck in a broken state\n      setTimeout(() => {\n        this._startNewDrawing();\n      }, 10);\n    }\n    \n  }\n  \n  /**\n   * Handle map mouse move events\n   * @param {Object} event - The map mousemove event\n   * @private\n   */\n  _handleMapMouseMove(event) {\n    try {\n      let coordinate;\n      \n      // Check if there's an active snap point from the snapping manager\n      if (this.manager.snappingManager && this.manager.snappingManager.getSnapPoint()) {\n        // Use the snapped coordinate\n        const snap = this.manager.snappingManager.getSnapPoint();\n        coordinate = snap.coordinate;\n      } else if (event.coordinate instanceof Coordinate) {\n        // Direct coordinate object\n        coordinate = event.coordinate;\n        \n      } else if (event.coordinate && typeof event.coordinate.lat === 'number' && typeof event.coordinate.lng === 'number') {\n        // Coordinate-like object\n        coordinate = new Coordinate(\n          event.coordinate.lat,\n          event.coordinate.lng,\n          event.coordinate.elevation !== undefined ? event.coordinate.elevation : 0,\n        );\n        \n      } else if (event.latLng && typeof event.latLng.lat === 'function' && typeof event.latLng.lng === 'function') {\n        // Google Maps LatLng object\n        coordinate = new Coordinate(\n          event.latLng.lat(),\n          event.latLng.lng(),\n          0,\n        );\n        \n      } else {\n        // Try to extract from raw event if available\n        const mapInterface = this.mapInterface;\n        if (event.originalEvent && mapInterface && typeof mapInterface.getCoordinateFromPixel === 'function') {\n          // Try to convert from pixel coordinates if map interface supports it\n          const pixel = {\n            x: event.originalEvent.clientX,\n            y: event.originalEvent.clientY,\n          };\n          coordinate = mapInterface.getCoordinateFromPixel(pixel);\n        }\n      }\n      \n      // Validate the coordinate\n      if (!coordinate || typeof coordinate.lat !== 'number' || typeof coordinate.lng !== 'number') {\n        console.error('Could not extract valid coordinate from mouse move event');\n        return;\n      }\n      \n      // Store the validated coordinate\n      this.workingData.mousePosition = coordinate;\n      \n      // Debug logging for tracking mouse position\n      if (this.options.mode === 'line' || this.options.mode === 'polygon') {\n        console.debug(`Mouse position: ${coordinate.lat.toFixed(6)}, ${coordinate.lng.toFixed(6)}`);\n      }\n      \n      // Handle freehand drawing\n      if (this.options.mode === 'freehand' && this.workingData.isDragging) {\n        this._handleFreehandDrawing(coordinate);\n      }\n      \n      // Update preview for line/polygon\n      if ((this.options.mode === 'line' || this.options.mode === 'polygon') && \n          this.workingData.activeFeature && \n          this.workingData.vertices.length > 0) {\n        // Call the enhanced _updatePreview method\n        this._updatePreview();\n      }\n    } catch (error) {\n      console.error('Error handling mouse move event:', error);\n    }\n  }\n  \n  /**\n   * Handle map double click events\n   * @param {Object} event - The map double click event\n   * @private\n   */\n  _handleMapDoubleClick(event) {\n    // Prevent default browser behavior if possible\n    if (event.originalEvent && typeof event.originalEvent.preventDefault === 'function') {\n      event.originalEvent.preventDefault();\n    }\n    \n    console.log(`Double click detected in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`);\n    \n    // Get coordinate, preferring snapped points if available\n    let coordinate;\n    if (this.manager.snappingManager && this.manager.snappingManager.getSnapPoint()) {\n      // Use the snapped coordinate for the final vertex\n      const snap = this.manager.snappingManager.getSnapPoint();\n      coordinate = snap.coordinate;\n      console.log('Using snapped coordinate for final vertex:', coordinate);\n    } else if (event.coordinate) {\n      coordinate = event.coordinate;\n    }\n    \n    // Add the final vertex at the current location before completing the drawing\n    if (coordinate && (this.options.mode === 'line' || this.options.mode === 'polygon')) {\n      console.log('Adding final vertex at double-click location');\n      this._addVertex(coordinate);\n    }\n    \n    // Complete drawing for line/polygon if we have enough vertices\n    if ((this.options.mode === 'line' && this.workingData.vertices.length >= 2) ||\n        (this.options.mode === 'polygon' && this.workingData.vertices.length >= 3)) {\n      \n      console.log(`Completing ${this.options.mode} with ${this.workingData.vertices.length} vertices`);\n      \n      // Complete the current drawing, which will respect the continuousDrawing option\n      this._completeDrawing();\n    } else {\n      console.log(`Not enough vertices to complete ${this.options.mode} drawing`);\n    }\n  }\n  \n  /**\n   * Handle map right click events\n   * @param {Object} event - The map right click event\n   * @private\n   */\n  _handleMapRightClick(event) {\n    // Prevent default context menu if possible\n    if (event.originalEvent && typeof event.originalEvent.preventDefault === 'function') {\n      event.originalEvent.preventDefault();\n    }\n    \n    console.log(`Right click detected in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`);\n    \n    // For line/polygon mode in the right conditions, complete the drawing\n    if ((this.options.mode === 'line' && this.workingData.vertices.length >= 1) ||\n        (this.options.mode === 'polygon' && this.workingData.vertices.length >= 2)) {\n      \n      // Don't add the right-click point as a vertex, just finish with existing vertices\n      console.log(`Completing ${this.options.mode} with ${this.workingData.vertices.length} vertices via right-click`);\n      \n      // We only complete if we have enough vertices\n      if ((this.options.mode === 'line' && this.workingData.vertices.length >= 2) ||\n          (this.options.mode === 'polygon' && this.workingData.vertices.length >= 3)) {\n        this._completeDrawing();\n      } else {\n        // Not enough vertices yet, just cancel\n        console.log(`Not enough vertices to complete ${this.options.mode}, canceling drawing`);\n        this._startNewDrawing();\n      }\n    } else {\n      // Otherwise cancel the drawing\n      console.log(`Canceling drawing and starting new ${this.options.mode} feature`);\n      this._startNewDrawing();\n    }\n  }\n  \n  /**\n   * Handle map mouse down events\n   * @param {Object} event - The map mousedown event\n   * @private\n   */\n  _handleMapMouseDown(event) {\n    // Start freehand drawing - check if originalEvent exists and has a button property\n    if (this.options.mode === 'freehand' && \n        event.originalEvent && \n        typeof event.originalEvent.button === 'number' && \n        event.originalEvent.button === 0) {\n      this.workingData.isDragging = true;\n      \n      // Get coordinate, preferring snapped points if available\n      let coordinate;\n      if (this.manager.snappingManager && this.manager.snappingManager.getSnapPoint()) {\n        // Use the snapped coordinate for the first point\n        const snap = this.manager.snappingManager.getSnapPoint();\n        coordinate = snap.coordinate;\n        console.log('Using snapped coordinate for freehand start:', coordinate);\n      } else if (event.coordinate) {\n        coordinate = event.coordinate;\n      }\n      \n      // Add the first point if coordinate is valid\n      if (coordinate) {\n        this._addFreehandPoint(coordinate);\n      }\n    }\n  }\n  \n  /**\n   * Handle map mouse up events\n   * @param {Object} event - The map mouseup event\n   * @private\n   */\n  _handleMapMouseUp(_event) {\n    // End freehand drawing\n    if (this.options.mode === 'freehand' && this.workingData.isDragging) {\n      this.workingData.isDragging = false;\n      \n      // Complete the drawing if we have enough points\n      if (this.workingData.activeFeature) {\n        const coordinates = this.workingData.activeFeature.getCoordinates();\n        if (coordinates.length >= 2) {\n          this._completeDrawing();\n        } else {\n          // Not enough points, reset\n          this._startNewDrawing();\n        }\n      }\n    }\n  }\n  \n  /**\n   * Handle keyboard events\n   * @param {KeyboardEvent} event - The keyboard event\n   * @private\n   */\n  _handleKeyDown(event) {\n    // Handle Escape key\n    if (event.key === 'Escape') {\n      console.log('Escape key pressed, canceling current drawing');\n      // Cancel drawing\n      this._startNewDrawing();\n    }\n    \n    // Handle Enter key\n    if (event.key === 'Enter') {\n      console.log(`Enter key pressed in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`);\n      \n      // Add current mouse position as final vertex if available and in appropriate mode\n      if ((this.options.mode === 'line' || this.options.mode === 'polygon') && \n          this.workingData.vertices.length > 0) {\n          \n        // Get coordinate, preferring snapped points if available\n        let finalCoordinate = this.workingData.mousePosition;\n        if (this.manager.snappingManager && this.manager.snappingManager.getSnapPoint()) {\n          // Use the snapped coordinate for the final vertex\n          const snap = this.manager.snappingManager.getSnapPoint();\n          finalCoordinate = snap.coordinate;\n          console.log('Using snapped coordinate for final vertex (Enter key):', finalCoordinate);\n        }\n        \n        if (finalCoordinate) {\n          console.log('Adding final vertex at current position');\n          this._addVertex(finalCoordinate);\n        }\n      }\n      \n      // Complete drawing if possible\n      if ((this.options.mode === 'line' && this.workingData.vertices.length >= 2) ||\n          (this.options.mode === 'polygon' && this.workingData.vertices.length >= 3)) {\n        console.log(`Completing ${this.options.mode} with ${this.workingData.vertices.length} vertices via Enter key`);\n        this._completeDrawing();\n      } else {\n        console.log(`Not enough vertices to complete ${this.options.mode} drawing`);\n      }\n    }\n    \n    // Handle Backspace/Delete key\n    if (event.key === 'Backspace' || event.key === 'Delete') {\n      console.log('Backspace/Delete key pressed, removing last vertex');\n      // Remove the last vertex\n      this._removeLastVertex();\n    }\n  }\n  \n  /**\n   * Create a point feature at the specified coordinate\n   * @param {Object} coordinate - The coordinate for the point\n   * @private\n   */\n  _createPoint(coordinate) {\n    try {\n      // Create point feature - ensure coordinate is properly formatted\n      // Import the Coordinate class from Survey.Core - available from the module import\n      let validCoord;\n      \n      // Check if coordinate is already a Coordinate instance\n      if (coordinate instanceof Coordinate) {\n        validCoord = coordinate;\n      } else if (coordinate && typeof coordinate.lat === 'number' && typeof coordinate.lng === 'number') {\n        // Create a proper Coordinate object from coordinate-like object\n        validCoord = new Coordinate(\n          coordinate.lat,\n          coordinate.lng,\n          coordinate.elevation !== undefined ? coordinate.elevation : 0,\n        );\n      } else {\n        console.error('Invalid coordinate provided:', coordinate);\n        throw new Error('Invalid coordinate');\n      }\n      \n      // Create the point style object\n      const pointStyle = {\n        ...this.options.pointSymbol,\n        // Use dual marker for points by default for better visual cues\n        // This shows both a pin and a dot at the exact location\n        useDualMarker: true,\n      };\n      \n      // Create a unique ID for debugging purposes\n      const pointId = `point-${Date.now()}`;\n\n      const pointFeature = new PointFeature(validCoord, {\n        id: pointId,\n        properties: {\n          type: 'drawing',\n          drawingType: 'point',\n          temporary: false,\n        },\n        style: pointStyle,\n      });\n\n      // Enhanced debugging for point creation\n      console.log('---------- POINT CREATION ----------');\n      console.log(`Created point with ID: ${pointId}`);\n      console.log(`At exact coordinate: ${validCoord.lat.toFixed(8)}, ${validCoord.lng.toFixed(8)}`);\n      console.log(`Using style: ${JSON.stringify(pointStyle)}`);\n      console.log('------------------------------------');\n      \n      // Apply 3D elevation if enabled\n      if (this.options.enable3D) {\n        this.manager.applyElevationData(pointFeature);\n      }\n      \n      // Add to features collection\n      this.manager.features.addFeature(pointFeature);\n      \n      // Emit event\n      this.emit('pointCreated', pointFeature);\n      \n      // Always maintain the tool active if continuous drawing is enabled\n      if (this.options.continuousDrawing) {\n        console.log('Continuous drawing enabled, keeping tool active - NO deactivation will occur');\n        // We don't need to do anything here - tool remains active\n      } else {\n        console.log('Continuous drawing disabled, tool will be deactivated');\n        // Schedule deactivation for a bit later to avoid race conditions\n        // Using a slightly longer timeout to ensure any event propagation completes\n        setTimeout(() => {\n          console.log('Now deactivating tool (continuousDrawing=false)');\n          this.manager.deactivateActiveTool();\n        }, 50);\n      }\n      \n      return pointFeature;\n    } catch (error) {\n      console.error('Error creating point feature:', error);\n      \n      // Avoid deactivating the tool on error to allow retrying\n      return null;\n    }\n  }\n  \n  /**\n   * Add a vertex to the active line or polygon\n   * @param {Object} coordinate - The coordinate to add\n   * @private\n   */\n  _addVertex(coordinate) {\n    try {\n      if (!this.workingData.activeFeature) {\n        console.log('No active feature found when trying to add vertex');\n        // Start a new drawing if there's no active feature\n        this._startNewDrawing();\n        if (!this.workingData.activeFeature) {\n          console.error('Failed to create new feature for drawing');\n          return;\n        }\n      }\n      \n      // Process coordinate to ensure it's usable\n      let validCoord;\n      \n      // Check if coordinate is already a proper Coordinate instance\n      if (coordinate instanceof Coordinate) {\n        validCoord = coordinate;\n      } else if (coordinate && typeof coordinate.lat === 'number' && typeof coordinate.lng === 'number') {\n        // Create a proper Coordinate object from coordinate-like object\n        validCoord = new Coordinate(\n          coordinate.lat,\n          coordinate.lng,\n          coordinate.elevation !== undefined ? coordinate.elevation : 0,\n        );\n      } else {\n        console.error('Invalid coordinate provided:', coordinate);\n        throw new Error('Invalid coordinate');\n      }\n      \n      console.log(`Adding vertex at ${validCoord.lat}, ${validCoord.lng} to ${this.options.mode} feature`);\n      \n      // Create enhanced vertex style that's more visible\n      const enhancedVertexStyle = {\n        ...this.options.vertexSymbol,\n        size: this.options.vertexSymbol.size || 8,\n        color: this.options.vertexSymbol.color || '#3388FF',\n        outlineWidth: this.options.vertexSymbol.outlineWidth || 2,\n        outlineColor: this.options.vertexSymbol.outlineColor || 'white',\n      };\n      \n      // Create vertex feature for visual feedback\n      const vertexFeature = new PointFeature(validCoord, {\n        id: `vertex-${Date.now()}-${this.workingData.vertices.length}`,\n        properties: {\n          type: 'vertex',\n          drawingId: this.workingData.activeFeature.id,\n          vertexIndex: this.workingData.vertices.length,\n          temporary: true,\n        },\n        style: enhancedVertexStyle,\n      });\n      \n      // Apply 3D elevation if enabled\n      if (this.options.enable3D) {\n        this.manager.applyElevationData(vertexFeature);\n      }\n      \n      // Add vertex to working features and vertices array\n      this.manager.workingFeatures.addFeature(vertexFeature);\n      this.workingData.vertices.push(vertexFeature);\n      \n      // Update feature geometry based on type\n      if (this.options.mode === 'line') {\n        const coordinates = this.workingData.vertices.map(v => v.getCoordinate());\n        console.log(`Setting line coordinates with ${coordinates.length} vertices`);\n        this.workingData.activeFeature.setCoordinates(coordinates);\n        \n        // Make sure the feature is properly triggering an update event\n        this.workingData.activeFeature.properties.lastUpdate = Date.now();\n        \n        // Notify the feature collection that this feature has been updated\n        this.manager.workingFeatures.updateFeature(this.workingData.activeFeature);\n        \n      } else if (this.options.mode === 'polygon') {\n        const coordinates = this.workingData.vertices.map(v => v.getCoordinate());\n        console.log(`Setting polygon coordinates with ${coordinates.length} vertices`);\n        \n        try {\n          // First try using setRings method (the preferred approach)\n          if (typeof this.workingData.activeFeature.setRings === 'function') {\n            this.workingData.activeFeature.setRings([coordinates]);\n          } \n          // Fall back to setCoordinates if setRings is not available\n          else if (typeof this.workingData.activeFeature.setCoordinates === 'function') {\n            console.log('Falling back to setCoordinates for polygon');\n            this.workingData.activeFeature.setCoordinates(coordinates);\n          }\n          else {\n            console.error('Polygon feature has neither setRings nor setCoordinates methods');\n          }\n        } catch (error) {\n          console.error('Error updating polygon coordinates:', error);\n        }\n        \n        // Make sure the feature is properly triggering an update event\n        this.workingData.activeFeature.properties.lastUpdate = Date.now();\n        \n        // Notify the feature collection that this feature has been updated\n        this.manager.workingFeatures.updateFeature(this.workingData.activeFeature);\n      }\n      \n      // After adding a vertex, ensure the preview is immediately updated\n      this._updatePreview();\n      \n      // Emit event\n      this.emit('vertexAdded', {\n        feature: this.workingData.activeFeature,\n        coordinate: validCoord,\n        vertexIndex: this.workingData.vertices.length - 1,\n      });\n      \n      // Log the current state of feature collection for debugging\n      setTimeout(() => {\n        const workingFeatureCount = this.manager.workingFeatures.getFeatureCount();\n        console.log(`Working features count after adding vertex: ${workingFeatureCount}`);\n        \n        const lineFeatures = this.manager.workingFeatures.getFeaturesByType('line');\n        const pointFeatures = this.manager.workingFeatures.getFeaturesByType('point');\n        console.log(`Working features by type - Lines: ${lineFeatures.length}, Points: ${pointFeatures.length}`);\n      }, 10);\n      \n    } catch (error) {\n      console.error('Error adding vertex:', error);\n      \n      // Try to recover by starting a new drawing\n      console.log('Attempting to recover by restarting the drawing');\n      setTimeout(() => {\n        this._startNewDrawing();\n      }, 10);\n    }\n  }\n  \n  /**\n   * Handle freehand drawing\n   * @param {Object} coordinate - The current mouse coordinate\n   * @private\n   */\n  _addFreehandPoint(coordinate) {\n    if (!this.workingData.activeFeature) {\n      return;\n    }\n    \n    // Only add points that are a certain distance apart\n    if (this.workingData.lastFreehandPoint) {\n      const distance = this.geometryEngine.calculateDistance(\n        this.workingData.lastFreehandPoint, \n        coordinate,\n      );\n      \n      // Skip if too close to the last point\n      if (distance < this.options.freehandSamplingInterval) {\n        return;\n      }\n    }\n    \n    // Create a proper Coordinate object if needed\n    let validCoord;\n    if (coordinate instanceof Coordinate) {\n      validCoord = coordinate;\n    } else if (coordinate && typeof coordinate.lat === 'number' && typeof coordinate.lng === 'number') {\n      validCoord = new Coordinate(\n        coordinate.lat,\n        coordinate.lng,\n        coordinate.elevation !== undefined ? coordinate.elevation : 0,\n      );\n    } else {\n      console.error('Invalid coordinate for freehand drawing:', coordinate);\n      return;\n    }\n    \n    // Add the point to the feature\n    const coordinates = this.workingData.activeFeature.getCoordinates();\n    coordinates.push(validCoord);\n    this.workingData.activeFeature.setCoordinates(coordinates);\n    \n    // Update the last freehand point with the validated coordinate\n    this.workingData.lastFreehandPoint = validCoord;\n    \n    // Apply 3D elevation if enabled (periodically to avoid too many requests)\n    if (this.options.enable3D && coordinates.length % 5 === 0) {\n      this.manager.applyElevationData(this.workingData.activeFeature);\n    }\n  }\n  \n  /**\n   * Handle ongoing freehand drawing\n   * @param {Object} coordinate - The current mouse coordinate\n   * @private\n   */\n  _handleFreehandDrawing(coordinate) {\n    // Check if there's an active snap point before using raw coordinate\n    let pointCoordinate = coordinate;\n    if (this.manager.snappingManager && this.manager.snappingManager.getSnapPoint()) {\n      // Use the snapped coordinate for the freehand point\n      const snap = this.manager.snappingManager.getSnapPoint();\n      pointCoordinate = snap.coordinate;\n    }\n    \n    // Add the freehand point\n    this._addFreehandPoint(pointCoordinate);\n  }\n  \n  /**\n   * Update the preview with the current mouse position\n   * This ensures that the line or polygon being drawn shows a preview\n   * that follows the mouse cursor in real-time\n   * @private\n   */\n  _updatePreview() {\n    if (!this.workingData.activeFeature || !this.workingData.mousePosition) {\n      return;\n    }\n    \n    // Get the coordinates of all existing vertices\n    const vertices = this.workingData.vertices.map(v => v.getCoordinate());\n    \n    // Ensure the mousePosition is a proper Coordinate object\n    const mouseCoordinate = this.workingData.mousePosition;\n    \n    // Handle line preview\n    if (this.options.mode === 'line' && vertices.length > 0) {\n      // For lines, show a preview from the last vertex to the mouse position\n      const previewCoords = [...vertices, mouseCoordinate];\n      \n      console.log(`Updating line preview with ${previewCoords.length} points, last point: ${mouseCoordinate.lat}, ${mouseCoordinate.lng}`);\n      \n      // Apply the new coordinates to the feature\n      this.workingData.activeFeature.setCoordinates(previewCoords);\n      \n      // Make sure the feature is properly triggering an update event\n      // by modifying a property to force an update if the coordinates didn't change\n      this.workingData.activeFeature.properties.lastPreviewUpdate = Date.now();\n      \n      // Notify the feature collection that this feature has been updated\n      this.manager.workingFeatures.updateFeature(this.workingData.activeFeature);\n    } \n    // Handle polygon preview\n    else if (this.options.mode === 'polygon' && vertices.length > 1) {\n      // For polygons, show a preview loop from last vertex to mouse position and back to first vertex\n      let previewCoords = [...vertices, mouseCoordinate];\n      \n      // Explicitly close the polygon by adding the first vertex at the end\n      // This ensures Google Maps won't add an extra segment automatically\n      if (vertices.length > 0) {\n        previewCoords = [...previewCoords, vertices[0]];\n      }\n      \n      console.log(`Updating polygon preview with ${previewCoords.length} points, explicitly closed, last point: ${mouseCoordinate.lat}, ${mouseCoordinate.lng}`);\n      \n      // Apply the new coordinates to the feature\n      this.workingData.activeFeature.setRings([previewCoords]);\n      \n      // Make sure the feature is properly triggering an update event\n      this.workingData.activeFeature.properties.lastPreviewUpdate = Date.now();\n      \n      // Notify the feature collection that this feature has been updated\n      this.manager.workingFeatures.updateFeature(this.workingData.activeFeature);\n    }\n  }\n  \n  /**\n   * Remove the last vertex from the drawing\n   * @private\n   */\n  _removeLastVertex() {\n    if (this.workingData.vertices.length === 0) {\n      return;\n    }\n    \n    // Remove the last vertex\n    const lastVertex = this.workingData.vertices.pop();\n    this.manager.workingFeatures.removeFeature(lastVertex);\n    \n    // Update feature geometry\n    if (this.options.mode === 'line') {\n      const coordinates = this.workingData.vertices.map(v => v.getCoordinate());\n      this.workingData.activeFeature.setCoordinates(coordinates);\n    } else if (this.options.mode === 'polygon') {\n      let coordinates = this.workingData.vertices.map(v => v.getCoordinate());\n      \n      // For polygons, explicitly close the ring by adding the first vertex at the end\n      // if we have at least one vertex\n      if (coordinates.length > 0) {\n        coordinates = [...coordinates, coordinates[0]];\n      }\n      \n      this.workingData.activeFeature.setRings([coordinates]);\n    }\n    \n    // Update preview\n    this._updatePreview();\n    \n    // Emit event\n    this.emit('vertexRemoved', {\n      feature: this.workingData.activeFeature,\n      vertexCount: this.workingData.vertices.length,\n    });\n  }\n  \n  /**\n   * Complete the current drawing\n   * @private\n   */\n  _completeDrawing() {\n    if (!this.workingData.activeFeature) {\n      console.log('No active feature to complete');\n      return;\n    }\n    \n    let finalFeature;\n    \n    switch (this.options.mode) {\n    case 'line':\n      // Need at least 2 vertices for a valid line\n      if (this.workingData.vertices.length < 2) {\n        console.log('Not enough vertices for a line (need at least 2)');\n        this._startNewDrawing();\n        return;\n      }\n        \n      // Create final line feature\n      const lineCoordinates = this.workingData.vertices.map(v => v.getCoordinate());\n      console.log(`Creating final line feature with ${lineCoordinates.length} vertices`);\n        \n      try {\n        // Using the existing feature to create the final one\n        this.workingData.activeFeature.properties.temporary = false;\n        this.workingData.activeFeature.properties.isPreview = false;\n        this.workingData.activeFeature.setCoordinates(lineCoordinates);\n          \n        // Change from preview style to final style\n        this.workingData.activeFeature.style = this.options.lineSymbol;\n          \n        // Set a more descriptive name for the line\n        const firstCoord = lineCoordinates[0];\n        const lastCoord = lineCoordinates[lineCoordinates.length - 1];\n          \n        // Format the coordinates for the name (rounded to 5 decimal places)\n        const startLat = firstCoord.lat.toFixed(5);\n        const startLng = firstCoord.lng.toFixed(5);\n        const endLat = lastCoord.lat.toFixed(5);\n        const endLng = lastCoord.lng.toFixed(5);\n          \n        this.workingData.activeFeature.setName(`Line from (${startLat}, ${startLng}) to (${endLat}, ${endLng})`);\n          \n        finalFeature = this.workingData.activeFeature;\n          \n        // Remove this feature from working features since we'll add it to permanent features\n        this.manager.workingFeatures.removeFeature(finalFeature);\n      } catch (error) {\n        console.error('Error finalizing line feature:', error);\n        this._startNewDrawing();\n        return;\n      }\n      break;\n        \n    case 'polygon':\n      // Need at least 3 vertices for a valid polygon\n      if (this.workingData.vertices.length < 3) {\n        console.log('Not enough vertices for a polygon (need at least 3)');\n        this._startNewDrawing();\n        return;\n      }\n        \n      // Create final polygon feature\n      let polygonCoordinates = this.workingData.vertices.map(v => v.getCoordinate());\n        \n      // Ensure the polygon is closed (first vertex is the same as last vertex)\n      if (polygonCoordinates.length > 0) {\n        // Explicitly close the polygon by adding the first vertex again\n        polygonCoordinates = [...polygonCoordinates, polygonCoordinates[0]];\n      }\n        \n      console.log(`Creating final polygon feature with ${polygonCoordinates.length} vertices (including closing vertex)`);\n        \n      try {\n        // Create a new polygon instance with the collected coordinates\n        finalFeature = new PolygonFeature(polygonCoordinates, {\n          id: `polygon-${Date.now()}`,\n          properties: {\n            type: 'drawing',\n            drawingType: 'polygon',\n            temporary: false,\n            isPreview: false,\n          },\n          style: this.options.polygonSymbol,\n        });\n          \n        // Set a descriptive name for the polygon\n        try {\n          const center = finalFeature.getCenter();\n          if (center) {\n            const centerLat = center.lat.toFixed(5);\n            const centerLng = center.lng.toFixed(5);\n            finalFeature.setName(`Polygon at (${centerLat}, ${centerLng})`);\n          } else {\n            finalFeature.setName(`Polygon with ${polygonCoordinates.length} vertices`);\n          }\n        } catch (/* eslint-disable-line no-unused-vars */ error) {\n          // Fallback naming if there's any issue getting the center\n          finalFeature.setName(`Polygon with ${polygonCoordinates.length} vertices`);\n        }\n          \n        // Remove the preview features from working features collection\n        this.manager.workingFeatures.removeFeature(this.workingData.activeFeature);\n          \n        // Also remove all vertex features from working features\n        this.workingData.vertices.forEach(vertex => {\n          this.manager.workingFeatures.removeFeature(vertex);\n        });\n      } catch (error) {\n        console.error('Error finalizing polygon feature:', error);\n        this._startNewDrawing();\n        return;\n      }\n      break;\n        \n    case 'freehand':\n      // Need at least 2 points for a valid freehand line\n      const freehandCoords = this.workingData.activeFeature.getCoordinates();\n      if (freehandCoords.length < 2) {\n        console.log('Not enough points for a freehand line (need at least 2)');\n        this._startNewDrawing();\n        return;\n      }\n        \n      // Create final feature based on geometry\n      console.log(`Creating final freehand feature with ${freehandCoords.length} vertices`);\n        \n      try {\n        // Using the existing feature for the final feature\n        this.workingData.activeFeature.properties.temporary = false;\n        this.workingData.activeFeature.properties.isPreview = false;\n          \n        // Change from preview style to final style\n        this.workingData.activeFeature.style = this.options.lineSymbol;\n          \n        // Set a descriptive name for the freehand line\n        const firstCoord = freehandCoords[0];\n        const lastCoord = freehandCoords[freehandCoords.length - 1];\n          \n        const startLat = firstCoord.lat.toFixed(5);\n        const startLng = firstCoord.lng.toFixed(5);\n        const endLat = lastCoord.lat.toFixed(5);\n        const endLng = lastCoord.lng.toFixed(5);\n          \n        this.workingData.activeFeature.setName(`Freehand line from (${startLat}, ${startLng}) to (${endLat}, ${endLng})`);\n          \n        finalFeature = this.workingData.activeFeature;\n          \n        // Remove this feature from working features since we'll add it to permanent features\n        this.manager.workingFeatures.removeFeature(finalFeature);\n      } catch (error) {\n        console.error('Error finalizing freehand feature:', error);\n        this._startNewDrawing();\n        return;\n      }\n      break;\n    }\n    \n    if (finalFeature) {\n      // Apply 3D elevation if enabled\n      if (this.options.enable3D) {\n        this.manager.applyElevationData(finalFeature);\n      }\n      \n      // Make sure the feature is no longer temporary\n      finalFeature.properties.temporary = false;\n      \n      // Set the feature ID to be a specific type\n      const featureType = this.options.mode === 'freehand' ? 'line' : this.options.mode;\n      finalFeature.id = `${featureType}-${Date.now()}`;\n      \n      // Add to features collection and log success\n      console.log(`Adding completed ${this.options.mode} feature to collection with ID ${finalFeature.id}`);\n      console.log('Feature details:', {\n        type: finalFeature.type,\n        id: finalFeature.id,\n        coordinates: finalFeature.getCoordinates ? finalFeature.getCoordinates() : null,\n        name: finalFeature.name,\n        properties: finalFeature.properties,\n      });\n      \n      this.manager.features.addFeature(finalFeature);\n      \n      // Verify the feature was added correctly\n      setTimeout(() => {\n        const featureCount = this.manager.features.getFeatureCount();\n        const lineFeatures = this.manager.features.getFeaturesByType('line');\n        console.log(`Total features after adding: ${featureCount}, Line features: ${lineFeatures.length}`);\n      }, 100);\n      \n      // Emit event\n      this.emit('drawingCompleted', finalFeature);\n      \n      // Handle tool state based on continuousDrawing setting\n      if (!this.options.continuousDrawing) {\n        console.log('Continuous drawing disabled, scheduling tool deactivation');\n        // Use setTimeout with longer delay to avoid race conditions with event handling\n        setTimeout(() => {\n          console.log('Now deactivating tool after completing drawing (continuousDrawing=false)');\n          this.manager.deactivateActiveTool();\n        }, 50);\n      } else {\n        // Start a new drawing immediately if in continuous mode\n        console.log('Continuous drawing enabled, starting new drawing');\n        // Use setTimeout to ensure other events are processed first\n        setTimeout(() => {\n          this._startNewDrawing();\n          console.log('New drawing started in continuous mode');\n        }, 10);\n      }\n    } else {\n      console.error('Failed to create final feature');\n      // Start a new drawing to recover from the error\n      this._startNewDrawing();\n    }\n  }\n  \n  /**\n   * Set the drawing mode\n   * @param {string} mode - The drawing mode (point, line, polygon, freehand)\n   * @returns {boolean} Success of mode change\n   */\n  setMode(mode) {\n    if (!['point', 'line', 'polygon', 'freehand'].includes(mode)) {\n      console.error(`Invalid drawing mode: ${mode}`);\n      return false;\n    }\n    \n    // If we're already in the same mode, complete the current drawing if possible\n    if (this.options.mode === mode) {\n      return this.tryCompleteCurrentDrawing();\n    }\n    \n    // Finish current drawing if any\n    if (this.workingData.activeFeature) {\n      if ((this.options.mode === 'line' && this.workingData.vertices.length >= 2) ||\n          (this.options.mode === 'polygon' && this.workingData.vertices.length >= 3) ||\n          (this.options.mode === 'freehand' && this.workingData.activeFeature.getCoordinates().length >= 2)) {\n        this._completeDrawing();\n      } else {\n        this._clearActiveDrawing();\n      }\n    }\n    \n    // Update mode\n    this.options.mode = mode;\n    \n    // Start new drawing with new mode\n    this._startNewDrawing();\n    \n    // Emit event\n    this.emit('modeChanged', { mode });\n    \n    return true;\n  }\n  \n  /**\n   * Try to complete the current drawing if there are enough vertices\n   * This is useful for finalizing a polygon or line when the user clicks the tool again\n   * @returns {boolean} True if a drawing was completed, false otherwise\n   */\n  tryCompleteCurrentDrawing() {\n    // Check if we have an active drawing with enough vertices\n    if (this.workingData.activeFeature) {\n      if ((this.options.mode === 'line' && this.workingData.vertices.length >= 2) ||\n          (this.options.mode === 'polygon' && this.workingData.vertices.length >= 3) ||\n          (this.options.mode === 'freehand' && this.workingData.activeFeature.getCoordinates().length >= 2)) {\n        console.log(`Completing ${this.options.mode} drawing with ${this.workingData.vertices.length} vertices via tool button click`);\n        this._completeDrawing();\n        return true;\n      } else {\n        console.log(`Not enough vertices to complete ${this.options.mode} drawing`);\n        // Not enough vertices, just start over\n        this._startNewDrawing();\n      }\n    } else {\n      // No active feature, create a new one\n      this._startNewDrawing();\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Set continuous drawing mode\n   * @param {boolean} enable - Whether to enable continuous drawing\n   * @returns {boolean} New state of continuous drawing mode\n   */\n  setContinuousDrawing(enable) {\n    this.options.continuousDrawing = !!enable;\n    \n    // Emit event\n    this.emit('continuousDrawingChanged', {\n      continuousDrawing: this.options.continuousDrawing,\n    });\n    \n    return this.options.continuousDrawing;\n  }\n  \n  /**\n   * Set 3D drawing mode\n   * @param {boolean} enable - Whether to enable 3D drawing\n   * @returns {boolean} New state of 3D drawing mode\n   */\n  setEnable3D(enable) {\n    this.options.enable3D = !!enable;\n    \n    // Emit event\n    this.emit('enable3DChanged', {\n      enable3D: this.options.enable3D,\n    });\n    \n    return this.options.enable3D;\n  }\n  \n  /**\n   * Set the freehand sampling interval\n   * @param {number} interval - The interval in meters\n   * @returns {number} The updated interval\n   */\n  setFreehandSamplingInterval(interval) {\n    if (isNaN(interval) || interval <= 0) {\n      console.error('Invalid sampling interval. Must be a positive number.');\n      return this.options.freehandSamplingInterval;\n    }\n    \n    this.options.freehandSamplingInterval = interval;\n    \n    // Emit event\n    this.emit('freehandSamplingIntervalChanged', {\n      interval: this.options.freehandSamplingInterval,\n    });\n    \n    return this.options.freehandSamplingInterval;\n  }\n  \n  /**\n   * Get the current drawing settings\n   * @returns {Object} Current drawing settings\n   */\n  getSettings() {\n    return {\n      mode: this.options.mode,\n      enable3D: this.options.enable3D,\n      continuousDrawing: this.options.continuousDrawing,\n      freehandSamplingInterval: this.options.freehandSamplingInterval,\n    };\n  }\n}","/**\n * EditingTool.js\n * Tool for editing features with 3D vertex manipulation\n * Part of the RTK Surveyor 3D-first implementation\n */\n\nimport { ToolBase } from './ToolBase.js';\nimport { PointFeature } from '../features/PointFeature.js';\nimport { LineFeature as _LineFeature } from '../features/LineFeature.js';\nimport { PolygonFeature as _PolygonFeature } from '../features/PolygonFeature.js';\n\n/**\n * @typedef {Object} EditingToolOptions\n * @property {boolean} [enable3D=true] - Whether to enable 3D editing\n * @property {number} [vertexDistanceTolerance=10] - Pixel distance tolerance for selecting vertices\n * @property {boolean} [allowVertexAddition=true] - Whether to allow adding new vertices to lines/polygons\n * @property {boolean} [allowVertexDeletion=true] - Whether to allow deleting vertices from lines/polygons\n * @property {Object} [vertexSymbol] - Symbol for regular vertices\n * @property {Object} [selectedVertexSymbol] - Symbol for selected vertices\n * @property {Object} [insertionVertexSymbol] - Symbol for insertion points\n * @property {Object} [lineSymbol] - Symbol for selected lines\n * @property {Object} [polygonSymbol] - Symbol for selected polygons\n */\n\n/**\n * Tool for editing survey features\n * Supports full 3D vertex manipulation and geometry editing\n */\nexport class EditingTool extends ToolBase {\n  /**\n   * Create a new EditingTool instance\n   * @param {Object} options - Tool configuration options\n   */\n  constructor(options = {}) {\n    super(options);\n    \n    // Initialize tool-specific options with defaults\n    this.options = Object.assign({\n      enable3D: true,\n      vertexDistanceTolerance: 10, // pixels\n      allowVertexAddition: true,\n      allowVertexDeletion: true,\n      snapToTerrain: true,\n      dragDistanceThreshold: 3, // pixels\n      vertexSymbol: {\n        type: 'circle',\n        size: 8,\n        color: '#3388FF',\n        outlineWidth: 1,\n        outlineColor: 'white',\n      },\n      selectedVertexSymbol: {\n        type: 'circle',\n        size: 10,\n        color: '#FF5733',\n        outlineWidth: 2,\n        outlineColor: 'white',\n      },\n      insertionVertexSymbol: {\n        type: 'circle',\n        size: 6,\n        color: 'rgba(51, 136, 255, 0.5)',\n        outlineWidth: 1,\n        outlineColor: '#3388FF',\n      },\n      lineSymbol: Object.assign({}, this.manager.settings.defaultLineSymbol, {\n        width: 4,\n        color: '#3388FF',\n      }),\n      polygonSymbol: Object.assign({}, this.manager.settings.defaultPolygonSymbol, {\n        outlineWidth: 3,\n        outlineColor: '#3388FF',\n      }),\n    }, options);\n    \n    // Initialize internal state\n    this.workingData = {\n      targetFeature: null,\n      originalFeature: null,\n      vertices: [],\n      insertionVertices: [],\n      selectedVertex: null,\n      isDragging: false,\n      dragStartPosition: null,\n      mousePosition: null,\n      operationMode: 'none', // none, move, add, delete\n      operationComplete: false,\n      draggedDistance: 0,\n      snapTargets: [],\n    };\n    \n    // Bind event handlers to maintain 'this' context\n    this._handleMapClick = this._handleMapClick.bind(this);\n    this._handleMapMouseMove = this._handleMapMouseMove.bind(this);\n    this._handleMapDoubleClick = this._handleMapDoubleClick.bind(this);\n    this._handleMapRightClick = this._handleMapRightClick.bind(this);\n    this._handleKeyDown = this._handleKeyDown.bind(this);\n    this._handleMapMouseDown = this._handleMapMouseDown.bind(this);\n    this._handleMapMouseUp = this._handleMapMouseUp.bind(this);\n    this._handleFeatureSelected = this._handleFeatureSelected.bind(this);\n  }\n  \n  /**\n   * Set up tool-specific event listeners\n   * @protected\n   * @override\n   */\n  _setupEventListeners() {\n    // Listen for feature selection from the manager\n    this.manager.on('featureSelected', this._handleFeatureSelected);\n    \n    // Listen for feature changes\n    this.manager.features.on('featureUpdated', feature => {\n      // If we're editing this feature, update our vertex controls\n      if (this.workingData.targetFeature && \n          this.workingData.targetFeature.id === feature.id) {\n        this._updateVertexControls();\n      }\n    });\n  }\n  \n  /**\n   * Tool-specific activation logic\n   * @protected\n   * @override\n   */\n  _activate() {\n    // Add map event listeners\n    this.mapInterface.addEventListener('click', this._handleMapClick);\n    this.mapInterface.addEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.addEventListener('dblclick', this._handleMapDoubleClick);\n    this.mapInterface.addEventListener('contextmenu', this._handleMapRightClick);\n    this.mapInterface.addEventListener('mousedown', this._handleMapMouseDown);\n    this.mapInterface.addEventListener('mouseup', this._handleMapMouseUp);\n    \n    // Add keyboard event listeners\n    document.addEventListener('keydown', this._handleKeyDown);\n    \n    // Set initial state\n    this.workingData.operationMode = 'none';\n    \n    // Look for currently selected feature\n    const selectedFeatures = this.manager.getSelectedFeatures();\n    if (selectedFeatures.length === 1) {\n      this._startEditingFeature(selectedFeatures[0]);\n    }\n    \n    // Emit activation event\n    this.emit('activated', {\n      enable3D: this.options.enable3D,\n      targetFeature: this.workingData.targetFeature,\n    });\n  }\n  \n  /**\n   * Tool-specific deactivation logic\n   * @protected\n   * @override\n   */\n  _deactivate() {\n    // Remove map event listeners\n    this.mapInterface.removeEventListener('click', this._handleMapClick);\n    this.mapInterface.removeEventListener('mousemove', this._handleMapMouseMove);\n    this.mapInterface.removeEventListener('dblclick', this._handleMapDoubleClick);\n    this.mapInterface.removeEventListener('contextmenu', this._handleMapRightClick);\n    this.mapInterface.removeEventListener('mousedown', this._handleMapMouseDown);\n    this.mapInterface.removeEventListener('mouseup', this._handleMapMouseUp);\n    \n    // Remove keyboard event listeners\n    document.removeEventListener('keydown', this._handleKeyDown);\n    \n    // Complete any in-progress editing\n    this._completeEditing();\n    \n    // Clear vertex controls\n    this._clearVertexControls();\n    \n    // Reset state\n    this.workingData.targetFeature = null;\n    this.workingData.originalFeature = null;\n    this.workingData.operationMode = 'none';\n  }\n  \n  /**\n   * Tool-specific reset logic\n   * @protected\n   * @override\n   */\n  _reset() {\n    // Complete any in-progress editing\n    this._completeEditing();\n    \n    // Reset for next operation\n    this.workingData.operationMode = 'none';\n    this.workingData.selectedVertex = null;\n    this.workingData.isDragging = false;\n    this.workingData.operationComplete = false;\n    \n    // Keep the target feature, just update the vertex controls\n    if (this.workingData.targetFeature) {\n      this._updateVertexControls();\n    }\n  }\n  \n  /**\n   * Handle map click events\n   * @param {Object} event - The map click event\n   * @private\n   */\n  _handleMapClick(event) {\n    // Skip if already dragging\n    if (this.workingData.isDragging) {\n      return;\n    }\n    \n    const coordinate = event.coordinate;\n    const screenPosition = event.pixel;\n    \n    // If we don't have a target feature, try to select one\n    if (!this.workingData.targetFeature) {\n      this._selectFeatureAtPosition(coordinate, screenPosition);\n      return;\n    }\n    \n    // If we have a target but no operation mode, check if we're clicking a vertex\n    if (this.workingData.operationMode === 'none') {\n      // Check for vertex selection first\n      const vertex = this._findVertexAtPosition(screenPosition);\n      if (vertex) {\n        this._selectVertex(vertex);\n        return;\n      }\n      \n      // Check for insertion point selection\n      if (this.options.allowVertexAddition) {\n        const insertionVertex = this._findInsertionVertexAtPosition(screenPosition);\n        if (insertionVertex) {\n          this._addVertexAtInsertion(insertionVertex);\n          return;\n        }\n      }\n      \n      // If we clicked the feature but not on a vertex, select for move\n      if (this._isPositionOnFeature(coordinate, screenPosition)) {\n        // Set mode to move the entire feature\n        this.workingData.operationMode = 'move';\n        this.workingData.dragStartPosition = coordinate;\n        \n        // Emit event\n        this.emit('featureMoveStarted', {\n          feature: this.workingData.targetFeature,\n          coordinate: coordinate,\n        });\n        \n        return;\n      }\n      \n      // If we clicked elsewhere, deselect the feature\n      this._stopEditingFeature();\n    }\n  }\n  \n  /**\n   * Handle map mouse move events\n   * @param {Object} event - The map mousemove event\n   * @private\n   */\n  _handleMapMouseMove(event) {\n    // Store mouse position\n    this.workingData.mousePosition = event.coordinate;\n    const screenPosition = event.pixel;\n    \n    // Handle drag operations\n    if (this.workingData.isDragging) {\n      this._handleDrag(event.coordinate, screenPosition);\n      return;\n    }\n    \n    // Update UI feedback based on what's under the cursor\n    if (this.workingData.targetFeature) {\n      // Check for hover over vertices\n      const vertex = this._findVertexAtPosition(screenPosition);\n      if (vertex) {\n        // Highlight the vertex\n        this._highlightVertex(vertex);\n        this.mapInterface.setCursor('pointer');\n        return;\n      }\n      \n      // Check for hover over insertion points\n      if (this.options.allowVertexAddition) {\n        const insertionVertex = this._findInsertionVertexAtPosition(screenPosition);\n        if (insertionVertex) {\n          // Highlight the insertion point\n          this._highlightInsertionVertex(insertionVertex);\n          this.mapInterface.setCursor('pointer');\n          return;\n        }\n      }\n      \n      // Check if we're over the feature itself\n      if (this._isPositionOnFeature(event.coordinate, screenPosition)) {\n        this.mapInterface.setCursor('move');\n        return;\n      }\n    }\n    \n    // Default cursor\n    this.mapInterface.setCursor('default');\n  }\n  \n  /**\n   * Handle map double click events\n   * @param {Object} event - The map double click event\n   * @private\n   */\n  _handleMapDoubleClick(event) {\n    // Prevent default browser behavior\n    if (event.originalEvent) {\n      event.originalEvent.preventDefault();\n    }\n    \n    // Currently no special behavior for double-click in the editing tool\n  }\n  \n  /**\n   * Handle map right click events\n   * @param {Object} event - The map right click event\n   * @private\n   */\n  _handleMapRightClick(event) {\n    // Prevent default context menu\n    if (event.originalEvent) {\n      event.originalEvent.preventDefault();\n    }\n    \n    // If we have a selected vertex and deletion is allowed, delete it\n    if (this.workingData.selectedVertex && this.options.allowVertexDeletion) {\n      this._deleteSelectedVertex();\n      return;\n    }\n    \n    // If we right-click on the feature, complete editing\n    if (this.workingData.targetFeature && \n        this._isPositionOnFeature(event.coordinate, event.pixel)) {\n      this._completeEditing();\n      return;\n    }\n    \n    // Right-click elsewhere, stop editing\n    this._stopEditingFeature();\n  }\n  \n  /**\n   * Handle map mouse down events\n   * @param {Object} event - The map mousedown event\n   * @private\n   */\n  _handleMapMouseDown(event) {\n    // Only handle left mouse button\n    if (event.originalEvent.button !== 0) {\n      return;\n    }\n    \n    // Start potential drag\n    if (this.workingData.targetFeature) {\n      const screenPosition = event.pixel;\n      const coordinate = event.coordinate;\n      \n      // Check if we're on a vertex\n      const vertex = this._findVertexAtPosition(screenPosition);\n      if (vertex) {\n        this._selectVertex(vertex);\n        this.workingData.isDragging = true;\n        this.workingData.dragStartPosition = coordinate;\n        this.workingData.operationMode = 'moveVertex';\n        this.workingData.draggedDistance = 0;\n        \n        // Emit event\n        this.emit('vertexMoveStarted', {\n          feature: this.workingData.targetFeature,\n          vertexIndex: vertex.vertexIndex,\n          coordinate: coordinate,\n        });\n        \n        return;\n      }\n      \n      // Check if we're on an insertion point\n      if (this.options.allowVertexAddition) {\n        const insertionVertex = this._findInsertionVertexAtPosition(screenPosition);\n        if (insertionVertex) {\n          // For insertion points, we add the vertex on click, not drag\n          return;\n        }\n      }\n      \n      // Check if we're on the feature itself\n      if (this._isPositionOnFeature(coordinate, screenPosition)) {\n        this.workingData.isDragging = true;\n        this.workingData.dragStartPosition = coordinate;\n        this.workingData.operationMode = 'move';\n        this.workingData.draggedDistance = 0;\n        \n        // Emit event\n        this.emit('featureMoveStarted', {\n          feature: this.workingData.targetFeature,\n          coordinate: coordinate,\n        });\n      }\n    }\n  }\n  \n  /**\n   * Handle map mouse up events\n   * @param {Object} event - The map mouseup event\n   * @private\n   */\n  _handleMapMouseUp(event) {\n    // End any drag operation\n    if (this.workingData.isDragging) {\n      this.workingData.isDragging = false;\n      \n      // If we didn't drag far enough, treat it as a click\n      if (this.workingData.draggedDistance < this.options.dragDistanceThreshold) {\n        // For vertex, just keep it selected\n        if (this.workingData.operationMode === 'moveVertex') {\n          // Keep vertex selected, but clear drag state\n          this.workingData.dragStartPosition = null;\n        } else if (this.workingData.operationMode === 'move') {\n          // For feature move, just clear drag state\n          this.workingData.dragStartPosition = null;\n        }\n      } else {\n        // Complete the drag operation\n        if (this.workingData.operationMode === 'moveVertex') {\n          // Emit event\n          this.emit('vertexMoveCompleted', {\n            feature: this.workingData.targetFeature,\n            vertexIndex: this.workingData.selectedVertex.vertexIndex,\n            coordinate: event.coordinate,\n          });\n        } else if (this.workingData.operationMode === 'move') {\n          // Emit event\n          this.emit('featureMoveCompleted', {\n            feature: this.workingData.targetFeature,\n            coordinate: event.coordinate,\n          });\n        }\n        \n        // Reset operation mode\n        this.workingData.operationMode = 'none';\n        this.workingData.dragStartPosition = null;\n      }\n    }\n  }\n  \n  /**\n   * Handle keyboard events\n   * @param {KeyboardEvent} event - The keyboard event\n   * @private\n   */\n  _handleKeyDown(event) {\n    // Handle Escape key\n    if (event.key === 'Escape') {\n      if (this.workingData.isDragging) {\n        // Cancel drag operation\n        this._cancelDrag();\n      } else if (this.workingData.selectedVertex) {\n        // Deselect vertex\n        this._deselectVertex();\n      } else if (this.workingData.targetFeature) {\n        // Cancel editing\n        this._cancelEditing();\n      }\n    }\n    \n    // Handle Delete key\n    if ((event.key === 'Delete' || event.key === 'Backspace') && \n        this.workingData.selectedVertex && \n        this.options.allowVertexDeletion) {\n      this._deleteSelectedVertex();\n    }\n    \n    // Handle Enter key\n    if (event.key === 'Enter') {\n      if (this.workingData.targetFeature) {\n        this._completeEditing();\n      }\n    }\n  }\n  \n  /**\n   * Handle feature selection events\n   * @param {Object} feature - The selected feature\n   * @private\n   */\n  _handleFeatureSelected(feature) {\n    if (!this.isActive) {\n      return;\n    }\n    \n    // If we're already editing a different feature, complete that edit first\n    if (this.workingData.targetFeature && \n        this.workingData.targetFeature.id !== feature.id) {\n      this._completeEditing();\n    }\n    \n    // Start editing the selected feature\n    this._startEditingFeature(feature);\n  }\n  \n  /**\n   * Start editing a feature\n   * @param {Object} feature - The feature to edit\n   * @private\n   */\n  _startEditingFeature(feature) {\n    // Only allow editing certain feature types\n    if (!['point', 'line', 'polygon'].includes(feature.type)) {\n      console.warn('Cannot edit feature of type:', feature.type);\n      return;\n    }\n    \n    // Store original feature state for undo\n    this.workingData.originalFeature = {\n      id: feature.id,\n      type: feature.type,\n      data: feature.toGeoJSON(),\n    };\n    \n    // Set as target feature\n    this.workingData.targetFeature = feature;\n    \n    // Create vertex controls\n    this._createVertexControls();\n    \n    // Reset operation state\n    this.workingData.operationMode = 'none';\n    this.workingData.selectedVertex = null;\n    this.workingData.isDragging = false;\n    \n    // Apply editing styles to feature\n    this._applyEditingStyle();\n    \n    // Emit event\n    this.emit('editingStarted', {\n      feature: feature,\n      featureType: feature.type,\n    });\n  }\n  \n  /**\n   * Stop editing the current feature\n   * @private\n   */\n  _stopEditingFeature() {\n    if (!this.workingData.targetFeature) {\n      return;\n    }\n    \n    // Clear vertex controls\n    this._clearVertexControls();\n    \n    // Restore original style\n    this._restoreOriginalStyle();\n    \n    // Get feature for event\n    const feature = this.workingData.targetFeature;\n    \n    // Clear target feature\n    this.workingData.targetFeature = null;\n    this.workingData.originalFeature = null;\n    this.workingData.selectedVertex = null;\n    this.workingData.operationMode = 'none';\n    \n    // Emit event\n    this.emit('editingStopped', {\n      feature: feature,\n    });\n  }\n  \n  /**\n   * Apply editing style to the target feature\n   * @private\n   */\n  _applyEditingStyle() {\n    if (!this.workingData.targetFeature) {\n      return;\n    }\n    \n    // Store original style\n    this.workingData.originalStyle = this.workingData.targetFeature.getStyle();\n    \n    // Apply appropriate style based on feature type\n    switch (this.workingData.targetFeature.type) {\n    case 'point':\n      // For points, we don't change the style\n      break;\n        \n    case 'line':\n      this.workingData.targetFeature.setStyle(this.options.lineSymbol);\n      break;\n        \n    case 'polygon':\n      this.workingData.targetFeature.setStyle(this.options.polygonSymbol);\n      break;\n    }\n  }\n  \n  /**\n   * Restore original style to the edited feature\n   * @private\n   */\n  _restoreOriginalStyle() {\n    if (!this.workingData.targetFeature || !this.workingData.originalStyle) {\n      return;\n    }\n    \n    // Restore the original style\n    this.workingData.targetFeature.setStyle(this.workingData.originalStyle);\n    this.workingData.originalStyle = null;\n  }\n  \n  /**\n   * Create vertex control points for the target feature\n   * @private\n   */\n  _createVertexControls() {\n    if (!this.workingData.targetFeature) {\n      return;\n    }\n    \n    // Clear any existing controls\n    this._clearVertexControls();\n    \n    let vertices = [];\n    \n    // Create vertices based on feature type\n    switch (this.workingData.targetFeature.type) {\n    case 'point':\n      // For points, create a single vertex\n      const coordinate = this.workingData.targetFeature.getCoordinate();\n      vertices.push(this._createVertexFeature(coordinate, 0));\n      break;\n        \n    case 'line':\n      // For lines, create vertices for each point\n      const lineCoordinates = this.workingData.targetFeature.getCoordinates();\n      vertices = lineCoordinates.map((coord, index) => \n        this._createVertexFeature(coord, index),\n      );\n        \n      // Create insertion vertices for potential new points\n      if (this.options.allowVertexAddition) {\n        this._createInsertionVertices(lineCoordinates);\n      }\n      break;\n        \n    case 'polygon':\n      // For polygons, create vertices for each point in each ring\n      const rings = this.workingData.targetFeature.getRings();\n      let vertexIndex = 0;\n        \n      rings.forEach((ring, ringIndex) => {\n        // Don't create a vertex for the closing point (it's the same as the first)\n        const ringVertices = ring.slice(0, -1).map((coord, pointIndex) => {\n          const vertex = this._createVertexFeature(coord, vertexIndex, {\n            ringIndex: ringIndex,\n            pointIndex: pointIndex,\n          });\n          vertexIndex++;\n          return vertex;\n        });\n          \n        vertices = vertices.concat(ringVertices);\n          \n        // Create insertion vertices for potential new points\n        if (this.options.allowVertexAddition) {\n          this._createInsertionVertices(ring, ringIndex);\n        }\n      });\n      break;\n    }\n    \n    // Store vertices\n    this.workingData.vertices = vertices;\n    \n    // Add vertices to the map\n    vertices.forEach(vertex => {\n      this.manager.workingFeatures.addFeature(vertex);\n    });\n    \n    // Add insertion vertices to the map\n    this.workingData.insertionVertices.forEach(vertex => {\n      this.manager.workingFeatures.addFeature(vertex);\n    });\n  }\n  \n  /**\n   * Update vertex control points for the target feature\n   * @private\n   */\n  _updateVertexControls() {\n    // Just recreate them\n    this._createVertexControls();\n  }\n  \n  /**\n   * Clear all vertex control points\n   * @private\n   */\n  _clearVertexControls() {\n    // Remove all vertices from the map\n    this.workingData.vertices.forEach(vertex => {\n      this.manager.workingFeatures.removeFeature(vertex);\n    });\n    \n    // Remove all insertion vertices from the map\n    this.workingData.insertionVertices.forEach(vertex => {\n      this.manager.workingFeatures.removeFeature(vertex);\n    });\n    \n    // Clear arrays\n    this.workingData.vertices = [];\n    this.workingData.insertionVertices = [];\n    this.workingData.selectedVertex = null;\n  }\n  \n  /**\n   * Create a vertex feature at the specified coordinate\n   * @param {Object} coordinate - The coordinate for the vertex\n   * @param {number} index - The index of the vertex\n   * @param {Object} [metadata] - Additional metadata for the vertex\n   * @returns {Object} The created vertex feature\n   * @private\n   */\n  _createVertexFeature(coordinate, index, metadata = {}) {\n    const vertexFeature = new PointFeature(coordinate, {\n      id: `vertex-${this.workingData.targetFeature.id}-${index}`,\n      properties: Object.assign({\n        type: 'vertex',\n        featureId: this.workingData.targetFeature.id,\n        vertexIndex: index,\n        isSelected: false,\n        temporary: true,\n      }, metadata),\n      style: this.options.vertexSymbol,\n    });\n    \n    return vertexFeature;\n  }\n  \n  /**\n   * Create insertion vertex features between existing vertices\n   * @param {Array} coordinates - The coordinates to create insertion vertices for\n   * @param {number} [ringIndex] - The ring index for polygon features\n   * @private\n   */\n  _createInsertionVertices(coordinates, ringIndex = 0) {\n    if (coordinates.length < 2) {\n      return;\n    }\n    \n    const insertionVertices = [];\n    \n    // For polygons, we need to include the closing segment\n    const isClosed = this.workingData.targetFeature.type === 'polygon';\n    const segmentCount = isClosed ? coordinates.length : coordinates.length - 1;\n    \n    for (let i = 0; i < segmentCount; i++) {\n      const start = coordinates[i];\n      const end = coordinates[(i + 1) % coordinates.length];\n      \n      // Calculate midpoint\n      const midpoint = this.geometryEngine.interpolate(start, end, 0.5);\n      \n      // Create insertion vertex\n      const insertionVertex = new PointFeature(midpoint, {\n        id: `insertion-${this.workingData.targetFeature.id}-${ringIndex}-${i}`,\n        properties: {\n          type: 'insertionVertex',\n          featureId: this.workingData.targetFeature.id,\n          segmentIndex: i,\n          ringIndex: ringIndex,\n          startVertex: i,\n          endVertex: (i + 1) % coordinates.length,\n          temporary: true,\n        },\n        style: this.options.insertionVertexSymbol,\n      });\n      \n      insertionVertices.push(insertionVertex);\n    }\n    \n    // Add to insertion vertices array\n    this.workingData.insertionVertices = this.workingData.insertionVertices.concat(insertionVertices);\n  }\n  \n  /**\n   * Find a vertex at the specified screen position\n   * @param {Array} screenPosition - The screen position [x, y]\n   * @returns {Object|null} The vertex feature or null if none found\n   * @private\n   */\n  _findVertexAtPosition(screenPosition) {\n    if (!this.workingData.targetFeature || this.workingData.vertices.length === 0) {\n      return null;\n    }\n    \n    // Find the closest vertex\n    let closestVertex = null;\n    let closestDistance = Infinity;\n    \n    for (const vertex of this.workingData.vertices) {\n      try {\n        const vertexScreenPos = this.mapInterface.coordinateToPixel(vertex.getCoordinate());\n        \n        // Check if vertexScreenPos is valid (not undefined or null)\n        if (!vertexScreenPos || vertexScreenPos.length < 2) {\n          console.warn('Invalid screen position for vertex:', vertex.id);\n          continue;\n        }\n        \n        const distance = Math.sqrt(\n          Math.pow(vertexScreenPos[0] - screenPosition[0], 2) +\n          Math.pow(vertexScreenPos[1] - screenPosition[1], 2),\n        );\n        \n        if (distance <= this.options.vertexDistanceTolerance && distance < closestDistance) {\n          closestVertex = vertex;\n          closestDistance = distance;\n        }\n      } catch (error) {\n        console.warn('Error calculating vertex screen position:', error);\n      }\n    }\n    \n    return closestVertex;\n  }\n  \n  /**\n   * Find an insertion vertex at the specified screen position\n   * @param {Array} screenPosition - The screen position [x, y]\n   * @returns {Object|null} The insertion vertex or null if none found\n   * @private\n   */\n  _findInsertionVertexAtPosition(screenPosition) {\n    if (!this.workingData.targetFeature || this.workingData.insertionVertices.length === 0) {\n      return null;\n    }\n    \n    // Find the closest insertion vertex\n    let closestVertex = null;\n    let closestDistance = Infinity;\n    \n    for (const vertex of this.workingData.insertionVertices) {\n      try {\n        const vertexScreenPos = this.mapInterface.coordinateToPixel(vertex.getCoordinate());\n        \n        // Check if vertexScreenPos is valid (not undefined or null)\n        if (!vertexScreenPos || vertexScreenPos.length < 2) {\n          console.warn('Invalid screen position for insertion vertex:', vertex.id);\n          continue;\n        }\n        \n        const distance = Math.sqrt(\n          Math.pow(vertexScreenPos[0] - screenPosition[0], 2) +\n          Math.pow(vertexScreenPos[1] - screenPosition[1], 2),\n        );\n        \n        if (distance <= this.options.vertexDistanceTolerance && distance < closestDistance) {\n          closestVertex = vertex;\n          closestDistance = distance;\n        }\n      } catch (error) {\n        console.warn('Error calculating insertion vertex screen position:', error);\n      }\n    }\n    \n    return closestVertex;\n  }\n  \n  /**\n   * Check if a position is on the target feature\n   * @param {Object} coordinate - The world coordinate\n   * @param {Array} screenPosition - The screen position [x, y]\n   * @returns {boolean} Whether the position is on the feature\n   * @private\n   */\n  _isPositionOnFeature(coordinate, screenPosition) {\n    if (!this.workingData.targetFeature) {\n      return false;\n    }\n    \n    // Different hit test based on feature type\n    switch (this.workingData.targetFeature.type) {\n    case 'point':\n      // For points, use the vertex hit test\n      return !!this._findVertexAtPosition(screenPosition);\n        \n    case 'line':\n      // For lines, check if we're close to any segment\n      const lineCoords = this.workingData.targetFeature.getCoordinates();\n        \n      // Need at least two points for a line\n      if (lineCoords.length < 2) {\n        return false;\n      }\n        \n      // Check each segment\n      for (let i = 0; i < lineCoords.length - 1; i++) {\n        const nearestInfo = this.geometryEngine.nearestPointOnSegment(\n          lineCoords[i],\n          lineCoords[i + 1],\n          coordinate,\n        );\n          \n        if (nearestInfo) {\n          try {\n            // Convert nearest point to screen coordinates\n            const nearestScreenPos = this.mapInterface.coordinateToPixel(nearestInfo.point);\n              \n            // Ensure the screen position is valid\n            if (!nearestScreenPos || nearestScreenPos.length < 2) {\n              console.warn('Invalid screen position for nearest point on segment');\n              continue;\n            }\n            \n            // Check distance in screen space\n            const distance = Math.sqrt(\n              Math.pow(nearestScreenPos[0] - screenPosition[0], 2) +\n              Math.pow(nearestScreenPos[1] - screenPosition[1], 2),\n            );\n            \n            if (distance <= this.options.vertexDistanceTolerance) {\n              return true;\n            }\n          } catch (error) {\n            console.warn('Error calculating screen distance for line segment:', error);\n          }\n        }\n      }\n      return false;\n        \n    case 'polygon':\n      // For polygons, check if the point is inside\n      return this.workingData.targetFeature.containsPoint(coordinate);\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Select a feature at the specified position\n   * @param {Object} coordinate - The world coordinate\n   * @param {Array} screenPosition - The screen position [x, y]\n   * @private\n   */\n  _selectFeatureAtPosition(coordinate, screenPosition) {\n    // Find features at this position\n    const features = this.manager.features.getFeaturesAtPosition(coordinate, {\n      tolerance: this.options.vertexDistanceTolerance,\n      screenPosition: screenPosition,\n      mapInterface: this.mapInterface,\n    });\n    \n    // Filter to editable feature types\n    const editableFeatures = features.filter(f => \n      ['point', 'line', 'polygon'].includes(f.type),\n    );\n    \n    if (editableFeatures.length > 0) {\n      // Select the first editable feature\n      this.manager.selectFeature(editableFeatures[0]);\n      this._startEditingFeature(editableFeatures[0]);\n    }\n  }\n  \n  /**\n   * Select a vertex for editing\n   * @param {Object} vertex - The vertex feature to select\n   * @private\n   */\n  _selectVertex(vertex) {\n    // Deselect current vertex if any\n    this._deselectVertex();\n    \n    // Set as selected vertex\n    this.workingData.selectedVertex = vertex;\n    \n    // Update vertex style\n    vertex.setStyle(this.options.selectedVertexSymbol);\n    \n    // Update vertex property\n    vertex.setProperty('isSelected', true);\n    \n    // Emit event\n    this.emit('vertexSelected', {\n      feature: this.workingData.targetFeature,\n      vertexIndex: vertex.getProperty('vertexIndex'),\n    });\n  }\n  \n  /**\n   * Deselect the currently selected vertex\n   * @private\n   */\n  _deselectVertex() {\n    if (!this.workingData.selectedVertex) {\n      return;\n    }\n    \n    // Restore vertex style\n    this.workingData.selectedVertex.setStyle(this.options.vertexSymbol);\n    \n    // Update vertex property\n    this.workingData.selectedVertex.setProperty('isSelected', false);\n    \n    // Emit event\n    this.emit('vertexDeselected', {\n      feature: this.workingData.targetFeature,\n      vertexIndex: this.workingData.selectedVertex.getProperty('vertexIndex'),\n    });\n    \n    // Clear selected vertex\n    this.workingData.selectedVertex = null;\n  }\n  \n  /**\n   * Highlight a vertex on hover\n   * @param {Object} vertex - The vertex to highlight\n   * @private\n   */\n  _highlightVertex(vertex) {\n    // Skip if this is already the selected vertex\n    if (this.workingData.selectedVertex && \n        this.workingData.selectedVertex.id === vertex.id) {\n      return;\n    }\n    \n    // Temporarily adjust style\n    const currentStyle = vertex.getStyle();\n    vertex.setStyle(Object.assign({}, currentStyle, {\n      size: currentStyle.size * 1.2,\n    }));\n    \n    // Reset other vertex styles\n    this.workingData.vertices.forEach(v => {\n      if (v.id !== vertex.id && !v.getProperty('isSelected')) {\n        v.setStyle(this.options.vertexSymbol);\n      }\n    });\n  }\n  \n  /**\n   * Highlight an insertion vertex on hover\n   * @param {Object} vertex - The insertion vertex to highlight\n   * @private\n   */\n  _highlightInsertionVertex(vertex) {\n    // Temporarily adjust style\n    const currentStyle = vertex.getStyle();\n    vertex.setStyle(Object.assign({}, currentStyle, {\n      size: currentStyle.size * 1.5,\n      color: 'rgba(255, 87, 51, 0.5)',\n    }));\n    \n    // Reset other insertion vertex styles\n    this.workingData.insertionVertices.forEach(v => {\n      if (v.id !== vertex.id) {\n        v.setStyle(this.options.insertionVertexSymbol);\n      }\n    });\n  }\n  \n  /**\n   * Add a new vertex at an insertion point\n   * @param {Object} insertionVertex - The insertion vertex\n   * @private\n   */\n  _addVertexAtInsertion(insertionVertex) {\n    if (!this.workingData.targetFeature || !insertionVertex) {\n      return;\n    }\n    \n    const startIndex = insertionVertex.getProperty('startVertex');\n    const endIndex = insertionVertex.getProperty('endVertex');\n    const ringIndex = insertionVertex.getProperty('ringIndex') || 0;\n    const coordinate = insertionVertex.getCoordinate();\n    \n    // Different approach based on feature type\n    switch (this.workingData.targetFeature.type) {\n    case 'line':\n      // For lines, insert between two vertices\n      const lineCoords = this.workingData.targetFeature.getCoordinates();\n        \n      // Insert at proper position\n      lineCoords.splice(endIndex, 0, coordinate);\n        \n      // Update line coordinates\n      this.workingData.targetFeature.setCoordinates(lineCoords);\n      break;\n        \n    case 'polygon':\n      // For polygons, insert in the appropriate ring\n      const rings = this.workingData.targetFeature.getRings();\n        \n      // Make sure ring exists\n      if (ringIndex >= 0 && ringIndex < rings.length) {\n        const ring = rings[ringIndex];\n          \n        // For polygons, the last point is the same as the first,\n        // so we need to handle insertion differently\n        if (endIndex === 0) {\n          // Inserting between last and first point (wrapping around)\n          ring.splice(ring.length - 1, 0, coordinate);\n          // Also update the closing point\n          ring[ring.length - 1] = ring[0];\n        } else {\n          // Normal insertion\n          ring.splice(endIndex, 0, coordinate);\n        }\n          \n        // Update polygon rings\n        this.workingData.targetFeature.setRings(rings);\n      }\n      break;\n    }\n    \n    // Update vertex controls\n    this._updateVertexControls();\n    \n    // Emit event\n    this.emit('vertexAdded', {\n      feature: this.workingData.targetFeature,\n      coordinate: coordinate,\n      beforeIndex: startIndex,\n      afterIndex: endIndex,\n    });\n  }\n  \n  /**\n   * Delete the currently selected vertex\n   * @private\n   */\n  _deleteSelectedVertex() {\n    if (!this.workingData.targetFeature || !this.workingData.selectedVertex) {\n      return;\n    }\n    \n    const vertexIndex = this.workingData.selectedVertex.getProperty('vertexIndex');\n    const ringIndex = this.workingData.selectedVertex.getProperty('ringIndex') || 0;\n    \n    // Different approach based on feature type\n    switch (this.workingData.targetFeature.type) {\n    case 'point':\n      // Can't delete the only vertex of a point\n      console.warn('Cannot delete the vertex of a point feature');\n      return;\n        \n    case 'line':\n      // For lines, remove the vertex\n      const lineCoords = this.workingData.targetFeature.getCoordinates();\n        \n      // Ensure we have enough vertices left\n      if (lineCoords.length <= 2) {\n        console.warn('Cannot delete vertex: Line must have at least 2 vertices');\n        return;\n      }\n        \n      // Remove the vertex\n      lineCoords.splice(vertexIndex, 1);\n        \n      // Update line coordinates\n      this.workingData.targetFeature.setCoordinates(lineCoords);\n      break;\n        \n    case 'polygon':\n      // For polygons, remove from the appropriate ring\n      const rings = this.workingData.targetFeature.getRings();\n        \n      // Make sure ring exists\n      if (ringIndex >= 0 && ringIndex < rings.length) {\n        const ring = rings[ringIndex];\n          \n        // Ensure we have enough vertices left\n        if (ring.length <= 4) { // 3 real vertices + closing point\n          console.warn('Cannot delete vertex: Polygon must have at least 3 vertices');\n          return;\n        }\n          \n        // Get the point index within the ring\n        const pointIndex = this.workingData.selectedVertex.getProperty('pointIndex');\n          \n        // Remove the vertex\n        ring.splice(pointIndex, 1);\n          \n        // If we removed the first point, update the closing point\n        if (pointIndex === 0) {\n          ring[ring.length - 1] = ring[0];\n        }\n          \n        // Update polygon rings\n        this.workingData.targetFeature.setRings(rings);\n      }\n      break;\n    }\n    \n    // Clear selected vertex\n    this.workingData.selectedVertex = null;\n    \n    // Update vertex controls\n    this._updateVertexControls();\n    \n    // Emit event\n    this.emit('vertexDeleted', {\n      feature: this.workingData.targetFeature,\n      vertexIndex: vertexIndex,\n    });\n  }\n  \n  /**\n   * Handle drag operations\n   * @param {Object} coordinate - The current mouse coordinate\n   * @param {Array} screenPosition - The current screen position\n   * @private\n   */\n  _handleDrag(coordinate, screenPosition) {\n    if (!this.workingData.isDragging || !this.workingData.dragStartPosition) {\n      return;\n    }\n    \n    // Calculate drag distance in screen pixels\n    const startScreenPos = this.mapInterface.coordinateToPixel(this.workingData.dragStartPosition);\n    const distance = Math.sqrt(\n      Math.pow(startScreenPos[0] - screenPosition[0], 2) +\n      Math.pow(startScreenPos[1] - screenPosition[1], 2),\n    );\n    \n    // Update tracked distance\n    this.workingData.draggedDistance = distance;\n    \n    // Handle based on operation mode\n    switch (this.workingData.operationMode) {\n    case 'moveVertex':\n      this._moveSelectedVertex(coordinate);\n      break;\n        \n    case 'move':\n      this._moveFeature(coordinate);\n      break;\n    }\n  }\n  \n  /**\n   * Move the selected vertex to a new position\n   * @param {Object} coordinate - The new coordinate\n   * @private\n   */\n  _moveSelectedVertex(coordinate) {\n    if (!this.workingData.targetFeature || !this.workingData.selectedVertex) {\n      return;\n    }\n    \n    const vertexIndex = this.workingData.selectedVertex.getProperty('vertexIndex');\n    const ringIndex = this.workingData.selectedVertex.getProperty('ringIndex') || 0;\n    \n    // Update the vertex control position\n    this.workingData.selectedVertex.setCoordinate(coordinate);\n    \n    // Apply 3D elevation data if enabled\n    if (this.options.enable3D && this.options.snapToTerrain) {\n      this.manager.applyElevationData(this.workingData.selectedVertex);\n      \n      // Get the updated coordinate with elevation\n      coordinate = this.workingData.selectedVertex.getCoordinate();\n    }\n    \n    // Update feature geometry based on type\n    switch (this.workingData.targetFeature.type) {\n    case 'point':\n      // For points, just update the coordinate\n      this.workingData.targetFeature.setCoordinate(coordinate);\n      break;\n        \n    case 'line':\n      // For lines, update the specific vertex\n      const lineCoords = this.workingData.targetFeature.getCoordinates();\n      lineCoords[vertexIndex] = coordinate;\n      this.workingData.targetFeature.setCoordinates(lineCoords);\n      break;\n        \n    case 'polygon':\n      // For polygons, update in the appropriate ring\n      const rings = this.workingData.targetFeature.getRings();\n        \n      // Make sure ring exists\n      if (ringIndex >= 0 && ringIndex < rings.length) {\n        const ring = rings[ringIndex];\n          \n        // Get the point index within the ring\n        const pointIndex = this.workingData.selectedVertex.getProperty('pointIndex');\n          \n        // Update the vertex\n        ring[pointIndex] = coordinate;\n          \n        // If we updated the first point, also update the closing point\n        if (pointIndex === 0) {\n          ring[ring.length - 1] = coordinate;\n        }\n          \n        // Update polygon rings\n        this.workingData.targetFeature.setRings(rings);\n      }\n      break;\n    }\n    \n    // Update insertion vertices\n    this._updateVertexControls();\n    \n    // Emit event\n    this.emit('vertexMoved', {\n      feature: this.workingData.targetFeature,\n      vertexIndex: vertexIndex,\n      coordinate: coordinate,\n    });\n  }\n  \n  /**\n   * Move the entire feature to a new position\n   * Handles both lat/lng and x/y coordinate formats for compatibility\n   * @param {Object} coordinate - The new coordinate\n   * @returns {void}\n   * @private\n   */\n  _moveFeature(coordinate) {\n    if (!this.workingData.targetFeature || !this.workingData.dragStartPosition) {\n      return;\n    }\n    \n    // Handle different coordinate formats and calculate offset\n    const startLat = this.workingData.dragStartPosition.lat !== undefined ? this.workingData.dragStartPosition.lat : this.workingData.dragStartPosition.y;\n    const startLng = this.workingData.dragStartPosition.lng !== undefined ? this.workingData.dragStartPosition.lng : this.workingData.dragStartPosition.x;\n    const startElevation = this.workingData.dragStartPosition.elevation !== undefined ? this.workingData.dragStartPosition.elevation : \n      (this.workingData.dragStartPosition.z !== undefined ? this.workingData.dragStartPosition.z : 0);\n    \n    const currentLat = coordinate.lat !== undefined ? coordinate.lat : coordinate.y;\n    const currentLng = coordinate.lng !== undefined ? coordinate.lng : coordinate.x;\n    const currentElevation = coordinate.elevation !== undefined ? coordinate.elevation : \n      (coordinate.z !== undefined ? coordinate.z : 0);\n    \n    // Calculate offset using standard lat/lng/elevation properties\n    const offset = {\n      lat: currentLat - startLat,\n      lng: currentLng - startLng,\n      elevation: this.options.enable3D ? currentElevation - startElevation : 0,\n    };\n    \n    // Move the feature based on type\n    switch (this.workingData.targetFeature.type) {\n    case 'point':\n      // For points, just update the coordinate\n      const pointCoord = this.workingData.targetFeature.getCoordinate();\n      const pointLat = pointCoord.lat !== undefined ? pointCoord.lat : pointCoord.y;\n      const pointLng = pointCoord.lng !== undefined ? pointCoord.lng : pointCoord.x;\n      const pointElevation = pointCoord.elevation !== undefined ? pointCoord.elevation : \n        (pointCoord.z !== undefined ? pointCoord.z : 0);\n        \n      const newCoord = {\n        lat: pointLat + offset.lat,\n        lng: pointLng + offset.lng,\n        elevation: pointElevation + offset.elevation,\n      };\n      this.workingData.targetFeature.setCoordinate(newCoord);\n      break;\n        \n    case 'line':\n      // For lines, offset all vertices\n      const lineCoords = this.workingData.targetFeature.getCoordinates();\n      const newLineCoords = lineCoords.map(coord => {\n        const lat = coord.lat !== undefined ? coord.lat : coord.y;\n        const lng = coord.lng !== undefined ? coord.lng : coord.x;\n        const elevation = coord.elevation !== undefined ? coord.elevation : \n          (coord.z !== undefined ? coord.z : 0);\n          \n        return {\n          lat: lat + offset.lat,\n          lng: lng + offset.lng,\n          elevation: elevation + offset.elevation,\n        };\n      });\n      this.workingData.targetFeature.setCoordinates(newLineCoords);\n      break;\n        \n    case 'polygon':\n      // For polygons, offset all rings\n      const rings = this.workingData.targetFeature.getRings();\n      const newRings = rings.map(ring => \n        ring.map(coord => {\n          const lat = coord.lat !== undefined ? coord.lat : coord.y;\n          const lng = coord.lng !== undefined ? coord.lng : coord.x;\n          const elevation = coord.elevation !== undefined ? coord.elevation : \n            (coord.z !== undefined ? coord.z : 0);\n            \n          return {\n            lat: lat + offset.lat,\n            lng: lng + offset.lng,\n            elevation: elevation + offset.elevation,\n          };\n        }),\n      );\n      this.workingData.targetFeature.setRings(newRings);\n      break;\n    }\n    \n    // Update start position for continuous movement\n    this.workingData.dragStartPosition = coordinate;\n    \n    // Update vertex controls\n    this._updateVertexControls();\n    \n    // Emit event\n    this.emit('featureMoved', {\n      feature: this.workingData.targetFeature,\n      offset: offset,\n    });\n  }\n  \n  /**\n   * Cancel the current drag operation\n   * @private\n   */\n  _cancelDrag() {\n    if (!this.workingData.isDragging) {\n      return;\n    }\n    \n    // Reset drag state\n    this.workingData.isDragging = false;\n    this.workingData.dragStartPosition = null;\n    \n    // Reset feature to original state (before drag started)\n    if (this.workingData.originalFeature && this.workingData.targetFeature) {\n      this.workingData.targetFeature.fromGeoJSON(this.workingData.originalFeature.data);\n    }\n    \n    // Update vertex controls\n    this._updateVertexControls();\n    \n    // Emit event\n    this.emit('dragCancelled', {\n      feature: this.workingData.targetFeature,\n    });\n    \n    // Reset operation mode\n    this.workingData.operationMode = 'none';\n  }\n  \n  /**\n   * Complete the editing operation\n   * @private\n   */\n  _completeEditing() {\n    if (!this.workingData.targetFeature) {\n      return;\n    }\n    \n    // Ensure we're not in a drag operation\n    if (this.workingData.isDragging) {\n      this.workingData.isDragging = false;\n      this.workingData.dragStartPosition = null;\n    }\n    \n    // Update feature with final changes\n    this.manager.features.updateFeature(this.workingData.targetFeature);\n    \n    // Restore original style\n    this._restoreOriginalStyle();\n    \n    // Get feature for event\n    const feature = this.workingData.targetFeature;\n    \n    // Mark operation as complete\n    this.workingData.operationComplete = true;\n    \n    // Clear vertex controls and selection\n    this._clearVertexControls();\n    \n    // Clear target feature\n    this.workingData.targetFeature = null;\n    this.workingData.originalFeature = null;\n    this.workingData.selectedVertex = null;\n    this.workingData.operationMode = 'none';\n    \n    // Emit event\n    this.emit('editingCompleted', {\n      feature: feature,\n    });\n  }\n  \n  /**\n   * Cancel the editing operation\n   * @private\n   */\n  _cancelEditing() {\n    if (!this.workingData.targetFeature || !this.workingData.originalFeature) {\n      return;\n    }\n    \n    // Restore feature to original state\n    this.workingData.targetFeature.fromGeoJSON(this.workingData.originalFeature.data);\n    \n    // Restore original style\n    this._restoreOriginalStyle();\n    \n    // Get feature for event\n    const feature = this.workingData.targetFeature;\n    \n    // Clear vertex controls and selection\n    this._clearVertexControls();\n    \n    // Clear target feature\n    this.workingData.targetFeature = null;\n    this.workingData.originalFeature = null;\n    this.workingData.selectedVertex = null;\n    this.workingData.operationMode = 'none';\n    \n    // Emit event\n    this.emit('editingCancelled', {\n      feature: feature,\n    });\n  }\n  \n  /**\n   * Set 3D editing mode\n   * @param {boolean} enable - Whether to enable 3D editing\n   * @returns {boolean} New state of 3D editing mode\n   */\n  setEnable3D(enable) {\n    this.options.enable3D = !!enable;\n    \n    // Update vertex controls if active\n    if (this.workingData.targetFeature) {\n      this._updateVertexControls();\n    }\n    \n    // Emit event\n    this.emit('enable3DChanged', {\n      enable3D: this.options.enable3D,\n    });\n    \n    return this.options.enable3D;\n  }\n  \n  /**\n   * Set vertex addition capability\n   * @param {boolean} allow - Whether to allow adding vertices\n   * @returns {boolean} New state of vertex addition capability\n   */\n  setAllowVertexAddition(allow) {\n    this.options.allowVertexAddition = !!allow;\n    \n    // Update vertex controls if active\n    if (this.workingData.targetFeature) {\n      this._updateVertexControls();\n    }\n    \n    // Emit event\n    this.emit('allowVertexAdditionChanged', {\n      allowVertexAddition: this.options.allowVertexAddition,\n    });\n    \n    return this.options.allowVertexAddition;\n  }\n  \n  /**\n   * Set vertex deletion capability\n   * @param {boolean} allow - Whether to allow deleting vertices\n   * @returns {boolean} New state of vertex deletion capability\n   */\n  setAllowVertexDeletion(allow) {\n    this.options.allowVertexDeletion = !!allow;\n    \n    // Emit event\n    this.emit('allowVertexDeletionChanged', {\n      allowVertexDeletion: this.options.allowVertexDeletion,\n    });\n    \n    return this.options.allowVertexDeletion;\n  }\n  \n  /**\n   * Set snap to terrain capability\n   * @param {boolean} enable - Whether to enable snap to terrain\n   * @returns {boolean} New state of snap to terrain capability\n   */\n  setSnapToTerrain(enable) {\n    this.options.snapToTerrain = !!enable;\n    \n    // Emit event\n    this.emit('snapToTerrainChanged', {\n      snapToTerrain: this.options.snapToTerrain,\n    });\n    \n    return this.options.snapToTerrain;\n  }\n  \n  /**\n   * Get the current editing settings\n   * @returns {Object} Current editing settings\n   */\n  getSettings() {\n    return {\n      enable3D: this.options.enable3D,\n      allowVertexAddition: this.options.allowVertexAddition,\n      allowVertexDeletion: this.options.allowVertexDeletion,\n      snapToTerrain: this.options.snapToTerrain,\n      vertexDistanceTolerance: this.options.vertexDistanceTolerance,\n    };\n  }\n}","/**\n * SnappingManager.js\n * Manager for snapping functionality between features\n * Part of the RTK Surveyor 3D-first implementation\n */\n\nimport { EventEmitter } from '../core/event-emitter.js';\nimport { PointFeature } from '../features/PointFeature.js';\n\n/**\n * @typedef {Object} SnappingManagerOptions\n * @property {Object} manager - The survey manager instance\n * @property {Object} mapInterface - The map interface instance\n * @property {number} [tolerance=10] - Snap tolerance in pixels\n * @property {boolean} [enable3D=true] - Whether to enable 3D snapping\n * @property {boolean} [snapToVertex=true] - Whether to snap to vertices\n * @property {boolean} [snapToEdge=true] - Whether to snap to edges\n * @property {boolean} [snapToGrid=false] - Whether to snap to grid\n * @property {number} [gridSize=10] - Grid size in meters\n * @property {Object} [vertexSnapSymbol] - Symbol for vertex snap indicators\n * @property {Object} [edgeSnapSymbol] - Symbol for edge snap indicators\n * @property {Object} [gridSnapSymbol] - Symbol for grid snap indicators\n */\n\n/**\n * Manager for snapping functionality between features\n * Provides advanced snapping capabilities for survey tools\n */\nexport class SnappingManager extends EventEmitter {\n  /**\n   * Create a new SnappingManager instance\n   * @param {SnappingManagerOptions} options - Configuration options\n   */\n  constructor(options = {}) {\n    super();\n    \n    if (!options.manager) {\n      throw new Error('Manager instance is required for snapping manager initialization');\n    }\n    \n    if (!options.mapInterface) {\n      throw new Error('Map interface is required for snapping manager initialization');\n    }\n    \n    // Store references\n    this.manager = options.manager;\n    this.mapInterface = options.mapInterface;\n    this.geometryEngine = options.geometryEngine || this.manager.geometryEngine;\n    \n    // Initialize options with defaults\n    this.options = Object.assign({\n      tolerance: 10, // pixels\n      enable3D: true,\n      snapToVertex: true,\n      snapToEdge: true,\n      snapToGrid: false,\n      gridSize: 10, // meters\n      highlightSnap: true,\n      includeTemporaryFeatures: true,\n      vertexSnapSymbol: {\n        type: 'circle',\n        size: 12,\n        color: 'rgba(255, 87, 51, 0.6)',\n        outlineWidth: 2,\n        outlineColor: '#FF5733',\n      },\n      edgeSnapSymbol: {\n        type: 'circle',\n        size: 10,\n        color: 'rgba(51, 136, 255, 0.6)',\n        outlineWidth: 1,\n        outlineColor: '#3388FF',\n      },\n      gridSnapSymbol: {\n        type: 'circle',\n        size: 8,\n        color: 'rgba(0, 200, 0, 0.5)',\n        outlineWidth: 1,\n        outlineColor: '#00C800',\n      },\n    }, options);\n    \n    // Initialize state\n    this.state = {\n      isActive: false,\n      currentSnap: null,\n      snapIndicator: null,\n      snapSourceFeature: null,\n      snapTargets: [],\n      lastMousePosition: null,\n    };\n    \n    // Bind event handlers\n    this._handleMapMouseMove = this._handleMapMouseMove.bind(this);\n  }\n  \n  /**\n   * Activate the snapping manager\n   * @param {Object} [options] - Activation options\n   */\n  activate(options = {}) {\n    if (this.state.isActive) {\n      return;\n    }\n    \n    // Update options if provided\n    if (options) {\n      this.options = Object.assign(this.options, options);\n    }\n    \n    // Add map event listeners\n    this.mapInterface.addEventListener('mousemove', this._handleMapMouseMove);\n    \n    // Mark as active\n    this.state.isActive = true;\n    \n    // Emit activation event\n    this.emit('activated', this.options);\n  }\n  \n  /**\n   * Deactivate the snapping manager\n   */\n  deactivate() {\n    if (!this.state.isActive) {\n      return;\n    }\n    \n    // Remove map event listeners\n    this.mapInterface.removeEventListener('mousemove', this._handleMapMouseMove);\n    \n    // Clear any active snap\n    this._clearSnap();\n    \n    // Mark as inactive\n    this.state.isActive = false;\n    \n    // Emit deactivation event\n    this.emit('deactivated');\n  }\n  \n  /**\n   * Set snap targets to constrain snapping to specific features\n   * @param {Array|Object} targets - Feature or array of features to snap to\n   */\n  setSnapTargets(targets) {\n    // Convert single feature to array\n    const targetArray = Array.isArray(targets) ? targets : [targets];\n    \n    // Store targets\n    this.state.snapTargets = targetArray;\n    \n    // Emit event\n    this.emit('snapTargetsChanged', targetArray);\n  }\n  \n  /**\n   * Clear snap targets to allow snapping to any feature\n   */\n  clearSnapTargets() {\n    this.state.snapTargets = [];\n    \n    // Emit event\n    this.emit('snapTargetsCleared');\n  }\n  \n  /**\n   * Set the snap source feature to avoid self-snapping\n   * @param {Object} feature - The feature to exclude from snap sources\n   */\n  setSnapSourceFeature(feature) {\n    this.state.snapSourceFeature = feature;\n  }\n  \n  /**\n   * Handle map mouse move events\n   * @param {Object} event - The map mousemove event\n   * @private\n   */\n  _handleMapMouseMove(event) {\n    // Make sure we have valid coordinate and pixel data\n    if (!event.coordinate || !event.pixel) {\n      return;\n    }\n    \n    // Store current mouse position\n    this.state.lastMousePosition = {\n      coordinate: event.coordinate,\n      pixel: event.pixel,\n    };\n    \n    // Find snap point\n    const snap = this._findSnapPoint(event.coordinate, event.pixel);\n    \n    // Clear current snap if none found\n    if (!snap) {\n      this._clearSnap();\n      return;\n    }\n    \n    // Update current snap\n    this._updateSnap(snap);\n  }\n  \n  /**\n   * Find a snap point based on current snap settings\n   * @param {Object} coordinate - The world coordinate\n   * @param {Array} pixel - The screen pixel position\n   * @returns {Object|null} Snap information or null if no snap found\n   * @private\n   */\n  _findSnapPoint(coordinate, pixel) {\n    // Skip if not active\n    if (!this.state.isActive) {\n      return null;\n    }\n    \n    // Try snapping in priority order\n    let snap = null;\n    \n    // 1. Try vertex snapping\n    if (this.options.snapToVertex) {\n      snap = this._findVertexSnap(coordinate, pixel);\n      if (snap) return snap;\n    }\n    \n    // 2. Try edge snapping\n    if (this.options.snapToEdge) {\n      snap = this._findEdgeSnap(coordinate, pixel);\n      if (snap) return snap;\n    }\n    \n    // 3. Try grid snapping\n    if (this.options.snapToGrid) {\n      snap = this._findGridSnap(coordinate);\n      if (snap) return snap;\n    }\n    \n    return null;\n  }\n  \n  /**\n   * Find vertex snap point\n   * @param {Object} coordinate - The world coordinate\n   * @param {Array} pixel - The screen pixel position\n   * @returns {Object|null} Vertex snap information or null\n   * @private\n   */\n  _findVertexSnap(coordinate, pixel) {\n    const features = this._getSnapFeatures();\n    let bestDistance = Infinity;\n    let bestSnap = null;\n    \n    // Check each feature for vertices\n    for (const feature of features) {\n      // Skip source feature to avoid self-snapping\n      if (this.state.snapSourceFeature && \n          feature.id === this.state.snapSourceFeature.id) {\n        continue;\n      }\n      \n      // Get vertices based on feature type\n      let vertices = [];\n      \n      switch (feature.type) {\n      case 'point':\n        vertices = [feature.getCoordinate()];\n        break;\n          \n      case 'line':\n        vertices = feature.getCoordinates();\n        break;\n          \n      case 'polygon':\n        // Get all vertices from all rings\n        const rings = feature.getRings();\n        rings.forEach(ring => {\n          vertices = vertices.concat(ring);\n        });\n        break;\n          \n      default:\n        continue; // Skip unsupported types\n      }\n      \n      // Check each vertex\n      for (const vertex of vertices) {\n        // Convert vertex to screen coordinates\n        const vertexPixel = this.mapInterface.coordinateToPixel(vertex);\n        \n        // Make sure we have valid pixel coordinates\n        if (!vertexPixel || !Array.isArray(vertexPixel) || vertexPixel.length < 2 || \n            !pixel || !Array.isArray(pixel) || pixel.length < 2) {\n          continue; // Skip this vertex if we don't have valid coordinates\n        }\n        \n        // Calculate screen distance\n        const distance = Math.sqrt(\n          Math.pow(vertexPixel[0] - pixel[0], 2) +\n          Math.pow(vertexPixel[1] - pixel[1], 2),\n        );\n        \n        // Check if within tolerance and closer than current best\n        if (distance <= this.options.tolerance && distance < bestDistance) {\n          bestDistance = distance;\n          bestSnap = {\n            type: 'vertex',\n            feature: feature,\n            coordinate: vertex,\n            distance: distance,\n            isSnapped: true,\n          };\n        }\n      }\n    }\n    \n    return bestSnap;\n  }\n  \n  /**\n   * Find edge snap point\n   * @param {Object} coordinate - The world coordinate\n   * @param {Array} pixel - The screen pixel position\n   * @returns {Object|null} Edge snap information or null\n   * @private\n   */\n  _findEdgeSnap(coordinate, pixel) {\n    const features = this._getSnapFeatures();\n    let bestDistance = Infinity;\n    let bestSnap = null;\n    \n    // Check each feature for edges\n    for (const feature of features) {\n      // Skip source feature to avoid self-snapping\n      if (this.state.snapSourceFeature && \n          feature.id === this.state.snapSourceFeature.id) {\n        continue;\n      }\n      \n      // Skip point features (no edges)\n      if (feature.type === 'point') {\n        continue;\n      }\n      \n      // Get segments based on feature type\n      const segments = [];\n      \n      switch (feature.type) {\n      case 'line':\n        const coords = feature.getCoordinates();\n          \n        // Create segments from adjacent coordinates\n        for (let i = 0; i < coords.length - 1; i++) {\n          segments.push({\n            start: coords[i],\n            end: coords[i + 1],\n            feature: feature,\n          });\n        }\n        break;\n          \n      case 'polygon':\n        // Get segments from all rings\n        const rings = feature.getRings();\n        rings.forEach(ring => {\n          for (let i = 0; i < ring.length - 1; i++) {\n            segments.push({\n              start: ring[i],\n              end: ring[i + 1],\n              feature: feature,\n            });\n          }\n        });\n        break;\n          \n      default:\n        continue; // Skip unsupported types\n      }\n      \n      // Check each segment\n      for (const segment of segments) {\n        // Find nearest point on segment\n        const nearestInfo = this.geometryEngine.nearestPointOnSegment(\n          segment.start,\n          segment.end,\n          coordinate,\n        );\n        \n        if (nearestInfo) {\n          // Convert nearest point to screen coordinates\n          const nearestPixel = this.mapInterface.coordinateToPixel(nearestInfo.point);\n          \n          // Calculate screen distance\n          const distance = Math.sqrt(\n            Math.pow(nearestPixel[0] - pixel[0], 2) +\n            Math.pow(nearestPixel[1] - pixel[1], 2),\n          );\n          \n          // Check if within tolerance and closer than current best\n          if (distance <= this.options.tolerance && distance < bestDistance) {\n            bestDistance = distance;\n            bestSnap = {\n              type: 'edge',\n              feature: segment.feature,\n              coordinate: nearestInfo.point,\n              segmentStart: segment.start,\n              segmentEnd: segment.end,\n              segmentPosition: nearestInfo.segmentPosition,\n              distance: distance,\n              isSnapped: true,\n            };\n          }\n        }\n      }\n    }\n    \n    return bestSnap;\n  }\n  \n  /**\n   * Find grid snap point\n   * @param {Object} coordinate - The world coordinate\n   * @returns {Object|null} Grid snap information or null\n   * @private\n   */\n  _findGridSnap(coordinate) {\n    // Skip if grid snapping is disabled\n    if (!this.options.snapToGrid) {\n      return null;\n    }\n    \n    // Calculate grid cell\n    const gridSize = this.options.gridSize;\n    \n    // Handle different coordinate formats\n    // Check if coordinate uses x,y,z or lat,lng,elevation\n    const lat = coordinate.lat !== undefined ? coordinate.lat : coordinate.y;\n    const lng = coordinate.lng !== undefined ? coordinate.lng : coordinate.x;\n    const elevation = coordinate.elevation !== undefined ? coordinate.elevation : \n      (coordinate.z !== undefined ? coordinate.z : 0);\n    \n    if (lat === undefined || lng === undefined) {\n      console.error('Invalid coordinate format for grid snapping:', coordinate);\n      return null;\n    }\n    \n    // Convert grid size from meters to degrees (simplified approximation)\n    // This is a rough conversion factor that will vary by location\n    const metersToDegreesLat = 1 / 111000; // Approximate conversion at equator\n    const metersToDegreesLng = 1 / (111000 * Math.cos(lat * Math.PI / 180));\n    \n    const gridSizeLat = gridSize * metersToDegreesLat;\n    const gridSizeLng = gridSize * metersToDegreesLng;\n    \n    // Round to nearest grid point\n    const snappedLat = Math.round(lat / gridSizeLat) * gridSizeLat;\n    const snappedLng = Math.round(lng / gridSizeLng) * gridSizeLng;\n    \n    // Create snapped coordinate (standard lat/lng/elevation format)\n    const snappedCoordinate = {\n      lat: snappedLat,\n      lng: snappedLng,\n      elevation: elevation,\n    };\n    \n    // Return snap info\n    return {\n      type: 'grid',\n      coordinate: snappedCoordinate,\n      gridSize: gridSize,\n      isSnapped: true,\n    };\n  }\n  \n  /**\n   * Get all features that can be snapped to\n   * @returns {Array} Array of features\n   * @private\n   */\n  _getSnapFeatures() {\n    // If specific snap targets are set, use those\n    if (this.state.snapTargets.length > 0) {\n      return this.state.snapTargets;\n    }\n    \n    // Otherwise get all features from the manager\n    const features = this.manager.features.getAllFeatures();\n    \n    // Include temporary features if configured\n    if (this.options.includeTemporaryFeatures) {\n      const workingFeatures = this.manager.workingFeatures.getAllFeatures();\n      \n      // Filter out snap indicators and temporary controls\n      const validWorkingFeatures = workingFeatures.filter(f => {\n        const type = f.getProperty('type');\n        return !(type === 'vertex' || \n                type === 'insertionVertex' || \n                type === 'snap-indicator');\n      });\n      \n      return features.concat(validWorkingFeatures);\n    }\n    \n    return features;\n  }\n  \n  /**\n   * Update the current snap\n   * @param {Object} snap - Snap information\n   * @private\n   */\n  _updateSnap(snap) {\n    // Clear current snap\n    this._clearSnap();\n    \n    // Store new snap\n    this.state.currentSnap = snap;\n    \n    // Create snap indicator if highlighting is enabled\n    if (this.options.highlightSnap) {\n      this._createSnapIndicator(snap);\n    }\n    \n    // Emit snap event\n    this.emit('snap', snap);\n  }\n  \n  /**\n   * Clear current snap\n   * @private\n   */\n  _clearSnap() {\n    // Remove snap indicator if exists\n    if (this.state.snapIndicator) {\n      this.manager.workingFeatures.removeFeature(this.state.snapIndicator);\n      this.state.snapIndicator = null;\n    }\n    \n    // Clear current snap\n    if (this.state.currentSnap) {\n      const wasSnapped = this.state.currentSnap.isSnapped;\n      this.state.currentSnap = null;\n      \n      // Emit unsnap event if we were snapped\n      if (wasSnapped) {\n        this.emit('unsnap');\n      }\n    }\n  }\n  \n  /**\n   * Create visual indicator for the snap point\n   * @param {Object} snap - Snap information\n   * @private\n   */\n  _createSnapIndicator(snap) {\n    // Determine symbol based on snap type\n    let symbol;\n    \n    switch (snap.type) {\n    case 'vertex':\n      symbol = this.options.vertexSnapSymbol;\n      break;\n        \n    case 'edge':\n      symbol = this.options.edgeSnapSymbol;\n      break;\n        \n    case 'grid':\n      symbol = this.options.gridSnapSymbol;\n      break;\n        \n    default:\n      symbol = this.options.vertexSnapSymbol;\n    }\n    \n    // Create indicator feature\n    const indicator = new PointFeature(snap.coordinate, {\n      id: `snap-indicator-${Date.now()}`,\n      properties: {\n        type: 'snap-indicator',\n        snapType: snap.type,\n        temporary: true,\n      },\n      style: symbol,\n    });\n    \n    // Add to working features\n    this.manager.workingFeatures.addFeature(indicator);\n    \n    // Store reference\n    this.state.snapIndicator = indicator;\n  }\n  \n  /**\n   * Get the current snap point if any\n   * @returns {Object|null} Current snap or null\n   */\n  getSnapPoint() {\n    return this.state.currentSnap;\n  }\n  \n  /**\n   * Force snap point calculation at a specific coordinate\n   * @param {Object} coordinate - The coordinate to snap from\n   * @param {Array} [pixel] - Optional screen position for pixel-based calculations\n   * @returns {Object|null} Snap result or null\n   */\n  snapPointAt(coordinate, pixel) {\n    // If pixel not provided, convert coordinate to pixel\n    if (!pixel && this.mapInterface) {\n      pixel = this.mapInterface.coordinateToPixel(coordinate);\n    }\n    \n    // Find snap\n    return this._findSnapPoint(coordinate, pixel);\n  }\n  \n  /**\n   * Enable or disable vertex snapping\n   * @param {boolean} enable - Whether to enable vertex snapping\n   * @returns {boolean} New state\n   */\n  setSnapToVertex(enable) {\n    this.options.snapToVertex = !!enable;\n    \n    // Emit event\n    this.emit('snapSettingsChanged', {\n      snapToVertex: this.options.snapToVertex,\n    });\n    \n    return this.options.snapToVertex;\n  }\n  \n  /**\n   * Enable or disable edge snapping\n   * @param {boolean} enable - Whether to enable edge snapping\n   * @returns {boolean} New state\n   */\n  setSnapToEdge(enable) {\n    this.options.snapToEdge = !!enable;\n    \n    // Emit event\n    this.emit('snapSettingsChanged', {\n      snapToEdge: this.options.snapToEdge,\n    });\n    \n    return this.options.snapToEdge;\n  }\n  \n  /**\n   * Enable or disable grid snapping\n   * @param {boolean} enable - Whether to enable grid snapping\n   * @returns {boolean} New state\n   */\n  setSnapToGrid(enable) {\n    this.options.snapToGrid = !!enable;\n    \n    // Emit event\n    this.emit('snapSettingsChanged', {\n      snapToGrid: this.options.snapToGrid,\n    });\n    \n    return this.options.snapToGrid;\n  }\n  \n  /**\n   * Set grid size for grid snapping\n   * @param {number} size - Grid size in meters\n   * @returns {number} New grid size\n   */\n  setGridSize(size) {\n    if (isNaN(size) || size <= 0) {\n      console.error('Invalid grid size. Must be a positive number.');\n      return this.options.gridSize;\n    }\n    \n    this.options.gridSize = size;\n    \n    // Emit event\n    this.emit('snapSettingsChanged', {\n      gridSize: this.options.gridSize,\n    });\n    \n    return this.options.gridSize;\n  }\n  \n  /**\n   * Set snap tolerance\n   * @param {number} tolerance - Snap tolerance in pixels\n   * @returns {number} New tolerance\n   */\n  setTolerance(tolerance) {\n    if (isNaN(tolerance) || tolerance <= 0) {\n      console.error('Invalid tolerance. Must be a positive number.');\n      return this.options.tolerance;\n    }\n    \n    this.options.tolerance = tolerance;\n    \n    // Emit event\n    this.emit('snapSettingsChanged', {\n      tolerance: this.options.tolerance,\n    });\n    \n    return this.options.tolerance;\n  }\n  \n  /**\n   * Get current snapping settings\n   * @returns {Object} Current settings\n   */\n  getSettings() {\n    return {\n      isActive: this.state.isActive,\n      tolerance: this.options.tolerance,\n      enable3D: this.options.enable3D,\n      snapToVertex: this.options.snapToVertex,\n      snapToEdge: this.options.snapToEdge,\n      snapToGrid: this.options.snapToGrid,\n      gridSize: this.options.gridSize,\n      highlightSnap: this.options.highlightSnap,\n      includeTemporaryFeatures: this.options.includeTemporaryFeatures,\n    };\n  }\n  \n  /**\n   * Destroy the snapping manager and clean up resources\n   */\n  destroy() {\n    // Deactivate if active\n    if (this.state.isActive) {\n      this.deactivate();\n    }\n    \n    // Clear snap targets\n    this.state.snapTargets = [];\n    \n    // Remove all event listeners\n    this.removeAllListeners();\n  }\n}","/**\n * SurveyManager.js\n * Central manager for all survey operations and tools\n * Part of the RTK Surveyor 3D-first implementation\n */\n\nimport { EventEmitter } from '../core/event-emitter.js';\nimport { FeatureCollection } from '../features/FeatureCollection.js';\nimport { GeometryEngine } from '../core/GeometryEngine.js';\n\n// Import all survey tools\nimport { MeasurementTool } from './MeasurementTool.js';\nimport { OffsetTool } from './OffsetTool.js';\nimport { DrawingTool } from './DrawingTool.js';\nimport { EditingTool } from './EditingTool.js';\nimport { SnappingManager } from './SnappingManager.js';\n\n/**\n * @typedef {Object} SurveyManagerOptions\n * @property {Object} mapInterface - The map interface instance\n * @property {Object} [settings] - Optional settings for the survey manager\n * @property {boolean} [settings.enable3D=true] - Whether to enable 3D support\n * @property {boolean} [settings.autoSave=false] - Whether to auto-save survey data\n * @property {number} [settings.undoLevels=20] - Number of undo levels to maintain\n * @property {string} [settings.elevationProvider='mapInterface'] - Elevation data source\n */\n\n/**\n * SurveyManager class\n * Responsible for managing all survey operations, tools, and data\n */\nexport class SurveyManager extends EventEmitter {\n  /**\n   * Create a new SurveyManager instance\n   * @param {SurveyManagerOptions} options - Configuration options\n   */\n  constructor(options = {}) {\n    super();\n    \n    // Store references and initialize properties\n    this.mapInterface = options.mapInterface;\n    this.settings = Object.assign({\n      enable3D: true,\n      autoSave: false,\n      undoLevels: 20,\n      elevationProvider: 'mapInterface',\n      snapTolerance: 10, // pixels\n      defaultPointSymbol: {\n        type: 'circle',\n        size: 10,\n        color: '#FF5733',\n      },\n      defaultLineSymbol: {\n        width: 3,\n        color: '#3388FF',\n      },\n      defaultPolygonSymbol: {\n        fillColor: 'rgba(51, 136, 255, 0.2)',\n        outlineColor: '#3388FF',\n        outlineWidth: 2,\n      },\n    }, options.settings || {});\n    \n    // Initialize feature collections\n    this.features = new FeatureCollection();\n    this.workingFeatures = new FeatureCollection(); // Temporary/working features\n    this.selectedFeatures = new FeatureCollection();\n    \n    // Initialize geometry engine\n    this.geometryEngine = new GeometryEngine();\n    \n    // Create operation history stack for undo/redo\n    this.history = {\n      undoStack: [],\n      redoStack: [],\n      maxSize: this.settings.undoLevels,\n    };\n    \n    // Initialize state trackers\n    this.activeTool = null;\n    this.activeMode = 'select';\n    this.isDrawing = false;\n    this.isEditing = false;\n    this.isMeasuring = false;\n    \n    // Initialize survey metadata\n    this.metadata = {\n      projectName: '',\n      created: new Date(),\n      modified: new Date(),\n      owner: '',\n      description: '',\n      projection: 'EPSG:4326',\n      units: {\n        distance: 'meters',\n        area: 'square-meters',\n        angle: 'degrees',\n      },\n      customProperties: {},\n    };\n    \n    // Initialize internal callback bindings\n    this._setupEventListeners();\n    \n    // Initialize tools\n    this._initializeTools();\n  }\n  \n  /**\n   * Initialize all survey tools\n   * @private\n   */\n  _initializeTools() {\n    // Initialize all tools\n    this.tools = {\n      measurement: new MeasurementTool({ \n        manager: this,\n        mapInterface: this.mapInterface,\n      }),\n      offset: new OffsetTool({\n        manager: this,\n        mapInterface: this.mapInterface,\n        geometryEngine: this.geometryEngine,\n      }),\n      drawing: new DrawingTool({\n        manager: this,\n        mapInterface: this.mapInterface,\n      }),\n      editing: new EditingTool({\n        manager: this,\n        mapInterface: this.mapInterface,\n      }),\n    };\n    \n    // Initialize the snapping manager\n    this.snappingManager = new SnappingManager({\n      manager: this,\n      tolerance: this.settings.snapTolerance,\n      mapInterface: this.mapInterface,\n      geometryEngine: this.geometryEngine,\n    });\n    \n    // Activate snapping by default\n    this.snappingManager.activate();\n    \n    // Emit event for tools initialized\n    this.emit('tools-initialized', {\n      tools: Object.keys(this.tools),\n      snappingActive: true,\n    });\n  }\n  \n  /**\n   * Set up internal event listeners\n   * @private\n   */\n  _setupEventListeners() {\n    // Listen for changes to feature collections\n    this.features.on('feature-added', ({ feature }) => {\n      this._recordHistoryAction({\n        type: 'feature-added',\n        featureId: feature.id,\n        featureData: feature.toGeoJSON(),\n      });\n      this.emit('feature-added', { feature });\n      this.metadata.modified = new Date();\n    });\n    \n    this.features.on('feature-removed', ({ feature }) => {\n      this._recordHistoryAction({\n        type: 'feature-removed',\n        featureId: feature.id,\n        featureData: feature.toGeoJSON(),\n      });\n      this.emit('feature-removed', { feature });\n      this.metadata.modified = new Date();\n    });\n    \n    this.features.on('feature-updated', ({ feature }) => {\n      this._recordHistoryAction({\n        type: 'feature-updated',\n        featureId: feature.id,\n        featureData: feature.toGeoJSON(),\n        previousData: this._lastFeatureState[feature.id],\n      });\n      this.emit('feature-updated', { feature });\n      this.metadata.modified = new Date();\n    });\n    \n    // Track feature state for history\n    this._lastFeatureState = {};\n    this.features.on('feature-geometry-changed', ({ feature }) => {\n      this._lastFeatureState[feature.id] = feature.toGeoJSON();\n    });\n  }\n  \n  /**\n   * Activate a specific survey tool\n   * @param {string} toolName - The name of the tool to activate\n   * @param {Object} [options] - Optional settings for tool activation\n   * @returns {boolean} Success of tool activation\n   */\n  activateTool(toolName, options = {}) {\n    // Deactivate current tool if one is active\n    if (this.activeTool) {\n      this.tools[this.activeTool].deactivate();\n    }\n    \n    // Check if requested tool exists\n    if (!this.tools[toolName]) {\n      console.error(`Tool '${toolName}' not found`);\n      return false;\n    }\n    \n    // Activate the new tool\n    try {\n      this.tools[toolName].activate(options);\n      this.activeTool = toolName;\n      this.activeMode = toolName;\n      \n      // Update state flags based on tool type\n      this.isDrawing = toolName === 'drawing';\n      this.isEditing = toolName === 'editing';\n      this.isMeasuring = toolName === 'measurement';\n      \n      // Emit event for tool activation\n      this.emit('tool-activated', { \n        tool: toolName, \n        options, \n      });\n      \n      return true;\n    } catch (error) {\n      console.error(`Failed to activate tool '${toolName}':`, error);\n      return false;\n    }\n  }\n  \n  /**\n   * Deactivate the current active tool\n   * @returns {boolean} Success of deactivation\n   */\n  deactivateActiveTool() {\n    if (!this.activeTool) {\n      return true; // No tool active, nothing to do\n    }\n    \n    try {\n      this.tools[this.activeTool].deactivate();\n      \n      // Reset state flags\n      this.activeTool = null;\n      this.activeMode = 'select';\n      this.isDrawing = false;\n      this.isEditing = false;\n      this.isMeasuring = false;\n      \n      // Emit event for tool deactivation\n      this.emit('tool-deactivated');\n      \n      return true;\n    } catch (error) {\n      console.error('Failed to deactivate tool:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Record an action in the history stack for undo/redo\n   * @param {Object} action - The action to record\n   * @private\n   */\n  _recordHistoryAction(action) {\n    // Add timestamp to action\n    action.timestamp = Date.now();\n    \n    // Add to undo stack\n    this.history.undoStack.push(action);\n    \n    // Clear redo stack when a new action is performed\n    this.history.redoStack = [];\n    \n    // Trim undo stack if it exceeds max size\n    if (this.history.undoStack.length > this.history.maxSize) {\n      this.history.undoStack.shift();\n    }\n    \n    // Emit history change event\n    this.emit('historyChanged', {\n      canUndo: this.history.undoStack.length > 0,\n      canRedo: this.history.redoStack.length > 0,\n    });\n  }\n  \n  /**\n   * Undo the last operation\n   * @returns {boolean} Success of undo operation\n   */\n  undo() {\n    if (this.history.undoStack.length === 0) {\n      return false;\n    }\n    \n    // Get the last action\n    const action = this.history.undoStack.pop();\n    \n    // Add to redo stack\n    this.history.redoStack.push(action);\n    \n    // Perform the undo based on action type\n    try {\n      switch (action.type) {\n      case 'featureAdded':\n        this.features.removeFeature(action.featureId);\n        break;\n      case 'featureRemoved':\n        this.features.fromGeoJSON(action.featureData);\n        break;\n      case 'featureUpdated':\n        if (action.previousData) {\n          const feature = this.features.getFeature(action.featureId);\n          if (feature) {\n            feature.fromGeoJSON(action.previousData, { silent: true });\n            this.features.updateFeature(feature, { silent: true });\n          }\n        }\n        break;\n        // Add more action types as needed\n      default:\n        console.warn(`Unknown action type for undo: ${action.type}`);\n      }\n      \n      // Emit events\n      this.emit('undo-performed', action);\n      this.emit('history-changed', {\n        canUndo: this.history.undoStack.length > 0,\n        canRedo: this.history.redoStack.length > 0,\n      });\n      \n      this.metadata.modified = new Date();\n      return true;\n    } catch (error) {\n      // Restore action to undo stack in case of error\n      this.history.undoStack.push(this.history.redoStack.pop());\n      console.error('Error during undo operation:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Redo the last undone operation\n   * @returns {boolean} Success of redo operation\n   */\n  redo() {\n    if (this.history.redoStack.length === 0) {\n      return false;\n    }\n    \n    // Get the last undone action\n    const action = this.history.redoStack.pop();\n    \n    // Add back to undo stack\n    this.history.undoStack.push(action);\n    \n    // Perform the redo based on action type\n    try {\n      switch (action.type) {\n      case 'featureAdded':\n        this.features.fromGeoJSON(action.featureData);\n        break;\n      case 'featureRemoved':\n        this.features.removeFeature(action.featureId);\n        break;\n      case 'featureUpdated':\n        const feature = this.features.getFeature(action.featureId);\n        if (feature) {\n          feature.fromGeoJSON(action.featureData, { silent: true });\n          this.features.updateFeature(feature, { silent: true });\n        }\n        break;\n        // Add more action types as needed\n      default:\n        console.warn(`Unknown action type for redo: ${action.type}`);\n      }\n      \n      // Emit events\n      this.emit('redo-performed', action);\n      this.emit('history-changed', {\n        canUndo: this.history.undoStack.length > 0,\n        canRedo: this.history.redoStack.length > 0,\n      });\n      \n      this.metadata.modified = new Date();\n      return true;\n    } catch (error) {\n      // Restore action to redo stack in case of error\n      this.history.redoStack.push(this.history.undoStack.pop());\n      console.error('Error during redo operation:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Save the current survey state\n   * @param {Object} [options] - Save options\n   * @returns {Object} Survey data object\n   */\n  saveState(_options = {}) {\n    const surveyData = {\n      metadata: { ...this.metadata },\n      features: this.features.toGeoJSON(),\n      settings: { ...this.settings },\n    };\n    \n    // Auto-update modified timestamp\n    surveyData.metadata.modified = new Date();\n    \n    // Emit save event\n    this.emit('survey-saved', surveyData);\n    \n    return surveyData;\n  }\n  \n  /**\n   * Load survey state from saved data\n   * @param {Object} surveyData - Survey data to load\n   * @param {Object} [options] - Load options\n   * @returns {boolean} Success of load operation\n   */\n  loadState(surveyData, _options = {}) {\n    if (!surveyData || !surveyData.features) {\n      console.error('Invalid survey data format');\n      return false;\n    }\n    \n    try {\n      // Clear current state\n      this.features.clear();\n      this.workingFeatures.clear();\n      this.selectedFeatures.clear();\n      \n      // Load metadata\n      if (surveyData.metadata) {\n        this.metadata = { ...surveyData.metadata };\n        \n        // Ensure date objects are restored from serialized format\n        this.metadata.created = new Date(this.metadata.created);\n        this.metadata.modified = new Date(this.metadata.modified);\n      }\n      \n      // Load settings\n      if (surveyData.settings) {\n        this.settings = Object.assign(this.settings, surveyData.settings);\n      }\n      \n      // Load features\n      this.features.fromGeoJSON(surveyData.features);\n      \n      // Reset history\n      this.history.undoStack = [];\n      this.history.redoStack = [];\n      \n      // Emit load event\n      this.emit('survey-loaded', surveyData);\n      \n      return true;\n    } catch (error) {\n      console.error('Error loading survey data:', error);\n      return false;\n    }\n  }\n  \n  /**\n   * Get currently selected features\n   * @returns {Array} Array of selected features\n   */\n  getSelectedFeatures() {\n    return this.selectedFeatures.getAllFeatures();\n  }\n  \n  /**\n   * Select a feature\n   * @param {Feature|string} feature - Feature or feature ID to select\n   * @param {Object} [options] - Selection options\n   * @param {boolean} [options.toggle=false] - Whether to toggle selection state\n   * @param {boolean} [options.addToSelection=false] - Whether to add to existing selection\n   * @returns {boolean} Success of selection operation\n   */\n  selectFeature(feature, options = {}) {\n    const featureObj = typeof feature === 'string' \n      ? this.features.getFeature(feature)\n      : feature;\n      \n    if (!featureObj) {\n      return false;\n    }\n    \n    // Check if feature is already selected\n    const isSelected = this.selectedFeatures.hasFeature(featureObj.id);\n    \n    // Handle toggle mode\n    if (options.toggle && isSelected) {\n      return this.deselectFeature(featureObj);\n    }\n    \n    // Clear existing selection if not adding to it\n    if (!options.addToSelection) {\n      this.clearSelection();\n    }\n    \n    // Don't reselect already selected features\n    if (isSelected) {\n      return true;\n    }\n    \n    // Add to selected collection\n    this.selectedFeatures.addFeature(featureObj);\n    \n    // Update feature selection state\n    featureObj.select();\n    \n    // Emit selection event\n    this.emit('feature-selected', { feature: featureObj });\n    \n    return true;\n  }\n  \n  /**\n   * Deselect a feature\n   * @param {Feature|string} feature - Feature or feature ID to deselect\n   * @returns {boolean} Success of deselection operation\n   */\n  deselectFeature(feature) {\n    const featureObj = typeof feature === 'string' \n      ? this.features.getFeature(feature)\n      : feature;\n      \n    if (!featureObj) {\n      return false;\n    }\n    \n    // Check if feature is selected\n    if (!this.selectedFeatures.hasFeature(featureObj.id)) {\n      return true; // Already not selected\n    }\n    \n    // Remove from selected collection\n    this.selectedFeatures.removeFeature(featureObj);\n    \n    // Update feature selection state\n    featureObj.deselect();\n    \n    // Emit deselection event\n    this.emit('feature-deselected', { feature: featureObj });\n    \n    return true;\n  }\n  \n  /**\n   * Clear all feature selections\n   */\n  clearSelection() {\n    // Get all selected features\n    const selectedFeatures = this.selectedFeatures.getAllFeatures();\n    \n    // Clear the selected collection\n    this.selectedFeatures.clear();\n    \n    // Update each feature's selection state\n    selectedFeatures.forEach(feature => {\n      feature.deselect();\n    });\n    \n    // Emit selection cleared event\n    if (selectedFeatures.length > 0) {\n      this.emit('selection-cleared', { features: selectedFeatures });\n    }\n  }\n  \n  /**\n   * Apply 3D elevation data to features\n   * Uses configured elevation provider to update Z values\n   * @param {Array|Feature} features - Features to update with elevation data\n   * @returns {Promise} Promise resolving when elevation is applied\n   */\n  async applyElevationData(features) {\n    // Convert single feature to array\n    const featureArray = Array.isArray(features) ? features : [features];\n    \n    if (featureArray.length === 0) {\n      return Promise.resolve([]);\n    }\n    \n    // Skip if 3D is disabled\n    if (!this.settings.enable3D) {\n      return Promise.resolve(featureArray);\n    }\n    \n    try {\n      // Determine which elevation provider to use\n      if (this.settings.elevationProvider === 'mapInterface' && \n          this.mapInterface && \n          typeof this.mapInterface.getElevation === 'function') {\n        \n        // Process each feature individually\n        for (const feature of featureArray) {\n          try {\n            // Apply based on feature type\n            switch (feature.type) {\n            case 'point':\n              const pointCoord = feature.getCoordinate();\n              // Get elevation for the point\n              if (!pointCoord.elevation) {\n                const elevation = await this.mapInterface.getElevation(pointCoord);\n                pointCoord.setZ(elevation);\n              }\n              break;\n                \n            case 'line':\n              const lineCoords = feature.getCoordinates();\n              // Get elevation for each coordinate that needs it\n              for (const coord of lineCoords) {\n                if (!coord.elevation) {\n                  const elevation = await this.mapInterface.getElevation(coord);\n                  coord.setZ(elevation);\n                }\n              }\n              feature.setCoordinates(lineCoords);\n              break;\n                \n            case 'polygon':\n              const rings = feature.getRings();\n              // Get elevation for each coordinate in each ring\n              for (const ring of rings) {\n                for (const coord of ring) {\n                  if (!coord.elevation) {\n                    const elevation = await this.mapInterface.getElevation(coord);\n                    coord.setZ(elevation);\n                  }\n                }\n              }\n              feature.setRings(rings);\n              break;\n            }\n            \n            // Update the feature in the collection\n            if (this.features.hasFeature(feature.id)) {\n              this.features.updateFeature(feature);\n            }\n          } catch (error) {\n            console.error(`Error applying elevation to feature ${feature.id}:`, error);\n          }\n        }\n        \n        // Emit elevation updated event\n        this.emit('elevation-data-applied', { features: featureArray });\n        \n        return featureArray;\n      } else {\n        console.warn('No valid elevation provider available');\n        return featureArray;\n      }\n    } catch (error) {\n      console.error('Error applying elevation data:', error);\n      return featureArray;\n    }\n  }\n  \n  /**\n   * Connect an external GNSS module for position updates and device integration\n   * @param {Object} gnssModule - GNSS module instance (from gnss.js library)\n   * @param {Object} [options] - GNSS integration options\n   * @returns {boolean} Success of connection\n   */\n  connectGnssModule(gnssModule, options = {}) {\n    if (!gnssModule) {\n      console.error('Invalid GNSS module provided');\n      return false;\n    }\n\n    try {\n      // Store reference to the GNSS module\n      this.gnssModule = gnssModule;\n\n      // Default options\n      this.gnssOptions = Object.assign({\n        centerMapOnPosition: true,\n        trackedPositionMarker: true,\n        trackedPositionMarkerStyle: {\n          color: '#4285F4',\n          size: 12,\n          outlineColor: '#FFFFFF',\n          outlineWidth: 2,\n        },\n        accuracyCircle: true,\n        qualityIndicator: true,\n      }, options);\n\n      // Setup position tracking\n      this._setupGnssEventHandlers();\n\n      // Create position marker if enabled\n      if (this.gnssOptions.trackedPositionMarker && this.mapInterface) {\n        this._createPositionMarker();\n      }\n\n      // Emit connected event\n      this.emit('gnss-connected', {\n        gnssModule: this.gnssModule,\n        options: this.gnssOptions,\n      });\n\n      return true;\n    } catch (error) {\n      console.error('Error connecting GNSS module:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Set up GNSS module event handlers\n   * @private\n   */\n  _setupGnssEventHandlers() {\n    if (!this.gnssModule || !this.gnssModule.events || typeof this.gnssModule.events.on !== 'function') {\n      console.warn('GNSS module has no events interface');\n      return;\n    }\n\n    // Handle position updates\n    this.gnssModule.events.on('position', (position) => {\n      this._handlePositionUpdate(position);\n    });\n\n    // Handle connection events\n    this.gnssModule.events.on('connection:connected', (data) => {\n      this.emit('gnss-device-connected', data);\n    });\n\n    this.gnssModule.events.on('connection:disconnected', () => {\n      this.emit('gnss-device-disconnected');\n    });\n\n    this.gnssModule.events.on('connection:error', (error) => {\n      this.emit('gnss-device-error', error);\n    });\n\n    // Handle NTRIP connection events\n    this.gnssModule.events.on('ntrip:connected', (data) => {\n      this.emit('gnss-ntrip-connected', data);\n    });\n\n    this.gnssModule.events.on('ntrip:disconnected', () => {\n      this.emit('gnss-ntrip-disconnected');\n    });\n\n    this.gnssModule.events.on('ntrip:error', (error) => {\n      this.emit('gnss-ntrip-error', error);\n    });\n  }\n\n  /**\n   * Handle position updates from GNSS module\n   * @param {Object} position - GNSS position data\n   * @private\n   */\n  _handlePositionUpdate(position) {\n    if (!position || !position.latitude || !position.longitude) {\n      return;\n    }\n\n    // Store current position\n    this.currentPosition = position;\n\n    // Update position marker if enabled\n    if (this.gnssOptions.trackedPositionMarker && this.positionMarker && this.mapInterface) {\n      this._updatePositionMarker(position);\n    }\n\n    // Center map if enabled\n    if (this.gnssOptions.centerMapOnPosition && this.mapInterface) {\n      this.mapInterface.setCenter({\n        lat: position.latitude,\n        lng: position.longitude,\n      });\n    }\n\n    // Emit position event\n    this.emit('gnss-position-updated', position);\n  }\n\n  /**\n   * Create a position marker on the map\n   * @private\n   */\n  _createPositionMarker() {\n    if (!this.mapInterface) return;\n\n    // Check if we already have a marker\n    if (this.positionMarker) {\n      return;\n    }\n\n    // Create position marker (implementation depends on map adapter)\n    if (this.mapInterface && typeof this.mapInterface.createMarker === 'function') {\n      this.positionMarker = this.mapInterface.createMarker({\n        lat: 0,\n        lng: 0,\n      }, {\n        ...this.gnssOptions.trackedPositionMarkerStyle,\n        visible: false,\n        zIndex: 1000,\n      });\n    }\n\n    // Create accuracy circle if enabled\n    if (this.gnssOptions.accuracyCircle && typeof this.mapInterface.createCircle === 'function') {\n      this.accuracyCircle = this.mapInterface.createCircle({\n        lat: 0,\n        lng: 0,\n      }, 0, {\n        fillColor: 'rgba(66, 133, 244, 0.2)',\n        strokeColor: '#4285F4',\n        strokeWeight: 1,\n        visible: false,\n        zIndex: 999,\n      });\n    }\n  }\n\n  /**\n   * Update position marker with new position data\n   * @param {Object} position - GNSS position data\n   * @private\n   */\n  _updatePositionMarker(position) {\n    if (!position || !position.latitude || !position.longitude) {\n      return;\n    }\n\n    // Get style based on fix quality\n    const style = this._getPositionStyleByQuality(position.quality);\n\n    // Update position marker\n    if (this.positionMarker) {\n      this.positionMarker.setPosition({\n        lat: position.latitude,\n        lng: position.longitude,\n      });\n\n      if (typeof this.positionMarker.setStyle === 'function') {\n        this.positionMarker.setStyle(style);\n      }\n\n      if (typeof this.positionMarker.setVisible === 'function') {\n        this.positionMarker.setVisible(true);\n      }\n    }\n\n    // Update accuracy circle if enabled and accuracy data is available\n    if (this.accuracyCircle && position.accuracy) {\n      this.accuracyCircle.setCenter({\n        lat: position.latitude,\n        lng: position.longitude,\n      });\n\n      this.accuracyCircle.setRadius(position.accuracy);\n\n      if (typeof this.accuracyCircle.setVisible === 'function') {\n        this.accuracyCircle.setVisible(true);\n      }\n    }\n  }\n\n  /**\n   * Get position marker style based on fix quality\n   * @param {number} quality - GNSS fix quality (0-5)\n   * @returns {Object} Style object\n   * @private\n   */\n  _getPositionStyleByQuality(quality) {\n    const baseStyle = { ...this.gnssOptions.trackedPositionMarkerStyle };\n\n    // Adjust color based on quality\n    switch (quality) {\n    case 4: // RTK Fixed\n      baseStyle.color = '#4CAF50'; // Green\n      break;\n\n    case 5: // RTK Float\n      baseStyle.color = '#FF9800'; // Orange\n      break;\n\n    case 2: // DGPS\n      baseStyle.color = '#FFEB3B'; // Yellow\n      break;\n\n    case 1: // GPS\n      baseStyle.color = '#2196F3'; // Blue\n      break;\n\n    case 0: // No fix\n    default:\n      baseStyle.color = '#F44336'; // Red\n      break;\n    }\n\n    return baseStyle;\n  }\n\n  /**\n   * Capture a GNSS position as a feature\n   * @param {Object} [options] - Capture options\n   * @returns {Promise<PointFeature|null>} Created point feature or null\n   */\n  async captureGnssPosition(options = {}) {\n    if (!this.gnssModule || !this.currentPosition) {\n      console.warn('No GNSS position available');\n      return null;\n    }\n\n    const position = this.currentPosition;\n\n    try {\n      // Create a point feature from the current position\n      const { PointFeature } = await import('../features/PointFeature.js');\n      const { Coordinate } = await import('../core/Coordinate.js');\n\n      // Create coordinate\n      const coordinate = new Coordinate(\n        position.latitude,\n        position.longitude,\n        position.altitude || 0,\n      );\n\n      // Create style based on fix quality\n      const style = this._getPositionStyleByQuality(position.quality);\n\n      // Set default options\n      const captureOptions = Object.assign({\n        name: `GNSS Point ${new Date().toLocaleTimeString()}`,\n        properties: {\n          source: 'gnss',\n          quality: position.quality,\n          satellites: position.satellites,\n          accuracy: position.accuracy,\n          timestamp: position.timestamp || new Date().toISOString(),\n        },\n        style,\n      }, options);\n\n      // Create feature\n      const feature = new PointFeature(coordinate, captureOptions);\n\n      // Add to feature collection\n      this.features.addFeature(feature);\n\n      // Emit capture event\n      this.emit('gnss-position-captured', {\n        feature,\n        position,\n      });\n\n      return feature;\n    } catch (error) {\n      console.error('Error capturing GNSS position:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Disconnect from GNSS module\n   * @returns {boolean} Success of disconnection\n   */\n  disconnectGnssModule() {\n    if (!this.gnssModule) {\n      return true; // Already disconnected\n    }\n\n    try {\n      // Remove position marker\n      if (this.positionMarker) {\n        if (typeof this.positionMarker.setMap === 'function') {\n          this.positionMarker.setMap(null);\n        }\n        this.positionMarker = null;\n      }\n\n      // Remove accuracy circle\n      if (this.accuracyCircle) {\n        if (typeof this.accuracyCircle.setMap === 'function') {\n          this.accuracyCircle.setMap(null);\n        }\n        this.accuracyCircle = null;\n      }\n\n      // Clear current position\n      this.currentPosition = null;\n\n      // Reset GNSS module reference\n      this.gnssModule = null;\n\n      // Emit disconnected event\n      this.emit('gnss-disconnected');\n\n      return true;\n    } catch (error) {\n      console.error('Error disconnecting GNSS module:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Destroy the survey manager and clean up resources\n   */\n  destroy() {\n    // Disconnect GNSS module if connected\n    if (this.gnssModule) {\n      this.disconnectGnssModule();\n    }\n\n    // Deactivate any active tool\n    this.deactivateActiveTool();\n\n    // Remove all event listeners\n    this.removeAllListeners();\n\n    // Destroy all tools\n    Object.values(this.tools).forEach(tool => {\n      if (typeof tool.destroy === 'function') {\n        tool.destroy();\n      }\n    });\n\n    // Clear collections\n    this.features.clear();\n    this.workingFeatures.clear();\n    this.selectedFeatures.clear();\n\n    // Clear history\n    this.history.undoStack = [];\n    this.history.redoStack = [];\n\n    // Emit destruction event\n    this.emit('destroyed', { manager: this });\n  }\n}","/**\n * Feature Component Module - Main entry point\n * @module gnss/survey/features\n */\n\n// Export feature base class\nexport { FeatureBase } from './FeatureBase.js';\n\n// Export feature implementations\nexport { PointFeature } from './PointFeature.js';\nexport { LineFeature } from './LineFeature.js';\nexport { PolygonFeature } from './PolygonFeature.js';\n\n// Feature operations\nexport { FeatureCollection } from './FeatureCollection.js';\n\n/**\n * Create a point feature\n * @param {Coordinate|Object} coordinate - The point's coordinate\n * @param {Object} [options] - Configuration options\n * @returns {PointFeature} - The created point feature\n */\nexport function createPoint(coordinate, options = {}) {\n  const { PointFeature } = require('./PointFeature.js');\n  return new PointFeature(coordinate, options);\n}\n\n/**\n * Create a line feature\n * @param {Array<Coordinate>} coordinates - The line's coordinates\n * @param {Object} [options] - Configuration options\n * @returns {LineFeature} - The created line feature\n */\nexport function createLine(coordinates, options = {}) {\n  const { LineFeature } = require('./LineFeature.js');\n  return new LineFeature(coordinates, options);\n}\n\n/**\n * Create a polygon feature\n * @param {Array<Coordinate>} coordinates - The polygon's exterior ring coordinates\n * @param {Object} [options] - Configuration options\n * @returns {PolygonFeature} - The created polygon feature\n */\nexport function createPolygon(coordinates, options = {}) {\n  const { PolygonFeature } = require('./PolygonFeature.js');\n  return new PolygonFeature(coordinates, options);\n}\n\n/**\n * Create a feature collection\n * @param {Array<FeatureBase>} [features=[]] - Initial features\n * @param {Object} [options] - Configuration options\n * @returns {FeatureCollection} - The created feature collection\n */\nexport function createFeatureCollection(features = [], options = {}) {\n  const { FeatureCollection } = require('./FeatureCollection.js');\n  return new FeatureCollection(features, options);\n}\n\n/**\n * Import features from GeoJSON\n * @param {Object} geojson - GeoJSON object or FeatureCollection\n * @param {Object} [options] - Import options\n * @returns {Array<FeatureBase>} - Array of imported features\n */\nexport function importFromGeoJSON(geojson, options = {}) {\n  if (!geojson) return [];\n    \n  // Handle FeatureCollection\n  if (geojson.type === 'FeatureCollection' && Array.isArray(geojson.features)) {\n    return geojson.features.map(feature => {\n      return _createFeatureFromGeoJSON(feature, options);\n    }).filter(Boolean);\n  }\n    \n  // Handle individual Feature\n  if (geojson.type === 'Feature') {\n    const feature = _createFeatureFromGeoJSON(geojson, options);\n    return feature ? [feature] : [];\n  }\n    \n  // Handle Geometry\n  if (geojson.type && geojson.coordinates) {\n    // Wrap it as a feature\n    const feature = _createFeatureFromGeoJSON({\n      type: 'Feature',\n      geometry: geojson,\n    }, options);\n    return feature ? [feature] : [];\n  }\n    \n  return [];\n}\n\n/**\n * Create a feature from a GeoJSON object\n * @param {Object} geojson - GeoJSON feature\n * @param {Object} options - Import options\n * @returns {FeatureBase|null} - Created feature or null\n * @private\n */\nfunction _createFeatureFromGeoJSON(geojson, options = {}) {\n  if (!geojson || !geojson.geometry || !geojson.geometry.type) {\n    return null;\n  }\n    \n  let feature;\n    \n  switch (geojson.geometry.type) {\n  case 'Point':\n    feature = createPoint([], { id: geojson.id });\n    break;\n            \n  case 'LineString':\n    feature = createLine([], { id: geojson.id });\n    break;\n            \n  case 'Polygon':\n    feature = createPolygon([], { id: geojson.id });\n    break;\n            \n  default:\n    console.warn(`Unsupported GeoJSON geometry type: ${geojson.geometry.type}`);\n    return null;\n  }\n    \n  if (feature) {\n    feature.fromGeoJSON(geojson, options);\n  }\n    \n  return feature;\n}","/**\n * Abstract Map Interface - Base class for all map providers\n * @module gnss/survey/map/MapInterface\n */\nexport class MapInterface {\n  /**\n     * Initialize the map interface\n     * @param {Object} options - Configuration options for the map\n     */\n  constructor(options = {}) {\n    if (this.constructor === MapInterface) {\n      throw new Error('Abstract class \\'MapInterface\\' cannot be instantiated directly.');\n    }\n        \n    this.options = options;\n  }\n    \n  /**\n     * Set the cursor style for the map\n     * @param {string} cursorType - CSS cursor value (e.g., 'default', 'pointer', 'crosshair')\n     * @returns {void}\n     */\n  setCursor(_cursorType) {\n    throw new Error('Method \\'setCursor()\\' must be implemented.');\n  }\n    \n  /**\n     * Initialize the map with the specified container\n     * @param {string|HTMLElement} container - The HTML element or element ID to contain the map\n     * @returns {Promise<void>} - Promise that resolves when the map is initialized\n     */\n  async initialize(_container) {\n    throw new Error('Method \\'initialize()\\' must be implemented.');\n  }\n    \n  /**\n     * Set the center of the map to the specified coordinate\n     * @param {Coordinate} coordinate - The coordinate to center the map on\n     * @returns {Promise<void>} - Promise that resolves when the map is centered\n     */\n  async setCenter(_coordinate) {\n    throw new Error('Method \\'setCenter()\\' must be implemented.');\n  }\n    \n  /**\n     * Set the zoom level of the map\n     * @param {number} zoomLevel - The zoom level to set\n     * @returns {Promise<void>} - Promise that resolves when the zoom is set\n     */\n  async setZoom(_zoomLevel) {\n    throw new Error('Method \\'setZoom()\\' must be implemented.');\n  }\n    \n  /**\n     * Add a marker to the map\n     * @param {Coordinate} coordinate - The coordinate to place the marker\n     * @param {Object} options - Configuration options for the marker\n     * @returns {Promise<Object>} - Promise that resolves with the created marker instance\n     */\n  async addMarker(_coordinate, _options = {}) {\n    throw new Error('Method \\'addMarker()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove a marker from the map\n     * @param {Object} marker - The marker instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the marker is removed\n     */\n  async removeMarker(_marker) {\n    throw new Error('Method \\'removeMarker()\\' must be implemented.');\n  }\n    \n  /**\n     * Add a polyline to the map\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the polyline\n     * @param {Object} options - Configuration options for the polyline\n     * @returns {Promise<Object>} - Promise that resolves with the created polyline instance\n     */\n  async addPolyline(_coordinates, _options = {}) {\n    throw new Error('Method \\'addPolyline()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove a polyline from the map\n     * @param {Object} polyline - The polyline instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the polyline is removed\n     */\n  async removePolyline(_polyline) {\n    throw new Error('Method \\'removePolyline()\\' must be implemented.');\n  }\n    \n  /**\n     * Add a polygon to the map\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the polygon\n     * @param {Object} options - Configuration options for the polygon\n     * @returns {Promise<Object>} - Promise that resolves with the created polygon instance\n     */\n  async addPolygon(_coordinates, _options = {}) {\n    throw new Error('Method \\'addPolygon()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove a polygon from the map\n     * @param {Object} polygon - The polygon instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the polygon is removed\n     */\n  async removePolygon(_polygon) {\n    throw new Error('Method \\'removePolygon()\\' must be implemented.');\n  }\n    \n  /**\n     * Get the current visible bounds of the map\n     * @returns {Promise<Object>} - Promise that resolves with the bounds object\n     */\n  async getBounds() {\n    throw new Error('Method \\'getBounds()\\' must be implemented.');\n  }\n    \n  /**\n     * Fit the map view to the specified bounds\n     * @param {Object} bounds - The bounds to fit the map to\n     * @param {Object} options - Configuration options for fitting\n     * @returns {Promise<void>} - Promise that resolves when the map is fitted to bounds\n     */\n  async fitBounds(_bounds, _options = {}) {\n    throw new Error('Method \\'fitBounds()\\' must be implemented.');\n  }\n    \n  /**\n     * Register an event listener on the map\n     * @param {string} eventType - The type of event to listen for\n     * @param {Function} listener - The callback function to execute when the event occurs\n     * @returns {Promise<Object>} - Promise that resolves with the listener handle\n     */\n  async addEventListener(_eventType, _listener) {\n    throw new Error('Method \\'addEventListener()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove an event listener from the map\n     * @param {string} eventType - The type of event\n     * @param {Object} listenerHandle - The listener handle to remove\n     * @returns {Promise<void>} - Promise that resolves when the listener is removed\n     */\n  async removeEventListener(_eventType, _listenerHandle) {\n    throw new Error('Method \\'removeEventListener()\\' must be implemented.');\n  }\n    \n  /**\n     * Get the elevation at a specific coordinate\n     * @param {Coordinate} coordinate - The coordinate to get elevation for\n     * @returns {Promise<number>} - Promise that resolves with the elevation in meters\n     */\n  async getElevation(_coordinate) {\n    throw new Error('Method \\'getElevation()\\' must be implemented.');\n  }\n    \n  /**\n     * Get elevations for a path of coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the path\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForPath(_coordinates) {\n    throw new Error('Method \\'getElevationsForPath()\\' must be implemented.');\n  }\n    \n  /**\n     * Convert a geographic coordinate to pixel coordinates on the map\n     * @param {Coordinate} coordinate - The geographic coordinate to convert\n     * @returns {Array<number>} - [x, y] pixel coordinates\n     */\n  coordinateToPixel(_coordinate) {\n    throw new Error('Method \\'coordinateToPixel()\\' must be implemented.');\n  }\n    \n  /**\n     * Convert pixel coordinates to a geographic coordinate\n     * @param {Array<number>} pixel - [x, y] pixel coordinates\n     * @returns {Coordinate} - The geographic coordinate\n     */\n  pixelToCoordinate(_pixel) {\n    throw new Error('Method \\'pixelToCoordinate()\\' must be implemented.');\n  }\n}","/**\n * Extended Map Interface for 3D maps\n * @module gnss/survey/map/Map3DInterface\n */\nimport { MapInterface } from './MapInterface.js';\n\nexport class Map3DInterface extends MapInterface {\n  /**\n     * Initialize the 3D map interface\n     * @param {Object} options - Configuration options for the map\n     */\n  constructor(options = {}) {\n    super(options);\n        \n    if (this.constructor === Map3DInterface) {\n      throw new Error('Abstract class \\'Map3DInterface\\' cannot be instantiated directly.');\n    }\n  }\n    \n  /**\n     * Set the camera tilt angle (pitch)\n     * @param {number} angle - The tilt angle in degrees (0 = looking straight down)\n     * @returns {Promise<void>} - Promise that resolves when the tilt is set\n     */\n  async setTilt(_angle) {\n    throw new Error('Method \\'setTilt()\\' must be implemented.');\n  }\n    \n  /**\n     * Set the camera heading (rotation)\n     * @param {number} angle - The heading angle in degrees (0 = north)\n     * @returns {Promise<void>} - Promise that resolves when the heading is set\n     */\n  async setHeading(_angle) {\n    throw new Error('Method \\'setHeading()\\' must be implemented.');\n  }\n    \n  /**\n     * Get the current camera position\n     * @returns {Promise<Object>} - Promise that resolves with the camera position\n     */\n  async getCameraPosition() {\n    throw new Error('Method \\'getCameraPosition()\\' must be implemented.');\n  }\n    \n  /**\n     * Set the camera position\n     * @param {Object} position - The camera position\n     * @param {Coordinate} position.coordinate - The coordinate to position the camera\n     * @param {number} position.distance - The distance from the coordinate\n     * @param {number} position.heading - The heading angle in degrees\n     * @param {number} position.tilt - The tilt angle in degrees\n     * @returns {Promise<void>} - Promise that resolves when the position is set\n     */\n  async setCameraPosition(_position) {\n    throw new Error('Method \\'setCameraPosition()\\' must be implemented.');\n  }\n    \n  /**\n     * Add a 3D model to the map\n     * @param {Coordinate} coordinate - The coordinate to place the model\n     * @param {Object} options - Configuration options for the model\n     * @returns {Promise<Object>} - Promise that resolves with the model object\n     */\n  async addModel(_coordinate, _options = {}) {\n    throw new Error('Method \\'addModel()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove a 3D model from the map\n     * @param {Object} model - The model to remove\n     * @returns {Promise<void>} - Promise that resolves when the model is removed\n     */\n  async removeModel(_model) {\n    throw new Error('Method \\'removeModel()\\' must be implemented.');\n  }\n    \n  /**\n     * Add terrain to the map\n     * @param {Object} options - Configuration options for the terrain\n     * @returns {Promise<Object>} - Promise that resolves with the terrain object\n     */\n  async addTerrain(_options = {}) {\n    throw new Error('Method \\'addTerrain()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove terrain from the map\n     * @returns {Promise<void>} - Promise that resolves when the terrain is removed\n     */\n  async removeTerrain() {\n    throw new Error('Method \\'removeTerrain()\\' must be implemented.');\n  }\n    \n  /**\n     * Enable or disable terrain exaggeration\n     * @param {number} factor - The exaggeration factor (1.0 = normal)\n     * @returns {Promise<void>} - Promise that resolves when exaggeration is set\n     */\n  async setTerrainExaggeration(_factor) {\n    throw new Error('Method \\'setTerrainExaggeration()\\' must be implemented.');\n  }\n}","/**\n * Abstract Elevation Service Interface\n * @module gnss/survey/map/ElevationService\n */\nexport class ElevationService {\n  /**\n     * Initialize the elevation service\n     * @param {Object} options - Configuration options for the elevation service\n     */\n  constructor(options = {}) {\n    if (this.constructor === ElevationService) {\n      throw new Error('Abstract class \\'ElevationService\\' cannot be instantiated directly.');\n    }\n        \n    this.options = options;\n  }\n    \n  /**\n     * Get the elevation at a specific coordinate\n     * @param {Coordinate} coordinate - The coordinate to get elevation for\n     * @returns {Promise<number>} - Promise that resolves with the elevation in meters\n     */\n  async getElevation(_coordinate) {\n    throw new Error('Method \\'getElevation()\\' must be implemented.');\n  }\n    \n  /**\n     * Get elevations for a path of coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the path\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForPath(_coordinates) {\n    throw new Error('Method \\'getElevationsForPath()\\' must be implemented.');\n  }\n    \n  /**\n     * Get elevations for an array of coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates to get elevations for\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForLocations(_coordinates) {\n    throw new Error('Method \\'getElevationsForLocations()\\' must be implemented.');\n  }\n}","/**\n * Google Maps implementation of the Map Interface\n * @module gnss/survey/map/GoogleMapsAdapter\n */\nimport { MapInterface } from './MapInterface.js';\nimport { Coordinate } from '../core/Coordinate.js';\n\nexport class GoogleMapsAdapter extends MapInterface {\n  /**\n     * Initialize the Google Maps adapter\n     * @param {Object} options - Configuration options for Google Maps\n     * @param {string} [options.apiKey] - Google Maps API key (optional if already loaded)\n     * @param {Object} [options.mapOptions] - Google Maps initialization options\n     */\n  constructor(options = {}) {\n    super(options);\n        \n    // If a map instance is provided, use it directly\n    this.map = options.mapInstance || null;\n    this.apiLoaded = this.map !== null || (window.google && window.google.maps);\n    this.apiKey = options.apiKey;\n    this.mapOptions = options.mapOptions || {\n      center: { lat: 0, lng: 0 },\n      zoom: 2,\n      mapTypeId: 'hybrid',\n      mapTypeControl: true,\n      fullscreenControl: true,\n      streetViewControl: false,\n    };\n        \n    // Keep track of event listeners for cleanup\n    // Structure: Map<eventType, Map<listenerFunction, handle>>\n    this.eventListeners = new Map();\n  }\n    \n  /**\n     * Set the cursor style for the map\n     * @param {string} cursorType - CSS cursor value (e.g., 'default', 'pointer', 'crosshair')\n     * @returns {void}\n     */\n  setCursor(cursorType) {\n    if (!this.map) {\n      return;\n    }\n    this.map.getDiv().style.cursor = cursorType;\n  }\n    \n  /**\n     * Load the Google Maps API if not already loaded\n     * @returns {Promise<void>} - Promise that resolves when the API is loaded\n     * @private\n     */\n  async _loadGoogleMapsAPI() {\n    if (window.google && window.google.maps) {\n      this.apiLoaded = true;\n      return;\n    }\n        \n    if (!this.apiKey) {\n      throw new Error('Google Maps API key is required for initialization');\n    }\n        \n    return new Promise((resolve, reject) => {\n      const callbackName = `GoogleMapsCallback_${Date.now()}`;\n      window[callbackName] = () => {\n        this.apiLoaded = true;\n        delete window[callbackName];\n        resolve();\n      };\n            \n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&callback=${callbackName}&libraries=geometry,places`;\n      script.async = true;\n      script.defer = true;\n      script.onerror = () => reject(new Error('Failed to load Google Maps API'));\n      document.head.appendChild(script);\n    });\n  }\n    \n  /**\n     * Initialize the map with the specified container\n     * @param {string|HTMLElement} container - The HTML element or element ID to contain the map\n     * @returns {Promise<void>} - Promise that resolves when the map is initialized\n     */\n  async initialize(container) {\n    // If we already have a map instance, we don't need to create a new one\n    if (this.map) {\n      return Promise.resolve();\n    }\n        \n    await this._loadGoogleMapsAPI();\n        \n    const element = typeof container === 'string' \n      ? document.getElementById(container) \n      : container;\n            \n    if (!element) {\n      throw new Error(`Map container element not found: ${container}`);\n    }\n        \n    this.map = new google.maps.Map(element, this.mapOptions);\n        \n    // Wait for the map to be fully loaded\n    return new Promise((resolve) => {\n      google.maps.event.addListenerOnce(this.map, 'idle', () => {\n        resolve();\n      });\n    });\n  }\n    \n  /**\n     * Convert a Coordinate to a Google Maps LatLng\n     * @param {Coordinate} coordinate - The coordinate to convert\n     * @returns {google.maps.LatLng} - Google Maps LatLng object\n     * @private\n     */\n  _toLatLng(coordinate) {\n    return new google.maps.LatLng(coordinate.lat, coordinate.lng);\n  }\n    \n  /**\n     * Convert a Google Maps LatLng to a Coordinate\n     * @param {google.maps.LatLng} latLng - The Google Maps LatLng to convert\n     * @param {number} [elevation] - Optional elevation value\n     * @returns {Coordinate} - Coordinate instance\n     * @private\n     */\n  _toCoordinate(latLng, elevation = null) {\n    // Use 0 as default elevation if null or undefined is provided\n    const safeElevation = elevation !== null && elevation !== undefined ? elevation : 0;\n    return new Coordinate(latLng.lat(), latLng.lng(), safeElevation);\n  }\n    \n  /**\n     * Set the center of the map to the specified coordinate\n     * @param {Coordinate} coordinate - The coordinate to center the map on\n     * @returns {Promise<void>} - Promise that resolves when the map is centered\n     */\n  async setCenter(coordinate) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    this.map.setCenter(this._toLatLng(coordinate));\n    return Promise.resolve();\n  }\n    \n  /**\n     * Set the zoom level of the map\n     * @param {number} zoomLevel - The zoom level to set\n     * @returns {Promise<void>} - Promise that resolves when the zoom is set\n     */\n  async setZoom(zoomLevel) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    this.map.setZoom(zoomLevel);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a marker to the map\n     * @param {Coordinate} coordinate - The coordinate to place the marker\n     * @param {Object} options - Configuration options for the marker\n     * @returns {Promise<Object>} - Promise that resolves with the created marker instance\n     */\n  async addMarker(coordinate, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const markerOptions = {\n      position: this._toLatLng(coordinate),\n      map: this.map,\n      title: options.title || '',\n      label: options.label || null,\n      icon: options.icon || null,\n      draggable: options.draggable || false,\n      zIndex: options.zIndex || null,\n      ...options.markerOptions,\n    };\n        \n    const marker = new google.maps.Marker(markerOptions);\n        \n    // Store elevation in marker object for future reference\n    marker.elevation = coordinate.elevation;\n        \n    return Promise.resolve(marker);\n  }\n    \n  /**\n     * Remove a marker from the map\n     * @param {Object} marker - The marker instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the marker is removed\n     */\n  async removeMarker(marker) {\n    if (!marker) {\n      return Promise.resolve();\n    }\n        \n    marker.setMap(null);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a polyline to the map\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the polyline\n     * @param {Object} options - Configuration options for the polyline\n     * @returns {Promise<Object>} - Promise that resolves with the created polyline instance\n     */\n  async addPolyline(coordinates, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const path = coordinates.map(coord => this._toLatLng(coord));\n        \n    const polylineOptions = {\n      path: path,\n      map: this.map,\n      strokeColor: options.strokeColor || '#FF0000',\n      strokeOpacity: options.strokeOpacity || 1.0,\n      strokeWeight: options.strokeWeight || 3,\n      ...options.polylineOptions,\n    };\n        \n    const polyline = new google.maps.Polyline(polylineOptions);\n        \n    // Store original coordinates with elevation data\n    polyline.originalCoordinates = [...coordinates];\n        \n    return Promise.resolve(polyline);\n  }\n    \n  /**\n     * Remove a polyline from the map\n     * @param {Object} polyline - The polyline instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the polyline is removed\n     */\n  async removePolyline(polyline) {\n    if (!polyline) {\n      return Promise.resolve();\n    }\n        \n    polyline.setMap(null);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a polygon to the map\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the polygon\n     * @param {Object} options - Configuration options for the polygon\n     * @returns {Promise<Object>} - Promise that resolves with the created polygon instance\n     */\n  async addPolygon(coordinates, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const path = coordinates.map(coord => this._toLatLng(coord));\n        \n    const polygonOptions = {\n      paths: path,\n      map: this.map,\n      strokeColor: options.strokeColor || '#FF0000',\n      strokeOpacity: options.strokeOpacity || 0.8,\n      strokeWeight: options.strokeWeight || 2,\n      fillColor: options.fillColor || '#FF0000',\n      fillOpacity: options.fillOpacity || 0.35,\n      ...options.polygonOptions,\n    };\n        \n    const polygon = new google.maps.Polygon(polygonOptions);\n        \n    // Store original coordinates with elevation data\n    polygon.originalCoordinates = [...coordinates];\n        \n    return Promise.resolve(polygon);\n  }\n    \n  /**\n     * Remove a polygon from the map\n     * @param {Object} polygon - The polygon instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the polygon is removed\n     */\n  async removePolygon(polygon) {\n    if (!polygon) {\n      return Promise.resolve();\n    }\n        \n    polygon.setMap(null);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Get the current visible bounds of the map\n     * @returns {Promise<Object>} - Promise that resolves with the bounds object\n     */\n  async getBounds() {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const bounds = this.map.getBounds();\n    if (!bounds) {\n      return Promise.resolve(null);\n    }\n        \n    const ne = bounds.getNorthEast();\n    const sw = bounds.getSouthWest();\n        \n    return Promise.resolve({\n      north: ne.lat(),\n      east: ne.lng(),\n      south: sw.lat(),\n      west: sw.lng(),\n      northEast: this._toCoordinate(ne),\n      southWest: this._toCoordinate(sw),\n    });\n  }\n    \n  /**\n     * Fit the map view to the specified bounds\n     * @param {Object} bounds - The bounds to fit the map to\n     * @param {Object} options - Configuration options for fitting\n     * @returns {Promise<void>} - Promise that resolves when the map is fitted to bounds\n     */\n  async fitBounds(bounds, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    let googleBounds;\n        \n    if (bounds.northEast && bounds.southWest) {\n      googleBounds = new google.maps.LatLngBounds(\n        this._toLatLng(bounds.southWest),\n        this._toLatLng(bounds.northEast),\n      );\n    } else if (bounds.north && bounds.south && bounds.east && bounds.west) {\n      googleBounds = new google.maps.LatLngBounds(\n        new google.maps.LatLng(bounds.south, bounds.west),\n        new google.maps.LatLng(bounds.north, bounds.east),\n      );\n    } else if (Array.isArray(bounds)) {\n      // Assume array of coordinates\n      googleBounds = new google.maps.LatLngBounds();\n      bounds.forEach(coord => {\n        googleBounds.extend(this._toLatLng(coord));\n      });\n    } else {\n      throw new Error('Invalid bounds format');\n    }\n        \n    const fitOptions = {\n      padding: options.padding || 0,\n      ...options.fitOptions,\n    };\n        \n    this.map.fitBounds(googleBounds, fitOptions);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Register an event listener on the map\n     * @param {string} eventType - The type of event to listen for\n     * @param {Function} listener - The callback function to execute when the event occurs\n     * @returns {Promise<Object>} - Promise that resolves with the listener handle\n     */\n  async addEventListener(eventType, listener) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    // Map Google-specific event names to standard ones\n    const googleEventType = eventType === 'contextmenu' ? 'rightclick' : eventType;\n        \n    // Create a debounced version of the mousemove handler to limit coordinate creation\n    let lastMoveTime = 0;\n    const throttleInterval = 50; // ms between mousemove events\n        \n    // For click events, track the last click time to prevent double-processing\n    // due to how Google Maps handles events internally\n    let lastClickTime = 0;\n    const clickDebounceTime = 100; // ms between clicks to consider it a \"new\" click\n        \n    const handle = google.maps.event.addListener(this.map, googleEventType, event => {\n      // For click events, check for debouncing\n      if (eventType === 'click' || eventType === 'dblclick') {\n        const now = Date.now();\n        if (now - lastClickTime < clickDebounceTime) {\n          // This might be a duplicate click or same click being processed by different handlers\n          console.debug(`Debounced ${eventType} event, too soon after last click`);\n          return;\n        }\n        lastClickTime = now;\n                \n        // If this event comes from a map feature like POI, ignore it if clickableIcons is false\n        // Google will still generate click events for its own features sometimes\n        if (event.placeId || event.feature) {\n          // This is a click on a Google Maps feature (POI, etc.)\n          console.debug('Ignoring click on Google Maps POI or feature');\n          // Don't trigger our handler for these clicks\n          return;\n        }\n      }\n            \n      // For mousemove, throttle the events to reduce coordinate creation\n      if (eventType === 'mousemove') {\n        const now = Date.now();\n        if (now - lastMoveTime < throttleInterval) {\n          return; // Skip this event if within throttle interval\n        }\n        lastMoveTime = now;\n      }\n            \n      // Convert Google Maps events to a standard format\n      // Create a normalized version of the originalEvent with preventDefault\n      // and stopPropagation functions\n      const normalizedOriginalEvent = {\n        preventDefault: function() {\n          // If the original event has preventDefault, call it\n          if (event.domEvent && typeof event.domEvent.preventDefault === 'function') {\n            event.domEvent.preventDefault();\n          }\n        },\n        stopPropagation: function() {\n          // If the original event has stopPropagation, call it\n          if (event.domEvent && typeof event.domEvent.stopPropagation === 'function') {\n            event.domEvent.stopPropagation();\n          }\n        },\n        // Also include the original DOM event if it exists\n        domEvent: event.domEvent || null,\n        // Pass along any other properties from the original event\n        ...event,\n      };\n            \n      const convertedEvent = {\n        type: eventType,\n        originalEvent: normalizedOriginalEvent,\n      };\n            \n      // Add coordinate and pixel information for mouse events\n      if (event.latLng) {\n        // Only create full coordinate objects for click events, not mousemove\n        if (eventType === 'click' || eventType === 'dblclick' || eventType === 'contextmenu') {\n          // For significant events, create a full coordinate object\n          convertedEvent.coordinate = this._toCoordinate(event.latLng);\n                    \n          // Log click events with enhanced debug info\n          console.log(`Google Maps ${eventType} event:`, \n            `${event.latLng.lat().toFixed(6)}, ${event.latLng.lng().toFixed(6)}`,\n            event.domEvent ? `DOM event: ${event.domEvent.type}` : '');\n        } else {\n          // For mousemove, just provide a simple object with lat/lng\n          convertedEvent.coordinate = {\n            lat: event.latLng.lat(),\n            lng: event.latLng.lng(),\n            elevation: 0,\n          };\n        }\n                \n        // Always keep the original latLng for direct access\n        convertedEvent.latLng = event.latLng;\n                \n        // Get pixel coordinates for all event types, helpful for debugging\n        try {\n          if (this.map.getProjection()) {\n            const coord = event.latLng;\n            const projection = this.map.getProjection();\n            const point = projection.fromLatLngToPoint(coord);\n            const scale = Math.pow(2, this.map.getZoom());\n            const worldPoint = new google.maps.Point(\n              point.x * scale, \n              point.y * scale,\n            );\n                        \n            const mapContainer = this.map.getDiv();\n            const mapBounds = mapContainer.getBoundingClientRect();\n                        \n            convertedEvent.pixel = [\n              Math.floor(worldPoint.x - (mapBounds.left + window.scrollX)),\n              Math.floor(worldPoint.y - (mapBounds.top + window.scrollY)),\n            ];\n                        \n            // For click events, add extra debug logging about pixel position\n            if (eventType === 'click') {\n              console.debug(`Click at pixel: ${convertedEvent.pixel[0]}, ${convertedEvent.pixel[1]}`);\n            }\n          }\n        } catch (e) {\n          console.warn('Error computing pixel coordinates:', e);\n        }\n      }\n            \n      // Call the listener with the converted event\n      listener(convertedEvent);\n    });\n        \n    // Keep track of the listener for later cleanup\n    // Store both the function reference and the handle\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Map());\n    }\n    this.eventListeners.get(eventType).set(listener, handle);\n        \n    return Promise.resolve(handle);\n  }\n    \n  /**\n     * Remove an event listener from the map\n     * @param {string} eventType - The type of event\n     * @param {Function|Object} listenerOrHandle - The listener function or handle to remove\n     * @returns {Promise<void>} - Promise that resolves when the listener is removed\n     */\n  async removeEventListener(eventType, listenerOrHandle) {\n    if (!listenerOrHandle) {\n      return Promise.resolve();\n    }\n        \n    let handle = listenerOrHandle;\n        \n    // Check if this is a function reference instead of a handle\n    if (typeof listenerOrHandle === 'function') {\n      // Look up the handle from our mapping\n      if (this.eventListeners.has(eventType) && \n                this.eventListeners.get(eventType).has(listenerOrHandle)) {\n        handle = this.eventListeners.get(eventType).get(listenerOrHandle);\n                \n        // Remove the mapping\n        this.eventListeners.get(eventType).delete(listenerOrHandle);\n      } else {\n        // If we don't have a mapping, we can't remove it\n        console.warn(`No event listener found for ${eventType}`);\n        return Promise.resolve();\n      }\n    }\n        \n    // Remove using the handle\n    try {\n      google.maps.event.removeListener(handle);\n    } catch (e) {\n      console.warn(`Error removing listener for ${eventType}:`, e);\n    }\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Get the elevation at a specific coordinate using Google Maps Elevation Service\n     * @param {Coordinate} coordinate - The coordinate to get elevation for\n     * @returns {Promise<number>} - Promise that resolves with the elevation in meters\n     */\n  async getElevation(coordinate) {\n    if (!this.apiLoaded) {\n      throw new Error('Google Maps API not loaded. Call initialize() first.');\n    }\n        \n    // If coordinate already has elevation, return it\n    if (coordinate.elevation !== null && coordinate.elevation !== undefined) {\n      return Promise.resolve(coordinate.elevation);\n    }\n        \n    const elevationService = new google.maps.ElevationService();\n    const locations = [this._toLatLng(coordinate)];\n        \n    return new Promise((resolve, reject) => {\n      elevationService.getElevationForLocations({ locations }, (results, status) => {\n        if (status === google.maps.ElevationStatus.OK && results && results.length > 0) {\n          resolve(results[0].elevation);\n        } else {\n          reject(new Error(`Elevation service failed: ${status}`));\n        }\n      });\n    });\n  }\n    \n  /**\n     * Get elevations for a path of coordinates using Google Maps Elevation Service\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the path\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForPath(coordinates) {\n    if (!this.apiLoaded) {\n      throw new Error('Google Maps API not loaded. Call initialize() first.');\n    }\n        \n    // For coordinates that already have elevation, we could just use those\n    // but we'll request all to ensure consistency from the elevation service\n        \n    const elevationService = new google.maps.ElevationService();\n    const path = coordinates.map(coord => this._toLatLng(coord));\n        \n    // Google's API has a limit on the number of samples, so chunk if needed\n    const MAX_SAMPLES = 512; // Google's limit\n    const samples = Math.min(coordinates.length, MAX_SAMPLES);\n        \n    return new Promise((resolve, reject) => {\n      elevationService.getElevationAlongPath(\n        {\n          path: path,\n          samples: samples,\n        },\n        (results, status) => {\n          if (status === google.maps.ElevationStatus.OK && results && results.length > 0) {\n            const elevations = results.map(result => result.elevation);\n            resolve(elevations);\n          } else {\n            reject(new Error(`Elevation service failed: ${status}`));\n          }\n        },\n      );\n    });\n  }\n    \n  /**\n     * Convert a geographic coordinate to pixel coordinates on the map\n     * @param {Coordinate} coordinate - The geographic coordinate to convert\n     * @returns {Array<number>} - [x, y] pixel coordinates\n     */\n  coordinateToPixel(coordinate) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const latLng = this._toLatLng(coordinate);\n    const projection = this.map.getProjection();\n        \n    if (!projection) {\n      throw new Error('Map projection not ready.');\n    }\n        \n    const point = projection.fromLatLngToPoint(latLng);\n    const scale = Math.pow(2, this.map.getZoom());\n    const worldPoint = new google.maps.Point(\n      point.x * scale, \n      point.y * scale,\n    );\n        \n    const mapContainer = this.map.getDiv();\n    const mapBounds = mapContainer.getBoundingClientRect();\n        \n    // Get the top-left of the map container\n    const topLeft = new google.maps.Point(\n      mapBounds.left + window.scrollX,\n      mapBounds.top + window.scrollY,\n    );\n        \n    // Position relative to the map container\n    return [\n      Math.floor(worldPoint.x - topLeft.x),\n      Math.floor(worldPoint.y - topLeft.y),\n    ];\n  }\n    \n  /**\n     * Convert pixel coordinates to a geographic coordinate\n     * @param {Array<number>} pixel - [x, y] pixel coordinates relative to the map container\n     * @returns {Coordinate} - The geographic coordinate\n     */\n  pixelToCoordinate(pixel) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const projection = this.map.getProjection();\n        \n    if (!projection) {\n      throw new Error('Map projection not ready.');\n    }\n        \n    const mapContainer = this.map.getDiv();\n    const mapBounds = mapContainer.getBoundingClientRect();\n        \n    // Get the top-left of the map container\n    const topLeft = new google.maps.Point(\n      mapBounds.left + window.scrollX,\n      mapBounds.top + window.scrollY,\n    );\n        \n    // Position in world coordinates\n    const scale = Math.pow(2, this.map.getZoom());\n    const worldPoint = new google.maps.Point(\n      (pixel[0] + topLeft.x) / scale,\n      (pixel[1] + topLeft.y) / scale,\n    );\n        \n    // Convert to LatLng\n    const latLng = projection.fromPointToLatLng(worldPoint);\n        \n    // Return as a Coordinate\n    return this._toCoordinate(latLng);\n  }\n    \n  /**\n     * Create a text label on the map\n     * @param {Object} options - Configuration for the label\n     * @param {Coordinate|Object} options.position - The position for the label\n     * @param {string} options.text - The text content of the label\n     * @param {Object} options.style - Styling options for the label\n     * @returns {Object} - The created label object\n     */\n  createLabel(options) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    // Extract options with defaults\n    const position = options.position;\n    const text = options.text || '';\n    const style = options.style || {};\n        \n    // Store labels if not already tracking them\n    if (!this._labels) {\n      this._labels = [];\n    }\n        \n    // Create the label as a custom overlay\n    const latLng = position.lat && position.lng ? \n      new google.maps.LatLng(position.lat, position.lng) : \n      this._toLatLng(position);\n            \n    // Create styles for the label\n    const fontStyle = style.font || '12px Arial';\n    const fillColor = style.fillColor || 'black';\n    const strokeColor = style.strokeColor || 'white';\n    const strokeWidth = style.strokeWidth || 3;\n        \n    // Custom overlay implementation for the label\n    class LabelOverlay extends google.maps.OverlayView {\n      constructor(map, latLng, text, style) {\n        super();\n        this.map = map;\n        this.latLng = latLng;\n        this.text = text;\n        this.style = style;\n        this.div = null;\n        this.setMap(map);\n      }\n            \n      onAdd() {\n        const div = document.createElement('div');\n        div.style.position = 'absolute';\n        div.style.padding = '2px 6px';\n        div.style.borderRadius = '3px';\n        div.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';\n        div.style.font = this.style.font;\n        div.style.color = this.style.fillColor;\n        div.style.textShadow = `${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                       0 ${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                       -${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                       0 -${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}`;\n        div.style.whiteSpace = 'nowrap';\n        div.style.userSelect = 'none';\n        div.style.pointerEvents = 'none'; // Don't block mouse events\n        div.innerHTML = this.text;\n                \n        this.div = div;\n        const panes = this.getPanes();\n        panes.overlayLayer.appendChild(div);\n      }\n            \n      draw() {\n        if (!this.div) return;\n                \n        const overlayProjection = this.getProjection();\n        const position = overlayProjection.fromLatLngToDivPixel(this.latLng);\n                \n        // Position the label\n        this.div.style.left = `${position.x}px`;\n        this.div.style.top = `${position.y}px`;\n        this.div.style.transform = 'translate(-50%, -100%)'; // Position above the point\n      }\n            \n      onRemove() {\n        if (this.div) {\n          this.div.parentNode.removeChild(this.div);\n          this.div = null;\n        }\n      }\n            \n      setPosition(latLng) {\n        this.latLng = latLng;\n        this.draw();\n      }\n            \n      setText(text) {\n        this.text = text;\n        if (this.div) {\n          this.div.innerHTML = text;\n        }\n      }\n            \n      setStyle(style) {\n        this.style = { ...this.style, ...style };\n        if (this.div) {\n          this.div.style.font = this.style.font;\n          this.div.style.color = this.style.fillColor;\n          this.div.style.textShadow = `${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                               0 ${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                               -${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                               0 -${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}`;\n        }\n      }\n    }\n        \n    // Create the label overlay\n    const label = new LabelOverlay(\n      this.map, \n      latLng, \n      text, \n      {\n        font: fontStyle,\n        fillColor: fillColor,\n        strokeColor: strokeColor,\n        strokeWidth: strokeWidth,\n      },\n    );\n        \n    // Store for management\n    this._labels.push(label);\n        \n    return label;\n  }\n    \n  /**\n     * Remove a label from the map\n     * @param {Object} label - The label to remove\n     * @returns {void}\n     */\n  removeLabel(label) {\n    if (!label) return;\n        \n    // Remove the label from the map\n    label.setMap(null);\n        \n    // Remove from our tracking array\n    if (this._labels) {\n      const index = this._labels.indexOf(label);\n      if (index !== -1) {\n        this._labels.splice(index, 1);\n      }\n    }\n  }\n}","/**\n * Leaflet implementation of the Map Interface\n * @module gnss/survey/map/LeafletAdapter\n */\nimport { MapInterface } from './MapInterface.js';\nimport { Coordinate } from '../core/Coordinate.js';\n\nexport class LeafletAdapter extends MapInterface {\n  /**\n     * Initialize the Leaflet adapter\n     * @param {Object} options - Configuration options for Leaflet\n     * @param {Object} [options.mapOptions] - Leaflet initialization options\n     * @param {string} [options.tileLayerUrl] - URL for the tile layer\n     * @param {Object} [options.tileLayerOptions] - Options for the tile layer\n     */\n  constructor(options = {}) {\n    super(options);\n        \n    this.map = null;\n    this.apiLoaded = false;\n    this.mapOptions = options.mapOptions || {\n      center: [0, 0],\n      zoom: 2,\n      minZoom: 2,\n      maxZoom: 18,\n    };\n        \n    this.tileLayerUrl = options.tileLayerUrl || \n            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';\n            \n    // Keep track of event listeners for cleanup\n    // Structure: Map<eventType, Map<listenerFunction, handle>>\n    this.eventListeners = new Map();\n        \n    this.tileLayerOptions = options.tileLayerOptions || {\n      attribution: '&copy; <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n    };\n        \n    // Keep track of event listeners for cleanup\n    this.eventListeners = new Map();\n  }\n    \n  /**\n     * Set the cursor style for the map\n     * @param {string} cursorType - CSS cursor value (e.g., 'default', 'pointer', 'crosshair')\n     * @returns {void}\n     */\n  setCursor(cursorType) {\n    if (!this.map) {\n      return;\n    }\n    this.map.getContainer().style.cursor = cursorType;\n  }\n    \n  /**\n     * Load the Leaflet API if not already loaded\n     * @returns {Promise<void>} - Promise that resolves when the API is loaded\n     * @private\n     */\n  async _loadLeafletAPI() {\n    if (window.L) {\n      this.apiLoaded = true;\n      return Promise.resolve();\n    }\n        \n    const loadCSS = new Promise((resolve, reject) => {\n      const link = document.createElement('link');\n      link.rel = 'stylesheet';\n      link.href = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.css';\n      link.integrity = 'sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=';\n      link.crossOrigin = '';\n      link.onload = resolve;\n      link.onerror = () => reject(new Error('Failed to load Leaflet CSS'));\n      document.head.appendChild(link);\n    });\n        \n    const loadJS = new Promise((resolve, reject) => {\n      const script = document.createElement('script');\n      script.src = 'https://unpkg.com/leaflet@1.9.4/dist/leaflet.js';\n      script.integrity = 'sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=';\n      script.crossOrigin = '';\n      script.async = true;\n      script.onload = () => {\n        this.apiLoaded = true;\n        resolve();\n      };\n      script.onerror = () => reject(new Error('Failed to load Leaflet JS'));\n      document.head.appendChild(script);\n    });\n        \n    return Promise.all([loadCSS, loadJS]);\n  }\n    \n  /**\n     * Initialize the map with the specified container\n     * @param {string|HTMLElement} container - The HTML element or element ID to contain the map\n     * @returns {Promise<void>} - Promise that resolves when the map is initialized\n     */\n  async initialize(container) {\n    await this._loadLeafletAPI();\n        \n    const element = typeof container === 'string' \n      ? document.getElementById(container) \n      : container;\n            \n    if (!element) {\n      throw new Error(`Map container element not found: ${container}`);\n    }\n        \n    this.map = L.map(element, this.mapOptions);\n        \n    // Add the base tile layer\n    L.tileLayer(this.tileLayerUrl, this.tileLayerOptions).addTo(this.map);\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Convert a Coordinate to a Leaflet LatLng\n     * @param {Coordinate} coordinate - The coordinate to convert\n     * @returns {L.LatLng} - Leaflet LatLng object\n     * @private\n     */\n  _toLatLng(coordinate) {\n    return L.latLng(coordinate.latitude, coordinate.longitude);\n  }\n    \n  /**\n     * Convert a Leaflet LatLng to a Coordinate\n     * @param {L.LatLng} latLng - The Leaflet LatLng to convert\n     * @param {number} [elevation] - Optional elevation value\n     * @returns {Coordinate} - Coordinate instance\n     * @private\n     */\n  _toCoordinate(latLng, elevation = null) {\n    return new Coordinate(latLng.lat, latLng.lng, elevation);\n  }\n    \n  /**\n     * Set the center of the map to the specified coordinate\n     * @param {Coordinate} coordinate - The coordinate to center the map on\n     * @returns {Promise<void>} - Promise that resolves when the map is centered\n     */\n  async setCenter(coordinate) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    this.map.setView(this._toLatLng(coordinate), this.map.getZoom());\n    return Promise.resolve();\n  }\n    \n  /**\n     * Set the zoom level of the map\n     * @param {number} zoomLevel - The zoom level to set\n     * @returns {Promise<void>} - Promise that resolves when the zoom is set\n     */\n  async setZoom(zoomLevel) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    this.map.setZoom(zoomLevel);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a marker to the map\n     * @param {Coordinate} coordinate - The coordinate to place the marker\n     * @param {Object} options - Configuration options for the marker\n     * @returns {Promise<Object>} - Promise that resolves with the created marker instance\n     */\n  async addMarker(coordinate, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const markerOptions = {\n      title: options.title || '',\n      alt: options.label || '',\n      draggable: options.draggable || false,\n      ...options.markerOptions,\n    };\n        \n    // Handle custom icon if provided\n    if (options.icon) {\n      if (typeof options.icon === 'string') {\n        // Simple URL icon\n        markerOptions.icon = L.icon({\n          iconUrl: options.icon,\n          iconSize: options.iconSize || [25, 41],\n          iconAnchor: options.iconAnchor || [12, 41],\n          popupAnchor: options.popupAnchor || [1, -34],\n        });\n      } else if (options.icon.options) {\n        // Already a Leaflet icon\n        markerOptions.icon = options.icon;\n      }\n    }\n        \n    const marker = L.marker(\n      [coordinate.latitude, coordinate.longitude], \n      markerOptions,\n    ).addTo(this.map);\n        \n    // Store elevation in marker object for future reference\n    marker.elevation = coordinate.elevation;\n        \n    return Promise.resolve(marker);\n  }\n    \n  /**\n     * Remove a marker from the map\n     * @param {Object} marker - The marker instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the marker is removed\n     */\n  async removeMarker(marker) {\n    if (!marker) {\n      return Promise.resolve();\n    }\n        \n    this.map.removeLayer(marker);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a polyline to the map\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the polyline\n     * @param {Object} options - Configuration options for the polyline\n     * @returns {Promise<Object>} - Promise that resolves with the created polyline instance\n     */\n  async addPolyline(coordinates, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const latLngs = coordinates.map(coord => [coord.latitude, coord.longitude]);\n        \n    const polylineOptions = {\n      color: options.strokeColor || '#FF0000',\n      opacity: options.strokeOpacity || 1.0,\n      weight: options.strokeWeight || 3,\n      ...options.polylineOptions,\n    };\n        \n    const polyline = L.polyline(latLngs, polylineOptions).addTo(this.map);\n        \n    // Store original coordinates with elevation data\n    polyline.originalCoordinates = [...coordinates];\n        \n    return Promise.resolve(polyline);\n  }\n    \n  /**\n     * Remove a polyline from the map\n     * @param {Object} polyline - The polyline instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the polyline is removed\n     */\n  async removePolyline(polyline) {\n    if (!polyline) {\n      return Promise.resolve();\n    }\n        \n    this.map.removeLayer(polyline);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a polygon to the map\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the polygon\n     * @param {Object} options - Configuration options for the polygon\n     * @returns {Promise<Object>} - Promise that resolves with the created polygon instance\n     */\n  async addPolygon(coordinates, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const latLngs = coordinates.map(coord => [coord.latitude, coord.longitude]);\n        \n    const polygonOptions = {\n      color: options.strokeColor || '#FF0000',\n      opacity: options.strokeOpacity || 0.8,\n      weight: options.strokeWeight || 2,\n      fillColor: options.fillColor || '#FF0000',\n      fillOpacity: options.fillOpacity || 0.35,\n      ...options.polygonOptions,\n    };\n        \n    const polygon = L.polygon(latLngs, polygonOptions).addTo(this.map);\n        \n    // Store original coordinates with elevation data\n    polygon.originalCoordinates = [...coordinates];\n        \n    return Promise.resolve(polygon);\n  }\n    \n  /**\n     * Remove a polygon from the map\n     * @param {Object} polygon - The polygon instance to remove\n     * @returns {Promise<void>} - Promise that resolves when the polygon is removed\n     */\n  async removePolygon(polygon) {\n    if (!polygon) {\n      return Promise.resolve();\n    }\n        \n    this.map.removeLayer(polygon);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Get the current visible bounds of the map\n     * @returns {Promise<Object>} - Promise that resolves with the bounds object\n     */\n  async getBounds() {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    const bounds = this.map.getBounds();\n    const ne = bounds.getNorthEast();\n    const sw = bounds.getSouthWest();\n        \n    return Promise.resolve({\n      north: ne.lat,\n      east: ne.lng,\n      south: sw.lat,\n      west: sw.lng,\n      northEast: this._toCoordinate(ne),\n      southWest: this._toCoordinate(sw),\n    });\n  }\n    \n  /**\n     * Fit the map view to the specified bounds\n     * @param {Object} bounds - The bounds to fit the map to\n     * @param {Object} options - Configuration options for fitting\n     * @returns {Promise<void>} - Promise that resolves when the map is fitted to bounds\n     */\n  async fitBounds(bounds, options = {}) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    let leafletBounds;\n        \n    if (bounds.northEast && bounds.southWest) {\n      leafletBounds = L.latLngBounds(\n        this._toLatLng(bounds.southWest),\n        this._toLatLng(bounds.northEast),\n      );\n    } else if (bounds.north && bounds.south && bounds.east && bounds.west) {\n      leafletBounds = L.latLngBounds(\n        L.latLng(bounds.south, bounds.west),\n        L.latLng(bounds.north, bounds.east),\n      );\n    } else if (Array.isArray(bounds)) {\n      // Assume array of coordinates\n      const latLngs = bounds.map(coord => this._toLatLng(coord));\n      leafletBounds = L.latLngBounds(latLngs);\n    } else {\n      throw new Error('Invalid bounds format');\n    }\n        \n    const fitOptions = {\n      padding: options.padding ? L.point(options.padding, options.padding) : null,\n      maxZoom: options.maxZoom || null,\n      animate: options.animate !== false,\n      ...options.fitOptions,\n    };\n        \n    this.map.fitBounds(leafletBounds, fitOptions);\n    return Promise.resolve();\n  }\n    \n  /**\n     * Register an event listener on the map\n     * @param {string} eventType - The type of event to listen for\n     * @param {Function} listener - The callback function to execute when the event occurs\n     * @returns {Promise<Object>} - Promise that resolves with the listener handle\n     */\n  async addEventListener(eventType, listener) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    // Map common event types to Leaflet event types\n    const leafletEventType = eventType === 'click' ? 'click' :\n      eventType === 'zoom_changed' ? 'zoomend' :\n        eventType === 'center_changed' ? 'moveend' :\n          eventType === 'bounds_changed' ? 'moveend' :\n            eventType;\n        \n    const handlerFunction = event => {\n      // Convert Leaflet events to a standard format\n      const convertedEvent = {\n        type: eventType,\n        originalEvent: event,\n      };\n            \n      // Add coordinate and pixel information for mouse events\n      if (event.latlng) {\n        // Convert latlng to coordinate\n        convertedEvent.coordinate = this._toCoordinate(event.latlng);\n                \n        // Add pixel coordinates\n        const pixel = this.coordinateToPixel(convertedEvent.coordinate);\n        convertedEvent.pixel = pixel;\n      }\n            \n      listener(convertedEvent);\n    };\n        \n    this.map.on(leafletEventType, handlerFunction);\n        \n    // Create a handle object for removing later\n    const handle = {\n      leafletEventType,\n      handlerFunction,\n    };\n        \n    // Keep track of the listener for later cleanup\n    // Store both the function reference and the handle\n    if (!this.eventListeners.has(eventType)) {\n      this.eventListeners.set(eventType, new Map());\n    }\n    this.eventListeners.get(eventType).set(listener, handle);\n        \n    return Promise.resolve(handle);\n  }\n    \n  /**\n     * Remove an event listener from the map\n     * @param {string} eventType - The type of event\n     * @param {Function|Object} listenerOrHandle - The listener function or handle to remove\n     * @returns {Promise<void>} - Promise that resolves when the listener is removed\n     */\n  async removeEventListener(eventType, listenerOrHandle) {\n    if (!listenerOrHandle || !this.map) {\n      return Promise.resolve();\n    }\n        \n    let handle = listenerOrHandle;\n        \n    // Check if this is a function reference instead of a handle\n    if (typeof listenerOrHandle === 'function') {\n      // Look up the handle from our mapping\n      if (this.eventListeners.has(eventType) && \n                this.eventListeners.get(eventType).has(listenerOrHandle)) {\n        handle = this.eventListeners.get(eventType).get(listenerOrHandle);\n                \n        // Remove the mapping\n        this.eventListeners.get(eventType).delete(listenerOrHandle);\n      } else {\n        // If we don't have a mapping, we can't remove it\n        console.warn(`No event listener found for ${eventType}`);\n        return Promise.resolve();\n      }\n    }\n        \n    // Remove the event listener using the handle\n    try {\n      this.map.off(handle.leafletEventType, handle.handlerFunction);\n    } catch (e) {\n      console.warn(`Error removing listener for ${eventType}:`, e);\n    }\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Get the elevation at a specific coordinate\n     * Note: Leaflet doesn't provide an elevation service, so this is a stub implementation\n     * that will need to be implemented with a third-party service\n     * @param {Coordinate} coordinate - The coordinate to get elevation for\n     * @returns {Promise<number>} - Promise that resolves with the elevation in meters\n     */\n  async getElevation(coordinate) {\n    // If coordinate already has elevation, return it\n    if (coordinate.elevation !== null && coordinate.elevation !== undefined) {\n      return Promise.resolve(coordinate.elevation);\n    }\n        \n    // This is where you would integrate with a third-party elevation service\n    // For example, open-elevation, mapzen, or the Google Maps Elevation API\n    // For now, just return 0 as a placeholder\n    console.warn('LeafletAdapter.getElevation: No elevation service configured');\n    return Promise.resolve(0);\n  }\n    \n  /**\n     * Get elevations for a path of coordinates\n     * Note: Leaflet doesn't provide an elevation service, so this is a stub implementation\n     * that will need to be implemented with a third-party service\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the path\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForPath(coordinates) {\n    // Use any existing elevation data\n    const elevations = coordinates.map(coord => {\n      return (coord.elevation !== null && coord.elevation !== undefined) \n        ? coord.elevation \n        : 0;\n    });\n        \n    console.warn('LeafletAdapter.getElevationsForPath: No elevation service configured');\n    return Promise.resolve(elevations);\n  }\n    \n  /**\n     * Convert a geographic coordinate to pixel coordinates on the map\n     * @param {Coordinate} coordinate - The geographic coordinate to convert\n     * @returns {Array<number>} - [x, y] pixel coordinates\n     */\n  coordinateToPixel(coordinate) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    // Convert coordinate to Leaflet LatLng\n    const latLng = L.latLng(coordinate.lat, coordinate.lng);\n        \n    // Get the pixel coordinates\n    const point = this.map.latLngToContainerPoint(latLng);\n        \n    return [point.x, point.y];\n  }\n    \n  /**\n     * Convert pixel coordinates to a geographic coordinate\n     * @param {Array<number>} pixel - [x, y] pixel coordinates relative to the map container\n     * @returns {Coordinate} - The geographic coordinate\n     */\n  pixelToCoordinate(pixel) {\n    if (!this.map) {\n      throw new Error('Map not initialized. Call initialize() first.');\n    }\n        \n    // Convert pixel coordinates to Leaflet Point\n    const point = L.point(pixel[0], pixel[1]);\n        \n    // Convert to LatLng\n    const latLng = this.map.containerPointToLatLng(point);\n        \n    // Return as a Coordinate\n    return this._toCoordinate(latLng);\n  }\n}","/**\n * Google Maps Elevation Service implementation\n * @module gnss/survey/map/GoogleMapsElevationService\n */\nimport { ElevationService } from './ElevationService.js';\nimport { Coordinate as _Coordinate } from '../core/Coordinate.js';\n\nexport class GoogleMapsElevationService extends ElevationService {\n  /**\n     * Initialize the Google Maps Elevation Service\n     * @param {Object} options - Configuration options\n     * @param {string} [options.apiKey] - Google Maps API key (optional if already loaded)\n     */\n  constructor(options = {}) {\n    super(options);\n        \n    this.apiLoaded = false;\n    this.apiKey = options.apiKey;\n    this.elevationService = null;\n  }\n    \n  /**\n     * Load the Google Maps API if not already loaded\n     * @returns {Promise<void>} - Promise that resolves when the API is loaded\n     * @private\n     */\n  async _loadGoogleMapsAPI() {\n    if (window.google && window.google.maps) {\n      this.apiLoaded = true;\n            \n      if (!this.elevationService && window.google.maps.ElevationService) {\n        this.elevationService = new google.maps.ElevationService();\n      }\n            \n      return;\n    }\n        \n    if (!this.apiKey) {\n      throw new Error('Google Maps API key is required for initialization');\n    }\n        \n    return new Promise((resolve, reject) => {\n      const callbackName = `GoogleMapsCallback_${Date.now()}`;\n      window[callbackName] = () => {\n        this.apiLoaded = true;\n        this.elevationService = new google.maps.ElevationService();\n        delete window[callbackName];\n        resolve();\n      };\n            \n      const script = document.createElement('script');\n      script.src = `https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&callback=${callbackName}&libraries=geometry`;\n      script.async = true;\n      script.defer = true;\n      script.onerror = () => reject(new Error('Failed to load Google Maps API'));\n      document.head.appendChild(script);\n    });\n  }\n    \n  /**\n     * Convert a Coordinate to a Google Maps LatLng\n     * @param {Coordinate} coordinate - The coordinate to convert\n     * @returns {google.maps.LatLng} - Google Maps LatLng object\n     * @private\n     */\n  _toLatLng(coordinate) {\n    return new google.maps.LatLng(coordinate.latitude, coordinate.longitude);\n  }\n    \n  /**\n     * Get the elevation at a specific coordinate\n     * @param {Coordinate} coordinate - The coordinate to get elevation for\n     * @returns {Promise<number>} - Promise that resolves with the elevation in meters\n     */\n  async getElevation(coordinate) {\n    // Initialize the API if needed\n    if (!this.apiLoaded) {\n      await this._loadGoogleMapsAPI();\n    }\n        \n    // If coordinate already has elevation, return it\n    if (coordinate.elevation !== null && coordinate.elevation !== undefined) {\n      return Promise.resolve(coordinate.elevation);\n    }\n        \n    const locations = [this._toLatLng(coordinate)];\n        \n    return new Promise((resolve, reject) => {\n      this.elevationService.getElevationForLocations({ locations }, (results, status) => {\n        if (status === google.maps.ElevationStatus.OK && results && results.length > 0) {\n          resolve(results[0].elevation);\n        } else {\n          reject(new Error(`Elevation service failed: ${status}`));\n        }\n      });\n    });\n  }\n    \n  /**\n     * Get elevations for a path of coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates for the path\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForPath(coordinates) {\n    // Initialize the API if needed\n    if (!this.apiLoaded) {\n      await this._loadGoogleMapsAPI();\n    }\n        \n    const path = coordinates.map(coord => this._toLatLng(coord));\n        \n    // Google's API has a limit on the number of samples, so chunk if needed\n    const MAX_SAMPLES = 512; // Google's limit\n    const samples = Math.min(coordinates.length, MAX_SAMPLES);\n        \n    return new Promise((resolve, reject) => {\n      this.elevationService.getElevationAlongPath(\n        {\n          path: path,\n          samples: samples,\n        },\n        (results, status) => {\n          if (status === google.maps.ElevationStatus.OK && results && results.length > 0) {\n            const elevations = results.map(result => result.elevation);\n            resolve(elevations);\n          } else {\n            reject(new Error(`Elevation service failed: ${status}`));\n          }\n        },\n      );\n    });\n  }\n    \n  /**\n     * Get elevations for an array of coordinates\n     * @param {Array<Coordinate>} coordinates - Array of coordinates to get elevations for\n     * @returns {Promise<Array<number>>} - Promise that resolves with array of elevations in meters\n     */\n  async getElevationsForLocations(coordinates) {\n    // Initialize the API if needed\n    if (!this.apiLoaded) {\n      await this._loadGoogleMapsAPI();\n    }\n        \n    // Google has a limit of 512 locations per request, so we may need to batch\n    const MAX_LOCATIONS = 512;\n    const batches = [];\n        \n    for (let i = 0; i < coordinates.length; i += MAX_LOCATIONS) {\n      const batchCoordinates = coordinates.slice(i, i + MAX_LOCATIONS);\n      const locations = batchCoordinates.map(coord => this._toLatLng(coord));\n            \n      batches.push(\n        new Promise((resolve, reject) => {\n          this.elevationService.getElevationForLocations(\n            { locations },\n            (results, status) => {\n              if (status === google.maps.ElevationStatus.OK && results) {\n                resolve(results.map(result => result.elevation));\n              } else {\n                reject(new Error(`Elevation service failed: ${status}`));\n              }\n            },\n          );\n        }),\n      );\n    }\n        \n    // Wait for all batches to complete and combine results\n    const results = await Promise.all(batches);\n    return results.flat();\n  }\n}","/**\n * Map Factory - Creates map instances based on provider type\n * @module gnss/survey/map/MapFactory\n */\nimport { GoogleMapsAdapter } from './GoogleMapsAdapter.js';\nimport { LeafletAdapter } from './LeafletAdapter.js';\nimport { MapInterface as _MapInterface } from './MapInterface.js';\n\nexport class MapFactory {\n  /**\n     * Create a map instance based on the provider type\n     * @param {string} providerType - The map provider type ('google', 'leaflet', etc.)\n     * @param {Object} options - Configuration options for the map provider\n     * @returns {MapInterface} - A map interface instance\n     */\n  static createMap(providerType, options = {}) {\n    switch (providerType.toLowerCase()) {\n    case 'google':\n      return new GoogleMapsAdapter(options);\n                \n    case 'leaflet':\n      return new LeafletAdapter(options);\n                \n    default:\n      throw new Error(`Unsupported map provider type: ${providerType}`);\n    }\n  }\n    \n  /**\n     * Check if a map provider is available\n     * @param {string} providerType - The map provider type ('google', 'leaflet', etc.)\n     * @param {Object} [options={}] - Configuration options with potential API keys\n     * @returns {boolean} - True if the provider is available\n     */\n  static isProviderAvailable(providerType, options = {}) {\n    switch (providerType.toLowerCase()) {\n    case 'google':\n      return typeof window !== 'undefined' && \n                      (window.google !== undefined || options.apiKey !== undefined);\n                \n    case 'leaflet':\n      return typeof window !== 'undefined';\n                \n    default:\n      return false;\n    }\n  }\n    \n  /**\n     * Get a list of supported map providers\n     * @returns {Array<string>} - Array of supported provider types\n     */\n  static getSupportedProviders() {\n    return ['google', 'leaflet'];\n  }\n}","/**\n * Abstract Feature Rendering Strategy Interface\n * @module gnss/survey/map/rendering/RenderingStrategy\n */\nexport class RenderingStrategy {\n  /**\n     * Initialize the rendering strategy\n     * @param {MapInterface} map - The map interface to render features on\n     * @param {Object} options - Configuration options for the rendering strategy\n     */\n  constructor(map, options = {}) {\n    if (this.constructor === RenderingStrategy) {\n      throw new Error('Abstract class \\'RenderingStrategy\\' cannot be instantiated directly.');\n    }\n        \n    this.map = map;\n    this.options = options;\n  }\n    \n  /**\n     * Render a point feature on the map\n     * @param {Object} feature - The point feature to render\n     * @param {Coordinate} feature.coordinate - The coordinate of the point\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderPoint(_feature, _options = {}) {\n    throw new Error('Method \\'renderPoint()\\' must be implemented.');\n  }\n    \n  /**\n     * Render a line feature on the map\n     * @param {Object} feature - The line feature to render\n     * @param {Array<Coordinate>} feature.coordinates - The coordinates of the line\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderLine(_feature, _options = {}) {\n    throw new Error('Method \\'renderLine()\\' must be implemented.');\n  }\n    \n  /**\n     * Render a polygon feature on the map\n     * @param {Object} feature - The polygon feature to render\n     * @param {Array<Coordinate>} feature.coordinates - The coordinates of the polygon boundary\n     * @param {Array<Array<Coordinate>>} [feature.holes] - Arrays of coordinates for any holes\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderPolygon(_feature, _options = {}) {\n    throw new Error('Method \\'renderPolygon()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove a rendered feature from the map\n     * @param {Object} renderedFeature - The rendered feature to remove\n     * @returns {Promise<void>} - Promise that resolves when the feature is removed\n     */\n  async removeFeature(_renderedFeature) {\n    throw new Error('Method \\'removeFeature()\\' must be implemented.');\n  }\n    \n  /**\n     * Update a rendered feature on the map\n     * @param {Object} renderedFeature - The previously rendered feature\n     * @param {Object} updatedFeature - The updated feature data\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the updated rendered feature\n     */\n  async updateFeature(_renderedFeature, _updatedFeature, _options = {}) {\n    throw new Error('Method \\'updateFeature()\\' must be implemented.');\n  }\n    \n  /**\n     * Highlight a rendered feature on the map\n     * @param {Object} renderedFeature - The rendered feature to highlight\n     * @param {Object} options - Highlight options\n     * @returns {Promise<void>} - Promise that resolves when the feature is highlighted\n     */\n  async highlightFeature(_renderedFeature, _options = {}) {\n    throw new Error('Method \\'highlightFeature()\\' must be implemented.');\n  }\n    \n  /**\n     * Remove highlight from a rendered feature\n     * @param {Object} renderedFeature - The rendered feature to unhighlight\n     * @returns {Promise<void>} - Promise that resolves when the highlight is removed\n     */\n  async unhighlightFeature(_renderedFeature) {\n    throw new Error('Method \\'unhighlightFeature()\\' must be implemented.');\n  }\n}","/**\n * Google Maps implementation of the rendering strategy\n * @module gnss/survey/map/rendering/GoogleMapsRenderingStrategy\n */\nimport { RenderingStrategy } from './RenderingStrategy.js';\n\nexport class GoogleMapsRenderingStrategy extends RenderingStrategy {\n  /**\n     * Initialize the Google Maps rendering strategy\n     * @param {GoogleMapsAdapter} map - The Google Maps adapter\n     * @param {Object} options - Configuration options\n     */\n  constructor(map, options = {}) {\n    super(map, options);\n        \n    if (!map || !map.map) {\n      throw new Error('GoogleMapsRenderingStrategy requires a valid GoogleMapsAdapter instance');\n    }\n        \n    // Store reference to the actual Google Map instance\n    this.googleMap = map.map;\n        \n    // Track rendered features for update/remove operations\n    this.renderedFeatures = new Map();\n  }\n    \n  /**\n     * Render a point feature on the map\n     * @param {Object} feature - The point feature to render\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderPoint(feature, options = {}) {\n    try {\n      const coordinate = feature.getCoordinate ? feature.getCoordinate() : feature.coordinate;\n      if (!coordinate) {\n        throw new Error('Invalid point feature: no coordinate found');\n      }\n\n      // Enhanced debug logging - clearly mark the start of point rendering\n      console.log('========== RENDERING POINT ==========');\n      console.log(`Coordinate: ${coordinate.lat.toFixed(6)}, ${coordinate.lng.toFixed(6)}`);\n      console.log(`Feature ID: ${feature.id || 'unknown'}`);\n      console.log(`Source: ${feature.properties?.source || 'standard'}`);\n\n      const style = feature.style || options.style || this.options.defaultPointStyle || {};\n      console.log(`Marker style: ${style.useDualMarker ? 'dual-marker' : (style.iconUrl ? 'image' : 'circle')}`);\n      console.log(`Marker color: ${style.color || 'default'}`);\n      console.log('=======================================');\n            \n      // Check for availability of Advanced Markers\n      if (!this._isAdvancedMarkerAvailable()) {\n        throw new Error('Advanced Markers are required and not available in the current Google Maps API version');\n      }\n            \n      // Get marker icon/content configuration\n      const iconConfig = this._createMarkerIcon(style, feature);\n            \n      // Advanced markers configuration - simpler now since we handle positioning with CSS\n      const markerOptions = {\n        position: { lat: coordinate.lat, lng: coordinate.lng },\n        map: this.googleMap,\n        title: feature.name || feature.properties?.name || '',\n        gmpDraggable: options.draggable || false,\n        content: iconConfig.content,\n      };\n            \n      // Create the Advanced Marker\n      const marker = new google.maps.marker.AdvancedMarkerElement(markerOptions);\n            \n      // Store original feature reference\n      marker.originalFeature = feature;\n            \n      // Add click event handler if needed\n      if (options.onClick || options.selectable !== false) {\n        // Advanced markers use the 'gmp-click' event (required for Google Maps Platform)\n        marker.addEventListener('gmp-click', (event) => {\n          // Log that we received a marker click event\n          console.log(`Advanced marker gmp-click received for feature: ${feature.id}`);\n                    \n          // Prevent propagation where possible\n          if (event.stopPropagation) {\n            event.stopPropagation();\n          }\n                    \n          // Stop immediate propagation if available\n          if (event.stopImmediatePropagation) {\n            event.stopImmediatePropagation();\n          }\n                    \n          // Prevent default action\n          if (event.preventDefault) {\n            event.preventDefault();\n          }\n                    \n          if (options.onClick) {\n            options.onClick({\n              feature,\n              renderedFeature: marker,\n              originalEvent: event,\n            });\n          }\n                    \n          if (options.selectable !== false) {\n            this._handleFeatureClick(feature, marker, event);\n          }\n                    \n          return false;\n        });\n      }\n            \n      // Store the rendered feature\n      const renderedFeature = {\n        id: feature.id,\n        type: 'point',\n        originalFeature: feature,\n        renderedObject: marker,\n        options,\n      };\n            \n      this.renderedFeatures.set(feature.id, renderedFeature);\n      return renderedFeature;\n    } catch (error) {\n      console.error('Error rendering point feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Render a line feature on the map\n     * @param {Object} feature - The line feature to render\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderLine(feature, options = {}) {\n    try {\n      // Use let instead of const since we might need to reassign it\n      let coordinates = feature.getCoordinates ? feature.getCoordinates() : feature.coordinates;\n            \n      // Ensure coordinates exist and are an array\n      if (!coordinates || !Array.isArray(coordinates)) {\n        console.warn('Line feature has no coordinates array');\n        // Create a placeholder empty array\n        coordinates = [];\n      }\n            \n      // Get line style from feature or options\n      const style = feature.style || options.style || this.options.defaultLineStyle || {};\n            \n      // Handle empty or insufficient coordinates for preview features\n      let path;\n      if (coordinates.length < 2) {\n        // For preview/temporary features (like during drawing), use a small invisible line\n        // that can be updated later\n        if (feature.properties?.temporary || feature.properties?.isPreview) {\n          console.log(`Creating initial placeholder line with ${coordinates.length} points`);\n                    \n          // Make a temporary path with two nearby points if we have none\n          // or duplicate the single point if we have one\n          if (coordinates.length === 0) {\n            // Use center of the map for placeholders\n            const center = this.googleMap.getCenter();\n            path = [\n              { lat: center.lat(), lng: center.lng() },\n              { lat: center.lat(), lng: center.lng() },\n            ];\n          } else {\n            // Duplicate the single coordinate\n            const singleCoord = coordinates[0];\n            path = [\n              { lat: singleCoord.lat, lng: singleCoord.lng },\n              { lat: singleCoord.lat, lng: singleCoord.lng },\n            ];\n          }\n        } else {\n          // For permanent features, we'll enforce the minimum coordinate requirement\n          throw new Error('Invalid permanent line feature: insufficient coordinates (need at least 2)');\n        }\n      } else {\n        // Normal case - convert existing coordinates to Google Maps path\n        path = coordinates.map(coord => ({\n          lat: coord.lat,\n          lng: coord.lng,\n        }));\n      }\n            \n      // Create polyline options\n      const polylineOptions = {\n        path,\n        map: this.googleMap,\n        geodesic: options.geodesic !== false,\n        strokeColor: style.color || style.strokeColor || '#3388FF',\n        strokeOpacity: style.opacity || style.strokeOpacity || 1.0,\n        strokeWeight: style.width || style.strokeWeight || 3,\n        clickable: true,\n        // Ensure it's on top and interactive\n        zIndex: 100,\n      };\n            \n      // Create the polyline\n      const polyline = new google.maps.Polyline(polylineOptions);\n            \n      // Store original feature reference\n      polyline.originalFeature = feature;\n            \n      // Add click event handler if needed\n      if (options.onClick || options.selectable !== false) {\n        polyline.addListener('click', (event) => {\n          // Log that we received a line click event\n          console.log(`Line click received for feature: ${feature.id}`);\n                    \n          // Prevent propagation to the map\n          if (event.stop) event.stop();\n          if (event.domEvent && event.domEvent.stopPropagation) {\n            event.domEvent.stopPropagation();\n          }\n          if (event.originalEvent && event.originalEvent.stopPropagation) {\n            event.originalEvent.stopPropagation();\n          }\n                    \n          // Ensure we stop immediate propagation too if available\n          if (event.domEvent && event.domEvent.stopImmediatePropagation) {\n            event.domEvent.stopImmediatePropagation();\n          }\n                    \n          // Force preventDefault to ensure no other handlers run\n          if (event.domEvent && event.domEvent.preventDefault) {\n            event.domEvent.preventDefault();\n          }\n                    \n          if (options.onClick) {\n            options.onClick({\n              feature,\n              renderedFeature: polyline,\n              originalEvent: event,\n            });\n          }\n                    \n          if (options.selectable !== false) {\n            this._handleFeatureClick(feature, polyline, event);\n          }\n                    \n          // Return false to try to prevent event bubbling\n          return false;\n        });\n      }\n            \n      // Store the rendered feature\n      const renderedFeature = {\n        id: feature.id,\n        type: 'line',\n        originalFeature: feature,\n        renderedObject: polyline,\n        options,\n      };\n            \n      this.renderedFeatures.set(feature.id, renderedFeature);\n      return renderedFeature;\n    } catch (error) {\n      console.error('Error rendering line feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Render a polygon feature on the map\n     * @param {Object} feature - The polygon feature to render\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderPolygon(feature, options = {}) {\n    try {\n      // For polygons, we need to handle rings correctly\n      let paths = [];\n            \n      // Try different methods to get polygon coordinates\n      if (feature.getRings && typeof feature.getRings === 'function') {\n        const rings = feature.getRings();\n        if (rings && rings.length > 0) {\n          // Convert each ring to Google Maps path\n          paths = rings.map(ring => \n            ring.map(coord => ({\n              lat: coord.lat, \n              lng: coord.lng,\n            })),\n          );\n        }\n      } else if (feature.coordinates && Array.isArray(feature.coordinates)) {\n        // If it's a simple array of coordinates (single ring)\n        paths = [feature.coordinates.map(coord => ({\n          lat: coord.lat,\n          lng: coord.lng,\n        }))];\n      }\n            \n      // Handle empty or insufficient coordinates for preview features\n      if (paths.length === 0 || paths[0].length < 3) {\n        // For preview/temporary features (like during drawing), use a placeholder polygon\n        if (feature.properties?.temporary || feature.properties?.isPreview) {\n          console.log(`Creating initial placeholder polygon with ${paths.length > 0 ? paths[0].length : 0} points`);\n                    \n          // Use center of the map for placeholders\n          const center = this.googleMap.getCenter();\n          const lat = center.lat();\n          const lng = center.lng();\n                    \n          // Create a tiny triangle at map center that will be invisible to user\n          // but valid for the Google Maps API\n          paths = [[\n            { lat, lng },\n            { lat, lng: lng + 0.0000001 },\n            { lat: lat + 0.0000001, lng },\n          ]];\n        } else {\n          // For permanent features, enforce the minimum coordinate requirement\n          throw new Error('Invalid permanent polygon feature: insufficient coordinates (need at least 3)');\n        }\n      }\n            \n      // Get polygon style from feature or options\n      const style = feature.style || options.style || this.options.defaultPolygonStyle || {};\n            \n      // Create polygon options\n      const polygonOptions = {\n        paths,\n        map: this.googleMap,\n        strokeColor: style.outlineColor || style.strokeColor || '#3388FF',\n        strokeOpacity: style.outlineOpacity || style.strokeOpacity || 0.8,\n        strokeWeight: style.outlineWidth || style.strokeWeight || 2,\n        fillColor: style.fillColor || '#3388FF',\n        fillOpacity: style.fillOpacity || 0.35,\n        clickable: true,\n        // Ensure it's on top and interactive\n        zIndex: 100,\n      };\n            \n      // Create the polygon\n      const polygon = new google.maps.Polygon(polygonOptions);\n            \n      // Store original feature reference\n      polygon.originalFeature = feature;\n            \n      // Add click event handler if needed\n      if (options.onClick || options.selectable !== false) {\n        polygon.addListener('click', (event) => {\n          // Log that we received a polygon click event\n          console.log(`Polygon click received for feature: ${feature.id}`);\n                    \n          // Prevent propagation to the map\n          if (event.stop) event.stop();\n          if (event.domEvent && event.domEvent.stopPropagation) {\n            event.domEvent.stopPropagation();\n          }\n          if (event.originalEvent && event.originalEvent.stopPropagation) {\n            event.originalEvent.stopPropagation();\n          }\n                    \n          // Ensure we stop immediate propagation too if available\n          if (event.domEvent && event.domEvent.stopImmediatePropagation) {\n            event.domEvent.stopImmediatePropagation();\n          }\n                    \n          // Force preventDefault to ensure no other handlers run\n          if (event.domEvent && event.domEvent.preventDefault) {\n            event.domEvent.preventDefault();\n          }\n                    \n          if (options.onClick) {\n            options.onClick({\n              feature,\n              renderedFeature: polygon,\n              originalEvent: event,\n            });\n          }\n                    \n          if (options.selectable !== false) {\n            this._handleFeatureClick(feature, polygon, event);\n          }\n                    \n          // Return false to try to prevent event bubbling\n          return false;\n        });\n      }\n            \n      // Store the rendered feature\n      const renderedFeature = {\n        id: feature.id,\n        type: 'polygon',\n        originalFeature: feature,\n        renderedObject: polygon,\n        options,\n      };\n            \n      this.renderedFeatures.set(feature.id, renderedFeature);\n      return renderedFeature;\n    } catch (error) {\n      console.error('Error rendering polygon feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Render a feature based on its type\n     * @param {Object} feature - The feature to render\n     * @param {string} featureType - The type of feature ('point', 'line', 'polygon')\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature object\n     */\n  async renderFeatureByType(feature, featureType, options = {}) {\n    switch (featureType) {\n    case 'point':\n      return this.renderPoint(feature, options);\n    case 'line':\n      return this.renderLine(feature, options);\n    case 'polygon':\n      return this.renderPolygon(feature, options);\n    default:\n      throw new Error(`Unsupported feature type: ${featureType}`);\n    }\n  }\n    \n  /**\n     * Remove a rendered feature from the map\n     * @param {Object} renderedFeature - The rendered feature to remove\n     * @returns {Promise<void>} - Promise that resolves when the feature is removed\n     */\n  async removeFeature(renderedFeature) {\n    try {\n      const mapObject = renderedFeature.renderedObject;\n      if (!mapObject) return;\n            \n      // Remove the map object based on its type\n      if (mapObject instanceof google.maps.marker.AdvancedMarkerElement) {\n        // Advanced marker removal\n        mapObject.map = null;\n      } else if (mapObject instanceof google.maps.Polyline ||\n                      mapObject instanceof google.maps.Polygon) {\n        // Polyline and Polygon removal\n        mapObject.setMap(null);\n      }\n            \n      // Remove from tracked features\n      this.renderedFeatures.delete(renderedFeature.id);\n            \n    } catch (error) {\n      console.error('Error removing feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Update a rendered feature on the map\n     * @param {Object} renderedFeature - The previously rendered feature\n     * @param {Object} updatedFeature - The updated feature data\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the updated rendered feature\n     */\n  async updateFeature(renderedFeature, updatedFeature, options = {}) {\n    try {\n      // Remove the existing feature first\n      await this.removeFeature(renderedFeature);\n            \n      // Re-render with updated feature data\n      const newRenderedFeature = await this.renderFeatureByType(\n        updatedFeature, \n        renderedFeature.type,\n        options || renderedFeature.options,\n      );\n            \n      return newRenderedFeature;\n    } catch (error) {\n      console.error('Error updating feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Highlight a rendered feature on the map\n     * @param {Object} renderedFeature - The rendered feature to highlight\n     * @param {Object} options - Highlight options\n     * @returns {Promise<void>} - Promise that resolves when the feature is highlighted\n     */\n  async highlightFeature(renderedFeature, options = {}) {\n    try {\n      const mapObject = renderedFeature.renderedObject;\n      if (!mapObject) return;\n            \n      // Store original styles for later unhighlighting\n      if (!mapObject.originalStyles) {\n        this._storeOriginalStyles(mapObject, renderedFeature.type);\n      }\n            \n      // Apply highlighting based on feature type\n      switch (renderedFeature.type) {\n      case 'point':\n        this._highlightMarker(mapObject, options);\n        break;\n                    \n      case 'line':\n        this._highlightPolyline(mapObject, options);\n        break;\n                    \n      case 'polygon':\n        this._highlightPolygon(mapObject, options);\n        break;\n      }\n    } catch (error) {\n      console.error('Error highlighting feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Remove highlight from a rendered feature\n     * @param {Object} renderedFeature - The rendered feature to unhighlight\n     * @returns {Promise<void>} - Promise that resolves when the highlight is removed\n     */\n  async unhighlightFeature(renderedFeature) {\n    try {\n      const mapObject = renderedFeature.renderedObject;\n      if (!mapObject || !mapObject.originalStyles) return;\n            \n      // Restore original styles based on feature type\n      switch (renderedFeature.type) {\n      case 'point':\n        this._unhighlightMarker(mapObject);\n        break;\n                    \n      case 'line':\n        this._unhighlightPolyline(mapObject);\n        break;\n                    \n      case 'polygon':\n        this._unhighlightPolygon(mapObject);\n        break;\n      }\n    } catch (error) {\n      console.error('Error unhighlighting feature:', error);\n      throw error;\n    }\n  }\n    \n  /**\n     * Store original styles for a map object\n     * @param {Object} mapObject - The map object\n     * @param {string} type - The feature type\n     * @private\n     */\n  _storeOriginalStyles(mapObject, type) {\n    mapObject.originalStyles = {};\n        \n    switch (type) {\n    case 'point':\n      // Advanced Marker styles storage\n      if (mapObject instanceof google.maps.marker.AdvancedMarkerElement && mapObject.content) {\n        const element = mapObject.content;\n        mapObject.originalStyles.transform = element.style.transform;\n        mapObject.originalStyles.boxShadow = element.style.boxShadow;\n        mapObject.originalStyles.zIndex = element.style.zIndex;\n      }\n      break;\n                \n    case 'line':\n      mapObject.originalStyles.strokeColor = mapObject.get('strokeColor');\n      mapObject.originalStyles.strokeWeight = mapObject.get('strokeWeight');\n      mapObject.originalStyles.strokeOpacity = mapObject.get('strokeOpacity');\n      mapObject.originalStyles.zIndex = mapObject.get('zIndex');\n      break;\n                \n    case 'polygon':\n      mapObject.originalStyles.strokeColor = mapObject.get('strokeColor');\n      mapObject.originalStyles.strokeWeight = mapObject.get('strokeWeight');\n      mapObject.originalStyles.strokeOpacity = mapObject.get('strokeOpacity');\n      mapObject.originalStyles.fillColor = mapObject.get('fillColor');\n      mapObject.originalStyles.fillOpacity = mapObject.get('fillOpacity');\n      mapObject.originalStyles.zIndex = mapObject.get('zIndex');\n      break;\n    }\n  }\n    \n  /**\n     * Highlight a marker\n     * @param {Object} marker - The marker to highlight\n     * @param {Object} options - Highlight options\n     * @private\n     */\n  _highlightMarker(marker, options = {}) {\n    const highlightColor = options.color || '#1a73e8';\n        \n    try {\n      // Highlight advanced marker by modifying the content element\n      if (marker.content) {\n        const element = marker.content;\n                \n        // Store original values if not already stored\n        if (!element._originalStyles) {\n          element._originalStyles = {\n            transform: element.style.transform || '',\n            transition: element.style.transition || '',\n            boxShadow: element.style.boxShadow || '',\n            zIndex: element.style.zIndex || '',\n          };\n        }\n                \n        // Apply highlighting styles\n        element.style.transform = 'scale(1.2)';\n        element.style.transition = 'transform 0.2s ease-in-out';\n        element.style.boxShadow = `0 0 0 2px ${highlightColor}, 0 2px 4px rgba(0,0,0,0.3)`;\n        element.style.zIndex = '1000';\n      }\n    } catch (error) {\n      console.error('Error highlighting marker:', error);\n    }\n  }\n    \n  /**\n     * Unhighlight a marker\n     * @param {Object} marker - The marker to unhighlight\n     * @private\n     */\n  _unhighlightMarker(marker) {\n    try {\n      // Restore original styles for advanced markers\n      if (marker.content && marker.content._originalStyles) {\n        const element = marker.content;\n        const originalStyles = element._originalStyles;\n                \n        // Restore original styles\n        element.style.transform = originalStyles.transform || '';\n        element.style.transition = originalStyles.transition || '';\n        element.style.boxShadow = originalStyles.boxShadow || '';\n        element.style.zIndex = originalStyles.zIndex || '';\n      }\n    } catch (error) {\n      console.error('Error unhighlighting marker:', error);\n    }\n  }\n    \n  /**\n     * Highlight a polyline\n     * @param {Object} polyline - The polyline to highlight\n     * @param {Object} options - Highlight options\n     * @private\n     */\n  _highlightPolyline(polyline, options = {}) {\n    const highlightColor = options.color || '#1a73e8';\n        \n    polyline.setOptions({\n      strokeColor: highlightColor,\n      strokeWeight: polyline.originalStyles.strokeWeight + 2,\n      strokeOpacity: 1.0,\n      zIndex: 1000,\n    });\n  }\n    \n  /**\n     * Unhighlight a polyline\n     * @param {Object} polyline - The polyline to unhighlight\n     * @private\n     */\n  _unhighlightPolyline(polyline) {\n    if (!polyline.originalStyles) return;\n        \n    polyline.setOptions({\n      strokeColor: polyline.originalStyles.strokeColor,\n      strokeWeight: polyline.originalStyles.strokeWeight,\n      strokeOpacity: polyline.originalStyles.strokeOpacity,\n      zIndex: polyline.originalStyles.zIndex,\n    });\n  }\n    \n  /**\n     * Highlight a polygon\n     * @param {Object} polygon - The polygon to highlight\n     * @param {Object} options - Highlight options\n     * @private\n     */\n  _highlightPolygon(polygon, options = {}) {\n    const highlightColor = options.color || '#1a73e8';\n        \n    polygon.setOptions({\n      strokeColor: highlightColor,\n      strokeWeight: polygon.originalStyles.strokeWeight + 2,\n      strokeOpacity: 1.0,\n      fillOpacity: polygon.originalStyles.fillOpacity * 1.2,\n      zIndex: 1000,\n    });\n  }\n    \n  /**\n     * Unhighlight a polygon\n     * @param {Object} polygon - The polygon to unhighlight\n     * @private\n     */\n  _unhighlightPolygon(polygon) {\n    if (!polygon.originalStyles) return;\n        \n    polygon.setOptions({\n      strokeColor: polygon.originalStyles.strokeColor,\n      strokeWeight: polygon.originalStyles.strokeWeight,\n      strokeOpacity: polygon.originalStyles.strokeOpacity,\n      fillColor: polygon.originalStyles.fillColor,\n      fillOpacity: polygon.originalStyles.fillOpacity,\n      zIndex: polygon.originalStyles.zIndex,\n    });\n  }\n    \n  /**\n     * Handle feature click events\n     * @param {Object} feature - The original feature\n     * @param {Object} mapObject - The rendered map object\n     * @param {Object} event - The click event\n     * @private\n     */\n  _handleFeatureClick(feature, mapObject, event) {\n    // Implement selection logic if needed\n    // This should trigger appropriate callbacks or emit events\n    if (this.options.onFeatureClick) {\n      this.options.onFeatureClick({\n        feature,\n        renderedFeature: {\n          id: feature.id,\n          type: this._getFeatureType(mapObject),\n          originalFeature: feature,\n          renderedObject: mapObject,\n        },\n        originalEvent: event,\n      });\n    }\n  }\n    \n  /**\n     * Determine the feature type from a rendered map object\n     * @param {Object} mapObject - The rendered map object\n     * @returns {string} - The feature type\n     * @private\n     */\n  _getFeatureType(mapObject) {\n    if (mapObject instanceof google.maps.marker.AdvancedMarkerElement) {\n      return 'point';\n    } else if (mapObject instanceof google.maps.Polyline) {\n      return 'line';\n    } else if (mapObject instanceof google.maps.Polygon) {\n      return 'polygon';\n    }\n    return 'unknown';\n  }\n    \n  /**\n     * Create a marker icon based on style and feature properties\n     * @param {Object} style - The style configuration\n     * @param {Object} feature - The feature object\n     * @returns {Object} - Icon configuration object\n     * @private\n     */\n  _createMarkerIcon(style, feature) {\n    // Determine color based on style or GNSS quality\n    let color = style.color;\n        \n    // For GNSS points, use quality-based coloring if available\n    if (feature.properties?.source === 'gnss' && feature.properties?.quality !== undefined) {\n      color = this._getQualityColor(feature.properties.quality) || color;\n    }\n        \n    // Default color if none specified\n    color = color || '#FF5733';\n        \n    // Check if we're using a dual-element marker (pin + centered dot)\n    if (style.useDualMarker || style.showPinAndDot) {\n      // Enhanced traditional pin marker\n      const size = style.size || 32; // Larger default size\n      \n      // Create the main container div - this will be centered on the coordinate by Google Maps\n      const container = document.createElement('div');\n      container.style.position = 'relative';\n      container.style.width = '0';  // Zero width container\n      container.style.height = '0';  // Zero height container\n      \n      // Create an SVG pin instead of using div\n      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n      svg.setAttribute('width', `${size}px`);\n      svg.setAttribute('height', `${size * 1.6}px`); // Taller for pin shape\n      svg.setAttribute('viewBox', '0 0 32 52');\n      svg.style.position = 'absolute';\n      svg.style.left = `${-size/2}px`;  // Center horizontally\n      svg.style.top = `${-size * 1.6}px`;  // Position above the coordinate point\n      \n      // Create the traditional teardrop/pin shape\n      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n      path.setAttribute('d', 'M16 0C7.2 0 0 7.2 0 16c0 9.6 16 36 16 36s16-26.4 16-36c0-8.8-7.2-16-16-16z');\n      path.setAttribute('fill', color);\n      path.setAttribute('stroke', style.outlineColor || 'white');\n      path.setAttribute('stroke-width', style.outlineWidth || 2);\n      \n      // Add the path to the SVG\n      svg.appendChild(path);\n      \n      // Create a small dot at the exact coordinate point\n      const dotElement = document.createElement('div');\n      dotElement.style.position = 'absolute';\n      dotElement.style.width = '6px';\n      dotElement.style.height = '6px';\n      dotElement.style.left = '-3px';  // Center the dot\n      dotElement.style.top = '-3px';   // Center the dot\n      dotElement.style.backgroundColor = 'black';\n      dotElement.style.border = '1px solid white';\n      dotElement.style.borderRadius = '50%';\n      dotElement.style.zIndex = '10';\n      \n      // Add elements to container\n      container.appendChild(svg);\n      container.appendChild(dotElement);\n      \n      // Log for debugging\n      console.log('Created SVG pin marker with absolute positioning from center');\n      \n      return { content: container };\n    } else if (style.iconUrl) {\n      // SIMPLE APPROACH: Image marker with absolute positioning\n      const width = style.iconSize?.[0] || 32;\n      const height = style.iconSize?.[1] || 32;\n      \n      // Create the main container div - this will be centered on the coordinate by Google Maps\n      const container = document.createElement('div');\n      container.style.position = 'relative';\n      container.style.width = '0';  // Zero width container\n      container.style.height = '0';  // Zero height container\n      \n      // Create and position the image element\n      const img = document.createElement('img');\n      img.src = style.iconUrl;\n      img.style.position = 'absolute';\n      img.style.width = `${width}px`;\n      img.style.height = `${height}px`;\n      img.style.left = `${-width/2}px`;  // Center horizontally\n      img.style.top = `${-height}px`;    // Bottom edge at the coordinate\n      \n      // Add the image to the container\n      container.appendChild(img);\n      \n      // Log for debugging\n      console.log('Created image marker with absolute positioning from center');\n      \n      return { content: container };\n    } else {\n      // SIMPLE APPROACH: Circle marker centered exactly on the coordinate\n      const size = style.size || 10;\n      \n      // Create the circle element\n      const circleDiv = document.createElement('div');\n      circleDiv.style.width = `${size * 2}px`;\n      circleDiv.style.height = `${size * 2}px`;\n      circleDiv.style.borderRadius = '50%';\n      circleDiv.style.backgroundColor = color;\n      circleDiv.style.border = `${style.outlineWidth || 2}px solid ${style.outlineColor || 'white'}`;\n      circleDiv.style.boxSizing = 'border-box';\n      circleDiv.style.position = 'relative';\n      \n      // Position exactly at the center\n      circleDiv.style.margin = `${-size}px 0 0 ${-size}px`;\n      \n      // Add crosshair if needed\n      if (style.showCrosshair) {\n        // Horizontal line\n        const hLine = document.createElement('div');\n        hLine.style.position = 'absolute';\n        hLine.style.width = '80%';\n        hLine.style.height = '1px';\n        hLine.style.backgroundColor = 'black';\n        hLine.style.left = '10%';\n        hLine.style.top = '50%';\n        \n        // Vertical line\n        const vLine = document.createElement('div');\n        vLine.style.position = 'absolute';\n        vLine.style.width = '1px';\n        vLine.style.height = '80%';\n        vLine.style.backgroundColor = 'black';\n        vLine.style.left = '50%';\n        vLine.style.top = '10%';\n        \n        circleDiv.appendChild(hLine);\n        circleDiv.appendChild(vLine);\n      }\n      \n      // Log for debugging\n      console.log('Created circle marker centered on coordinate');\n      \n      return { content: circleDiv };\n    }\n  }\n    \n  /**\n     * Check if Google Maps Advanced Markers are available\n     * @returns {boolean} - Whether Advanced Markers are available\n     * @private\n     */\n  _isAdvancedMarkerAvailable() {\n    return window.google && \n              window.google.maps && \n              window.google.maps.marker && \n              window.google.maps.marker.AdvancedMarkerElement;\n  }\n    \n  /**\n     * Get color based on GNSS fix quality\n     * @param {number} quality - The GNSS fix quality value\n     * @returns {string} - Color hex code\n     * @private\n     */\n  _getQualityColor(quality) {\n    const qualityColors = {\n      0: '#888888', // No fix - gray\n      1: '#FF0000', // GPS fix - red\n      2: '#FF9900', // DGPS fix - orange\n      4: '#00FF00', // RTK fixed - green\n      5: '#00FFFF',  // Float RTK - cyan\n    };\n        \n    return qualityColors[quality] || '#888888';\n  }\n}","/**\n * Layer Management for organizing map features\n * @module gnss/survey/map/LayerManager\n */\nexport class LayerManager {\n  /**\n     * Initialize the layer manager\n     * @param {MapInterface} map - The map interface to manage layers for\n     * @param {RenderingStrategy} renderingStrategy - The strategy for rendering features\n     * @param {Object} options - Configuration options\n     */\n  constructor(map, renderingStrategy, options = {}) {\n    this.map = map;\n    this.renderingStrategy = renderingStrategy;\n    this.options = options;\n        \n    // Layers storage - each layer contains features\n    this.layers = new Map();\n        \n    // Selection tracking\n    this.selectedFeatures = new Map();\n        \n    // Create default layer if specified\n    if (options.defaultLayer) {\n      this.createLayer(options.defaultLayer);\n    }\n  }\n    \n  /**\n     * Set up event listeners for a feature\n     * This ensures selection/deselection events are properly handled\n     * @param {Object} feature - The feature to set up listeners for\n     * @param {Object} renderedFeature - The rendered feature object\n     * @private\n     */\n  _setupFeatureEventListeners(feature, renderedFeature) {\n    if (!feature || !feature.on || typeof feature.on !== 'function') {\n      console.warn('Cannot set up event listeners: feature has no event emitter');\n      return;\n    }\n        \n    // Listen for selection events\n    feature.on('selected', () => {\n      console.log(`Feature ${feature.id} selected event received`);\n      this.selectedFeatures.set(feature.id, renderedFeature);\n      this.renderingStrategy.highlightFeature(renderedFeature).catch(error => {\n        console.error(`Error highlighting feature ${feature.id}:`, error);\n      });\n    });\n        \n    // Listen for deselection events\n    feature.on('deselected', () => {\n      console.log(`Feature ${feature.id} deselected event received`);\n      this.selectedFeatures.delete(feature.id);\n      this.renderingStrategy.unhighlightFeature(renderedFeature).catch(error => {\n        console.error(`Error unhighlighting feature ${feature.id}:`, error);\n      });\n    });\n  }\n    \n  /**\n     * Create a new layer\n     * @param {string} layerId - The unique identifier for the layer\n     * @param {Object} options - Layer options\n     * @returns {Object} - The created layer\n     */\n  createLayer(layerId, options = {}) {\n    if (this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' already exists`);\n    }\n        \n    const layer = {\n      id: layerId,\n      options,\n      features: new Map(),\n      visible: options.visible !== false,\n      selectable: options.selectable !== false,\n      editable: options.editable !== false,\n    };\n        \n    this.layers.set(layerId, layer);\n    return layer;\n  }\n    \n  /**\n     * Remove a layer and all its features\n     * @param {string} layerId - The ID of the layer to remove\n     * @returns {Promise<void>} - Promise that resolves when the layer is removed\n     */\n  async removeLayer(layerId) {\n    if (!this.layers.has(layerId)) {\n      return Promise.resolve();\n    }\n        \n    const layer = this.layers.get(layerId);\n        \n    // Remove all features from the map\n    const removePromises = [];\n    for (const feature of layer.features.values()) {\n      removePromises.push(this.renderingStrategy.removeFeature(feature));\n    }\n        \n    await Promise.all(removePromises);\n        \n    // Remove the layer\n    this.layers.delete(layerId);\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Set layer visibility\n     * @param {string} layerId - The ID of the layer\n     * @param {boolean} visible - Whether the layer should be visible\n     * @returns {Promise<void>} - Promise that resolves when visibility is set\n     */\n  async setLayerVisibility(layerId, visible) {\n    if (!this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' does not exist`);\n    }\n        \n    const layer = this.layers.get(layerId);\n        \n    // If visibility is already set correctly, do nothing\n    if (layer.visible === visible) {\n      return Promise.resolve();\n    }\n        \n    layer.visible = visible;\n        \n    // Hide or show all features in the layer\n    const promises = [];\n    for (const feature of layer.features.values()) {\n      if (visible) {\n        // Re-render the feature if it was hidden\n        promises.push(\n          this.renderingStrategy.renderFeatureByType(\n            feature.originalFeature,\n            feature.type,\n          ),\n        );\n      } else {\n        // Remove the feature from the map\n        promises.push(this.renderingStrategy.removeFeature(feature));\n      }\n    }\n        \n    await Promise.all(promises);\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Add a feature to a layer\n     * @param {string} layerId - The ID of the layer to add to\n     * @param {Object} feature - The feature to add\n     * @param {string} featureType - The type of feature ('point', 'line', 'polygon')\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the rendered feature\n     */\n  async addFeature(layerId, feature, featureType, options = {}) {\n    if (!this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' does not exist`);\n    }\n        \n    const layer = this.layers.get(layerId);\n        \n    // Only render if the layer is visible\n    let renderedFeature = null;\n        \n    if (layer.visible) {\n      switch (featureType) {\n      case 'point':\n        renderedFeature = await this.renderingStrategy.renderPoint(feature, options);\n        break;\n                    \n      case 'line':\n        renderedFeature = await this.renderingStrategy.renderLine(feature, options);\n        break;\n                    \n      case 'polygon':\n        renderedFeature = await this.renderingStrategy.renderPolygon(feature, options);\n        break;\n                    \n      default:\n        throw new Error(`Unsupported feature type: ${featureType}`);\n      }\n    } else {\n      // If layer is not visible, create a placeholder with the feature data\n      const id = feature.id || `feature_${Date.now()}_${Math.floor(Math.random() * 10000)}`;\n      renderedFeature = {\n        id,\n        originalFeature: feature,\n        renderedObject: null,\n        type: featureType,\n        highlighted: false,\n      };\n    }\n        \n    // Store the feature in the layer\n    layer.features.set(renderedFeature.id, renderedFeature);\n        \n    // Set up event listeners for selection/deselection\n    this._setupFeatureEventListeners(feature, renderedFeature);\n        \n    // If the feature is already selected, apply highlighting immediately\n    if (feature.selected) {\n      console.log(`Feature ${feature.id} added while already selected, applying highlight`);\n      this.selectedFeatures.set(feature.id, renderedFeature);\n      if (renderedFeature.renderedObject) {\n        this.renderingStrategy.highlightFeature(renderedFeature).catch(error => {\n          console.error(`Error highlighting feature ${feature.id}:`, error);\n        });\n      }\n    }\n        \n    return renderedFeature;\n  }\n    \n  /**\n     * Remove a feature from a layer\n     * @param {string} layerId - The ID of the layer\n     * @param {string} featureId - The ID of the feature to remove\n     * @returns {Promise<void>} - Promise that resolves when the feature is removed\n     */\n  async removeFeature(layerId, featureId) {\n    if (!this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' does not exist`);\n    }\n        \n    const layer = this.layers.get(layerId);\n        \n    if (!layer.features.has(featureId)) {\n      return Promise.resolve();\n    }\n        \n    const renderedFeature = layer.features.get(featureId);\n    const originalFeature = renderedFeature.originalFeature;\n        \n    // If this is a selected feature, remove it from selection tracking\n    if (this.selectedFeatures.has(featureId)) {\n      console.log(`Removing selected feature ${featureId} from selection tracking`);\n      this.selectedFeatures.delete(featureId);\n    }\n        \n    // Remove event listeners from original feature if possible\n    if (originalFeature && typeof originalFeature.off === 'function') {\n      console.log(`Removing event listeners from feature ${featureId}`);\n      originalFeature.off('selected');\n      originalFeature.off('deselected');\n    }\n        \n    // Remove from map if it was rendered\n    if (renderedFeature.renderedObject) {\n      // Ensure it's unhighlighted before removal\n      if (renderedFeature.renderedObject.originalStyles) {\n        try {\n          await this.renderingStrategy.unhighlightFeature(renderedFeature);\n        } catch (error) {\n          console.error(`Error unhighlighting feature before removal: ${error.message}`);\n        }\n      }\n            \n      await this.renderingStrategy.removeFeature(renderedFeature);\n    }\n        \n    // Remove from layer\n    layer.features.delete(featureId);\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Update a feature in a layer\n     * @param {string} layerId - The ID of the layer\n     * @param {string} featureId - The ID of the feature to update\n     * @param {Object} updatedFeature - The updated feature data\n     * @param {Object} options - Rendering options\n     * @returns {Promise<Object>} - Promise that resolves with the updated feature\n     */\n  async updateFeature(layerId, featureId, updatedFeature, options = {}) {\n    if (!this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' does not exist`);\n    }\n        \n    const layer = this.layers.get(layerId);\n        \n    if (!layer.features.has(featureId)) {\n      throw new Error(`Feature with ID '${featureId}' does not exist in layer '${layerId}'`);\n    }\n        \n    const existingFeature = layer.features.get(featureId);\n        \n    // If layer is visible, update the rendered feature\n    let updatedRenderedFeature;\n        \n    if (layer.visible && existingFeature.renderedObject) {\n      updatedRenderedFeature = await this.renderingStrategy.updateFeature(\n        existingFeature,\n        updatedFeature,\n        options,\n      );\n    } else {\n      // If not visible, just update the data\n      updatedRenderedFeature = {\n        ...existingFeature,\n        originalFeature: updatedFeature,\n      };\n    }\n        \n    // Update in layer\n    layer.features.set(featureId, updatedRenderedFeature);\n        \n    return updatedRenderedFeature;\n  }\n    \n  /**\n     * Get all layers\n     * @returns {Array<Object>} - Array of layer objects\n     */\n  getLayers() {\n    return Array.from(this.layers.values());\n  }\n    \n  /**\n     * Get a specific layer\n     * @param {string} layerId - The ID of the layer to get\n     * @returns {Object|null} - The layer object or null if not found\n     */\n  getLayer(layerId) {\n    return this.layers.get(layerId) || null;\n  }\n    \n  /**\n     * Get all features in a layer\n     * @param {string} layerId - The ID of the layer\n     * @returns {Array<Object>} - Array of feature objects\n     */\n  getLayerFeatures(layerId) {\n    if (!this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' does not exist`);\n    }\n        \n    const layer = this.layers.get(layerId);\n    return Array.from(layer.features.values());\n  }\n    \n  /**\n     * Get a specific feature from a layer\n     * @param {string} layerId - The ID of the layer\n     * @param {string} featureId - The ID of the feature\n     * @returns {Object|null} - The feature object or null if not found\n     */\n  getFeature(layerId, featureId) {\n    if (!this.layers.has(layerId)) {\n      return null;\n    }\n        \n    const layer = this.layers.get(layerId);\n    return layer.features.get(featureId) || null;\n  }\n    \n  /**\n     * Fit the map view to show all features in a layer\n     * @param {string} layerId - The ID of the layer\n     * @param {Object} options - Options for fitting the bounds\n     * @returns {Promise<void>} - Promise that resolves when the map is fitted\n     */\n  async fitLayerToView(layerId, options = {}) {\n    if (!this.layers.has(layerId)) {\n      throw new Error(`Layer with ID '${layerId}' does not exist`);\n    }\n        \n    const layer = this.layers.get(layerId);\n        \n    if (layer.features.size === 0) {\n      return Promise.resolve();\n    }\n        \n    // Collect all coordinates from all features\n    const allCoordinates = [];\n        \n    for (const feature of layer.features.values()) {\n      const featureCoords = this._getFeatureCoordinates(feature);\n      allCoordinates.push(...featureCoords);\n    }\n        \n    if (allCoordinates.length === 0) {\n      return Promise.resolve();\n    }\n        \n    // Fit map to these coordinates\n    await this.map.fitBounds(allCoordinates, options);\n        \n    return Promise.resolve();\n  }\n    \n  /**\n     * Get coordinates from a feature based on its type\n     * @param {Object} feature - The feature to extract coordinates from\n     * @returns {Array<Coordinate>} - Array of coordinates\n     * @private\n     */\n  _getFeatureCoordinates(feature) {\n    if (!feature.originalFeature) {\n      return [];\n    }\n        \n    switch (feature.type) {\n    case 'point':\n      return [feature.originalFeature.coordinate];\n                \n    case 'line':\n    case 'polygon':\n      return feature.originalFeature.coordinates || [];\n                \n    default:\n      return [];\n    }\n  }\n}","/**\n * Map Module - Main entry point\n * @module gnss/survey/map\n */\n\n// Core interfaces\nexport { MapInterface } from './MapInterface.js';\nexport { Map3DInterface } from './Map3DInterface.js';\nexport { ElevationService } from './ElevationService.js';\n\n// Map implementations\nexport { GoogleMapsAdapter } from './GoogleMapsAdapter.js';\nexport { LeafletAdapter } from './LeafletAdapter.js';\n\n// Elevation service implementations\nexport { GoogleMapsElevationService } from './GoogleMapsElevationService.js';\n\n// Factory for creating map instances\nexport { MapFactory } from './MapFactory.js';\n\n// Rendering strategies\nexport { RenderingStrategy, GoogleMapsRenderingStrategy } from './rendering/index.js';\n\n// Layer management\nexport { LayerManager } from './LayerManager.js';\n\n/**\n * Create a map instance with the specified provider\n * @param {string} provider - The map provider to use ('google', 'leaflet', etc.)\n * @param {Object} options - Configuration options for the map\n * @returns {MapInterface} - The created map instance\n */\nexport function createMap(provider, options = {}) {\n  return MapFactory.createMap(provider, options);\n}\n\n/**\n * Get a list of supported map providers\n * @returns {Array<string>} - Array of supported provider names\n */\nexport function getSupportedProviders() {\n  return MapFactory.getSupportedProviders();\n}","/**\n * SimplifiedDrawingTool.js\n * A simplified drawing tool implementation for basic usage\n */\n\nimport { EventEmitter } from '../core/event-emitter.js';\nimport { Coordinate } from '../core/Coordinate.js';\n\n/**\n * Simplified drawing tool that works with Google Maps\n */\nexport class SimplifiedDrawingTool extends EventEmitter {\n  /**\n   * Create a new SimplifiedDrawingTool instance\n   * @param {Object} options - Tool configuration\n   */\n  constructor(options = {}) {\n    super();\n    \n    this.map = options.map;\n    this.geometryEngine = options.geometryEngine;\n    \n    this.options = {\n      mode: 'point',\n      enable3D: true,\n      continuousDrawing: true,\n      pointSymbol: {\n        color: '#4285F4',\n        size: 8,\n      },\n      lineSymbol: {\n        color: '#4285F4',\n        width: 3,\n      },\n      polygonSymbol: {\n        fillColor: 'rgba(66, 133, 244, 0.3)',\n        outlineColor: '#4285F4',\n        outlineWidth: 2,\n      },\n      ...options,\n    };\n    \n    this.isActive = false;\n    this.listeners = [];\n    this.currentFeature = null;\n    this.vertices = [];\n    this.markers = [];\n    this.polyline = null;\n    this.polygon = null;\n  }\n  \n  /**\n   * Activate the drawing tool\n   * @param {Object} options - Activation options\n   */\n  activate(options = {}) {\n    if (this.isActive) {\n      this._reset();\n    }\n    \n    // Update options\n    Object.assign(this.options, options);\n    \n    // Mark as active\n    this.isActive = true;\n    \n    // Add click listener to map\n    this._addMapListeners();\n    \n    // Log activation info\n    console.log(`SimplifiedDrawingTool activated in ${this.options.mode} mode`);\n    \n    // Emit activation event\n    this.emit('activated', { mode: this.options.mode });\n  }\n  \n  /**\n   * Add map event listeners\n   * @private\n   */\n  _addMapListeners() {\n    // Remove any existing listeners first\n    this._removeMapListeners();\n    \n    // Add click listener to map\n    const clickListener = google.maps.event.addListener(this.map, 'click', this._handleMapClick.bind(this));\n    this.listeners.push(clickListener);\n    \n    // Add mousemove listener for lines and polygons\n    if (this.options.mode === 'line' || this.options.mode === 'polygon') {\n      const moveListener = google.maps.event.addListener(this.map, 'mousemove', this._handleMapMouseMove.bind(this));\n      this.listeners.push(moveListener);\n    }\n  }\n  \n  /**\n   * Remove map event listeners\n   * @private\n   */\n  _removeMapListeners() {\n    this.listeners.forEach(listener => {\n      google.maps.event.removeListener(listener);\n    });\n    this.listeners = [];\n  }\n  \n  /**\n   * Handle map click events\n   * @param {Object} event - Google Maps click event\n   * @private\n   */\n  _handleMapClick(event) {\n    const lat = event.latLng.lat();\n    const lng = event.latLng.lng();\n    \n    console.log(`Map clicked at ${lat}, ${lng} in ${this.options.mode} mode`);\n    \n    switch (this.options.mode) {\n    case 'point':\n      this._createPoint(lat, lng);\n      break;\n        \n    case 'line':\n      this._addLineVertex(lat, lng);\n      break;\n        \n    case 'polygon':\n      this._addPolygonVertex(lat, lng);\n      break;\n    }\n  }\n  \n  /**\n   * Handle map mouse move events\n   * @param {Object} event - Google Maps mouse move event\n   * @private\n   */\n  _handleMapMouseMove(event) {\n    if (!this.isActive || this.vertices.length === 0) return;\n    \n    const lat = event.latLng.lat();\n    const lng = event.latLng.lng();\n    \n    // Update preview line/polygon\n    if (this.options.mode === 'line') {\n      this._updateLinePreview(lat, lng);\n    } else if (this.options.mode === 'polygon') {\n      this._updatePolygonPreview(lat, lng);\n    }\n  }\n  \n  /**\n   * Create a point feature\n   * @param {number} lat - Latitude\n   * @param {number} lng - Longitude\n   * @private\n   */\n  _createPoint(lat, lng) {\n    // Create marker\n    const marker = new google.maps.Marker({\n      position: { lat, lng },\n      map: this.map,\n      title: `Point (${lat.toFixed(6)}, ${lng.toFixed(6)})`,\n      animation: google.maps.Animation.DROP,\n    });\n    \n    this.markers.push(marker);\n    \n    // Emit event\n    const coordinate = new Coordinate(lat, lng, 0);\n    this.emit('featureCreated', {\n      type: 'point',\n      coordinate: coordinate,\n      marker: marker,\n    });\n    \n    // If continuousDrawing is false, deactivate the tool\n    if (!this.options.continuousDrawing) {\n      this.deactivate();\n    }\n  }\n  \n  /**\n   * Add a vertex to the line\n   * @param {number} lat - Latitude\n   * @param {number} lng - Longitude\n   * @private\n   */\n  _addLineVertex(lat, lng) {\n    // Add vertex to line\n    this.vertices.push({ lat, lng });\n    \n    // Create marker for vertex\n    const marker = new google.maps.Marker({\n      position: { lat, lng },\n      map: this.map,\n      title: `Vertex ${this.vertices.length}`,\n      icon: {\n        path: google.maps.SymbolPath.CIRCLE,\n        fillColor: this.options.lineSymbol.color,\n        fillOpacity: 1,\n        strokeWeight: 2,\n        strokeColor: '#FFFFFF',\n        scale: 6,\n      },\n    });\n    \n    this.markers.push(marker);\n    \n    // If this is the first vertex, create a new polyline\n    if (this.vertices.length === 1) {\n      this.polyline = new google.maps.Polyline({\n        path: this.vertices,\n        geodesic: true,\n        strokeColor: this.options.lineSymbol.color,\n        strokeOpacity: 1.0,\n        strokeWeight: this.options.lineSymbol.width,\n        map: this.map,\n      });\n    } else {\n      // Otherwise update the existing polyline\n      this.polyline.setPath(this.vertices);\n      \n      // If double-clicked and we have at least 2 points, complete the line\n      if (this.vertices.length >= 2) {\n        // Double-click is handled automatically by listening for two clicks in quick succession\n        const now = Date.now();\n        if (this._lastClickTime && now - this._lastClickTime < 300) {\n          this._completeLine();\n          return;\n        }\n        this._lastClickTime = now;\n      }\n    }\n  }\n  \n  /**\n   * Add a vertex to the polygon\n   * @param {number} lat - Latitude\n   * @param {number} lng - Longitude\n   * @private\n   */\n  _addPolygonVertex(lat, lng) {\n    // Add vertex to polygon\n    this.vertices.push({ lat, lng });\n    \n    // Create marker for vertex\n    const marker = new google.maps.Marker({\n      position: { lat, lng },\n      map: this.map,\n      title: `Vertex ${this.vertices.length}`,\n      icon: {\n        path: google.maps.SymbolPath.CIRCLE,\n        fillColor: this.options.polygonSymbol.outlineColor,\n        fillOpacity: 1,\n        strokeWeight: 2,\n        strokeColor: '#FFFFFF',\n        scale: 6,\n      },\n    });\n    \n    this.markers.push(marker);\n    \n    // If this is the first vertex, create a new polygon\n    if (this.vertices.length === 1) {\n      // Start with a polyline until we have 3 points\n      this.polyline = new google.maps.Polyline({\n        path: this.vertices,\n        geodesic: true,\n        strokeColor: this.options.polygonSymbol.outlineColor,\n        strokeOpacity: 1.0,\n        strokeWeight: this.options.polygonSymbol.outlineWidth,\n        map: this.map,\n      });\n    } else if (this.vertices.length === 3) {\n      // With 3 points, we can create a polygon\n      if (this.polyline) {\n        this.polyline.setMap(null);\n        this.polyline = null;\n      }\n      \n      // Create polygon\n      this.polygon = new google.maps.Polygon({\n        paths: [...this.vertices, this.vertices[0]],\n        strokeColor: this.options.polygonSymbol.outlineColor,\n        strokeOpacity: 1.0,\n        strokeWeight: this.options.polygonSymbol.outlineWidth,\n        fillColor: this.options.polygonSymbol.fillColor,\n        fillOpacity: 0.35,\n        map: this.map,\n      });\n      \n      // Double-click is handled automatically by listening for two clicks in quick succession\n      const now = Date.now();\n      if (this._lastClickTime && now - this._lastClickTime < 300) {\n        this._completePolygon();\n        return;\n      }\n      this._lastClickTime = now;\n    } else if (this.vertices.length > 3) {\n      // Update existing polygon\n      this.polygon.setPaths([...this.vertices, this.vertices[0]]);\n      \n      // Double-click is handled automatically by listening for two clicks in quick succession\n      const now = Date.now();\n      if (this._lastClickTime && now - this._lastClickTime < 300) {\n        this._completePolygon();\n        return;\n      }\n      this._lastClickTime = now;\n    } else {\n      // Update polyline\n      this.polyline.setPath(this.vertices);\n    }\n  }\n  \n  /**\n   * Update the line preview\n   * @param {number} lat - Current mouse latitude\n   * @param {number} lng - Current mouse longitude\n   * @private\n   */\n  _updateLinePreview(lat, lng) {\n    if (this.vertices.length === 0 || !this.polyline) return;\n    \n    // Create a preview path with the current vertices plus the mouse position\n    const previewPath = [...this.vertices, { lat, lng }];\n    this.polyline.setPath(previewPath);\n  }\n  \n  /**\n   * Update the polygon preview\n   * @param {number} lat - Current mouse latitude\n   * @param {number} lng - Current mouse longitude\n   * @private\n   */\n  _updatePolygonPreview(lat, lng) {\n    if (this.vertices.length === 0) return;\n    \n    if (this.vertices.length < 3) {\n      // If we have less than 3 vertices, update the polyline\n      if (this.polyline) {\n        const previewPath = [...this.vertices, { lat, lng }];\n        this.polyline.setPath(previewPath);\n      }\n    } else {\n      // If we have 3 or more vertices, update the polygon\n      if (this.polygon) {\n        const previewPath = [...this.vertices, { lat, lng }, this.vertices[0]];\n        this.polygon.setPaths(previewPath);\n      }\n    }\n  }\n  \n  /**\n   * Complete the line drawing\n   * @private\n   */\n  _completeLine() {\n    if (this.vertices.length < 2) return;\n    \n    // Create final polyline\n    const finalLine = new google.maps.Polyline({\n      path: this.vertices,\n      geodesic: true,\n      strokeColor: this.options.lineSymbol.color,\n      strokeOpacity: 1.0,\n      strokeWeight: this.options.lineSymbol.width,\n      map: this.map,\n    });\n    \n    // Emit event\n    const coordinates = this.vertices.map(v => new Coordinate(v.lat, v.lng, 0));\n    this.emit('featureCreated', {\n      type: 'line',\n      coordinates: coordinates,\n      polyline: finalLine,\n    });\n    \n    // Reset the drawing\n    this._reset();\n    \n    // If continuousDrawing is false, deactivate\n    if (!this.options.continuousDrawing) {\n      this.deactivate();\n    }\n  }\n  \n  /**\n   * Complete the polygon drawing\n   * @private\n   */\n  _completePolygon() {\n    if (this.vertices.length < 3) return;\n    \n    // Create final polygon\n    const finalPolygon = new google.maps.Polygon({\n      paths: this.vertices,\n      strokeColor: this.options.polygonSymbol.outlineColor,\n      strokeOpacity: 1.0,\n      strokeWeight: this.options.polygonSymbol.outlineWidth,\n      fillColor: this.options.polygonSymbol.fillColor,\n      fillOpacity: 0.35,\n      map: this.map,\n    });\n    \n    // Emit event\n    const coordinates = this.vertices.map(v => new Coordinate(v.lat, v.lng, 0));\n    this.emit('featureCreated', {\n      type: 'polygon',\n      coordinates: coordinates,\n      polygon: finalPolygon,\n    });\n    \n    // Reset the drawing\n    this._reset();\n    \n    // If continuousDrawing is false, deactivate\n    if (!this.options.continuousDrawing) {\n      this.deactivate();\n    }\n  }\n  \n  /**\n   * Reset the drawing state\n   * @private\n   */\n  _reset() {\n    // Clear temporary markers\n    this.markers.forEach(marker => marker.setMap(null));\n    this.markers = [];\n    \n    // Clear temporary polyline\n    if (this.polyline) {\n      this.polyline.setMap(null);\n      this.polyline = null;\n    }\n    \n    // Clear temporary polygon\n    if (this.polygon) {\n      this.polygon.setMap(null);\n      this.polygon = null;\n    }\n    \n    // Reset vertices\n    this.vertices = [];\n    \n    // Reset last click time\n    this._lastClickTime = null;\n  }\n  \n  /**\n   * Deactivate the drawing tool\n   */\n  deactivate() {\n    if (!this.isActive) return;\n    \n    // Remove listeners\n    this._removeMapListeners();\n    \n    // Reset drawing state\n    this._reset();\n    \n    // Mark as inactive\n    this.isActive = false;\n    \n    // Emit deactivation event\n    this.emit('deactivated');\n  }\n}","/**\n * GIS Survey Module - Main entry point\n *\n * This module provides a complete set of 3D-first, map-agnostic survey tools\n * for geospatial applications. It supports full 3D visualization and\n * calculations, and can optionally integrate with GNSS receivers.\n */\n\n// Import core module functionality\nimport { EventEmitter } from './core/event-emitter.js';\nimport { Coordinate } from './core/Coordinate.js';\nimport { GeometryEngine } from './core/GeometryEngine.js';\nimport { CoordinateUtils } from './core/CoordinateUtils.js';\nimport { GeoidModel } from './core/GeoidModel.js';\nimport { TransformerFactory } from './core/TransformerFactory.js';\nimport { CoordinateTransformer } from './core/CoordinateTransformer.js';\nimport { SimpleWGS84Transformer } from './core/SimpleWGS84Transformer.js';\nimport { initializeCore } from './core/index.js';\n\n// Import survey manager and tools\nimport { SurveyManager } from './tools/SurveyManager.js';\nimport { DrawingTool } from './tools/DrawingTool.js';\nimport { MeasurementTool } from './tools/MeasurementTool.js';\nimport { EditingTool } from './tools/EditingTool.js';\nimport { OffsetTool } from './tools/OffsetTool.js';\nimport { SnappingManager } from './tools/SnappingManager.js';\nimport { ToolBase } from './tools/ToolBase.js';\n\n// Import feature implementations\nimport {\n  FeatureBase,\n  PointFeature,\n  LineFeature,\n  PolygonFeature,\n  FeatureCollection,\n  createPoint,\n  createLine,\n  createPolygon,\n  createFeatureCollection,\n  importFromGeoJSON,\n} from './features/index.js';\n\n// Import map implementations\nimport {\n  MapInterface,\n  Map3DInterface,\n  ElevationService,\n  GoogleMapsAdapter,\n  LeafletAdapter,\n  GoogleMapsElevationService,\n  MapFactory,\n  LayerManager,\n  RenderingStrategy,\n  GoogleMapsRenderingStrategy,\n  createMap,\n  getSupportedProviders,\n} from './map/index.js';\n\n// Backward compatibility - Import SimplifiedDrawingTool for existing code\nimport { SimplifiedDrawingTool } from './tools/SimplifiedDrawingTool.js';\n\n/**\n * Initialize the survey module.\n *\n * @param {Object} [options] - Initialization options\n * @param {Object} [options.core] - Core module options\n * @param {Object} [options.map] - Map provider options\n * @returns {Promise<Object>} Promise that resolves to the survey interface\n */\nexport async function initialize(options = {}) {\n  // Initialize the core coordinate system and geometry engine\n  await initializeCore(options.core);\n\n  // Return an interface with core functionality implemented\n  return {\n    version: VERSION,\n    core: {\n      initialized: true,\n      Coordinate,\n      GeometryEngine,\n      GeoidModel,\n      CoordinateUtils,\n      TransformerFactory,\n    },\n  };\n}\n\n/**\n * Create a new Survey instance.\n * @param {Object} mapInstance - The map instance to use\n * @param {string} mapType - The type of map provider ('google', 'leaflet', 'cesium')\n * @param {Object} [options] - Configuration options\n * @returns {Promise<Object>} A promise that resolves to the SurveyManager instance\n */\nexport async function createSurvey(mapInstance, mapType, options = {}) {\n  // Initialize the survey module\n  await initialize(options);\n\n  // Create appropriate map adapter\n  const mapInterface = MapFactory.createMap(mapType, {\n    mapInstance,\n    ...options.mapOptions,\n  });\n\n  // Create the survey manager\n  const surveyManager = new SurveyManager({\n    mapInterface,\n    settings: {\n      enable3D: options.enable3D === undefined ? true : options.enable3D,\n      continuousDrawing: options.continuousDrawing === undefined ? true : options.continuousDrawing,\n      autoSave: options.autoSave || false,\n      undoLevels: options.undoLevels || 20,\n      elevationProvider: options.elevationProvider || 'mapInterface',\n      ...options.settings,\n    },\n  });\n\n  // Initialize layer manager if needed\n  if (options.initializeLayers !== false) {\n    const renderingStrategy = mapType === 'google' ?\n      new GoogleMapsRenderingStrategy(mapInterface) :\n      new RenderingStrategy(mapInterface);\n\n    surveyManager.layerManager = new LayerManager(mapInterface, renderingStrategy, {\n      defaultLayer: 'main',\n    });\n\n    // Create standard layers\n    surveyManager.layerManager.createLayer('points', { name: 'Points', visible: true });\n    surveyManager.layerManager.createLayer('lines', { name: 'Lines', visible: true });\n    surveyManager.layerManager.createLayer('polygons', { name: 'Polygons', visible: true });\n    surveyManager.layerManager.createLayer('working', {\n      name: 'Working Features',\n      visible: true,\n      zIndex: 1000,\n    });\n  }\n\n  return surveyManager;\n}\n\n// Export core classes\nexport {\n  Coordinate,\n  GeometryEngine,\n  GeoidModel,\n  TransformerFactory,\n  CoordinateTransformer,\n  SimpleWGS84Transformer,\n  CoordinateUtils,\n  EventEmitter,\n};\n\n// Export Feature classes and utilities\nexport {\n  FeatureBase,\n  PointFeature,\n  LineFeature,\n  PolygonFeature,\n  FeatureCollection,\n  createPoint,\n  createLine,\n  createPolygon,\n  createFeatureCollection,\n  importFromGeoJSON,\n};\n\n// Export Map classes and utilities\nexport {\n  MapInterface,\n  Map3DInterface,\n  ElevationService,\n  GoogleMapsAdapter,\n  LeafletAdapter,\n  GoogleMapsElevationService,\n  MapFactory,\n  LayerManager,\n  RenderingStrategy,\n  GoogleMapsRenderingStrategy,\n  createMap,\n  getSupportedProviders,\n};\n\n// Export Tool classes\nexport {\n  SurveyManager,\n  DrawingTool,\n  MeasurementTool,\n  EditingTool,\n  OffsetTool,\n  SnappingManager,\n  ToolBase,\n  SimplifiedDrawingTool,\n};\n\n// Export initialization functions\nexport { initializeCore };\n\n// Create a namespace for survey module\nexport const Survey = {\n  Manager: SurveyManager,\n  Core: {\n    Coordinate,\n    GeometryEngine,\n    GeoidModel,\n    CoordinateUtils,\n    TransformerFactory,\n    CoordinateTransformer,\n    SimpleWGS84Transformer,\n    EventEmitter,\n  },\n  Features: {\n    FeatureBase,\n    PointFeature,\n    LineFeature,\n    PolygonFeature,\n    FeatureCollection,\n    createPoint,\n    createLine,\n    createPolygon,\n    createFeatureCollection,\n    importFromGeoJSON,\n  },\n  Map: {\n    MapInterface,\n    Map3DInterface,\n    ElevationService,\n    GoogleMapsAdapter,\n    LeafletAdapter,\n    GoogleMapsElevationService,\n    MapFactory,\n    LayerManager,\n    RenderingStrategy,\n    GoogleMapsRenderingStrategy,\n    createMap,\n    getSupportedProviders,\n  },\n  Tools: {\n    DrawingTool,\n    MeasurementTool,\n    EditingTool,\n    OffsetTool,\n    SnappingManager,\n    ToolBase,\n    SimplifiedDrawingTool,\n  },\n};\n\n// Export version and build information\nexport const VERSION = '1.0.0';\nexport const BUILD_DATE = new Date().toISOString();"],"names":["EventEmitter","constructor","this","events","debugMode","on","event","listener","push","filter","l","addEventListener","once","remove","args","emit","data","console","log","forEach","error","off","removeEventListener","removeAllListeners","setDebug","enabled","CoordinateTransformer","Error","_transformCache","Map","_geoidCache","_datelineHandled","transform","_coordinate","_fromProjection","_toProjection","getSupportedProjections","convertEllipsoidalToOrthometric","convertOrthometricToEllipsoidal","clearCache","clear","_crossesDateLine","Math","abs","lng","_getCacheKey","coordinate","fromProjection","toProjection","lat","toFixed","elevation","_handleDateLineCrossing","_doTransform","adjustedCoord","Coordinate","heightReference","transformed","_logTransformationError","message","source","projection","elev","target","stack","GeoidModel","getHeight","_approximateUSGeoidHeight","height","sin","PI","corners","normalizedLat","normalizedLng","loadModel","modelName","warn","Promise","resolve","SimpleWGS84Transformer","super","projections","WGS84","datum","type","epsg","params","NAD83","NAD27","UTM_NAD83_N","north","UTM_NAD83_S","StatePlane_NAD83","datumShifts","WGS84_to_NAD83","dx","dy","dz","rx","ry","rz","ds","NAD83_to_NAD27","Object","keys","_validateProjection","clone","cacheKey","cached","get","result","geographicSource","geographicTarget","_utmToGeographic","_statePlaneToGeographic","sourceDatum","targetDatum","_transformDatum","_geographicToUtm","_geographicToStatePlane","set","geoidHeight","_getGeoidHeight","undefined","join","fromDatum","toDatum","_applyHelmertTransformation","_invertHelmertParams","nad83","ecef","_geographicToECEF","x2","x","y","z","y2","z2","_ecefToGeographic","e2","h","cos","N","sqrt","originalFormat","a","b","p","atan2","_params","TransformerFactory","static","setDefaultType","includes","_defaultType","getTransformer","transformerType","_instances","has","transformer","_checkForProj4js","proj4","values","isAvailable","getAllSupportedProjections","simple","proj4js","parseFloat","isNaN","max","min","safeElevation","fromObject","obj","latitude","longitude","altitude","alt","e","targetProjection","toHeightReference","reference","distanceTo","other","otherCoord","horizontalDistance","elevDiff","bearingTo","bearing","midpointTo","Bx","By","midElevation","toObject","toGeoJSON","wgs84Coord","coordinates","toString","toCompactString","setZ","Number","isFinite","CoordinateUtils","standardizeCoordinate","toCoordinate","extractStandardValues","standardized","cloneWithStandardProperties","GeometryEngine","calculateElevationGain","length","totalGain","i","prev","curr","diff","calculateElevationLoss","totalLoss","_getCoordinateClass","nearestPointOnSegment","start","end","point","calculateDistance","coord1","coord2","options","includeElevation","getLat","coord","getLng","lat1","lng1","lat2","lng2","simpleCoord1","simpleCoord2","distance2D","_calculateApproximateDistance","calculateArea","firstCoord","lastCoord","closedCoords","_isSelfIntersecting","_calculateAreaWithTriangulation","_calculate3DArea","_calculate2DSphericalArea","calculatePerimeter","perimeter","calculatePathLength","calculatePerpendicularOffset","pointIndex","segmentPosition","distance","enable3D","startPoint","endPoint","segmentFraction","nearestPoint","segmentBearing","perpendicularBearing","offsetPoint","_calculateDestinationPoint","calculateBearing","from","to","createArc","center","radiusMeters","startAngle","endAngle","segments","angleIncrement","angle","createCircle","createRectangle","widthMeters","heightMeters","rotationDegrees","rotationRadians","halfWidth","halfHeight","bearings","distances","isPointInPolygon","polygon","inside","closedPolygon","normalizedPolygon","map","j","xi","yi","xj","yj","pointInPolygon","calculateCentroid","sumLat","sumLng","sumElev","calculatePolygonCentroid","exteriorRing","holes","exteriorCentroid","validHoles","hole","exteriorArea","totalArea","weightedLat","weightedLng","weightedElev","holeCentroid","holeArea","calculatePathCenter","targetDistance","currentDistance","segmentLength","fraction","createOffsetLine","offsetMeters","closed","perpBearing","startOffset","endOffset","_findClosestPointOnLineSegment","destinationCoordinate","standardStart","earthRadius","_EARTH_RADIUS_M","bearingRad","latRad","lngRad","distRatio","sinDistRatio","cosDistRatio","sinLat1","cosLat1","sinLat2","asin","segmentStart","segmentEnd","standardPoint","standardEnd","dot","len2","t","closestLng","closestLat","closestElev","closestPoint","_lineSegmentsIntersect","p1","p2","p3","p4","pt1","pt2","pt3","pt4","d1","_direction","d2","d3","d4","_onSegment","c","hasSelfIntersections","area","_calculateSphericalTriangleArea","A","B","C","R","a1","a2","b1","b2","c1","c2","acos","_options","cartesian","_geographicToCartesian","normal","_calculateBestFitPlaneNormal","projectedPoints","_projectPointOntoPlane","crossProduct","_crossProduct","_vectorLength","points","v1","v2","_WGS84_SEMI_MAJOR_AXIS","standardCoord","sinLat","cosLat","sinLng","cosLng","planePoint","v","dist","_dotProduct","dLat","dLon","async","initializeCore","geoidModel","then","TransformerFactory$1","GeoidModel$1","FeatureBase","id","Date","now","floor","random","name","substr","style","properties","metadata","selected","visible","editable","interactive","rendered","timestamp","sourceData","getType","getBounds","getCenter","getElevationRange","contains","nearest","fromGeoJSON","_geojson","setStyle","feature","getStyle","setProperties","getProperties","getProperty","setProperty","value","setName","getName","select","deselect","toggleSelection","show","hide","toggleVisibility","enableEditing","disableEditing","setRendered","renderedObject","getRendered","isRendered","PointFeature","elevationVal","Array","isArray","getCoordinate","setCoordinate","northEast","southWest","east","south","west","range","tolerance","checkLat","checkLng","coordLat","coordLng","Infinity","includeProperties","geojson","geometry","coords","moveByDistanceAndBearing","preserveElevation","newCoord","moveTo","LineFeature","_validateCoordinates","_updateProperties","elevations","minElevation","maxElevation","elevationGain","elevationLoss","getCoordinates","setCoordinates","addCoordinate","index","splice","action","removeCoordinate","removed","updateCoordinate","oldCoord","oldCoordinate","newCoordinate","getVertexCount","getVertex","toggleClosed","setClosed","isClosed","segmentIndex","calculateNearestPointOnPath","ring","geometryType","newCoordinates","first","last","pop","clonedCoordinates","calculateLength","createElevationProfile","calculateElevationChange","gain","loss","offsetCoords","simplify","simplified","simplifyPath","createRegularPoints","interval","createRegularPointsAlongPath","getPointAtPercentage","percentage","getPointAtDistance","splitAtVertex","slice","reverse","PolygonFeature","interiorRings","holeCoords","_setupEventForwarding","ringIndex","exteriorCoords","averageElevation","reduce","sum","centroid","getHoles","getRings","concat","setRings","rings","addHole","getHole","holeIndex","removeHole","updateHole","getHoleCount","addVertex","removeVertex","updateVertex","exteriorRange","ringRange","isInterior","exteriorNearest","minDistance","holeNearest","exteriorRingCoords","equals","clonedExteriorCoords","clonedHoles","includeHoles","simplifiedExterior","simplifiedHoles","buffer","bufferedExterior","bufferPolygon","isValid","holeCenter","doPathsIntersect","otherHole","otherHoleCoords","calculate3DSurfaceArea","calculate3DPolygonSurfaceArea","calculateVolume","baseElevation","calculatePolygonVolume","FeatureCollection","features","addFeature","collection","removeFeature","featureOrId","featureId","delete","getFeature","hasFeature","getAllFeatures","getFeaturesByType","findFeatures","predicate","getFeatureCount","size","getFeatureCountsByType","counts","selectAll","deselectAll","getSelectedFeatures","setAllVisible","getVisibleFeatures","includeHidden","importCount","featureJson","err","count","firstBounds","bounds","applyStyleToAll","findFeaturesAt","getFeaturesAtPosition","screenPosition","mapInterface","featureCoord","featureScreenPos","coordinateToPixel","pow","findNearestFeature","featureType","nearestFeature","maxDistance","updateFeature","ToolBase","manager","geometryEngine","isActive","workingData","_setupEventListeners","activate","activationOptions","assign","_activate","deactivate","_deactivate","reset","_reset","updateOptions","_optionsUpdated","destroy","_destroy","MeasurementTool","mode","units","areaUnits","volumeUnits","continuousMeasure","showSegmentLengths","showTotalLength","lineSymbol","settings","defaultLineSymbol","pointSymbol","defaultPointSymbol","labelStyle","font","fillColor","strokeColor","strokeWidth","activeMeasurement","measurements","mousePosition","hoverCoordinate","measurementLabels","segmentLabels","_handleMapClick","bind","_handleMapMouseMove","_handleMapDoubleClick","_handleMapRightClick","_handleKeyDown","_activateMeasurementMode","document","_createNewMeasurement","_clearTemporaryMeasurements","_clearActiveMeasurement","measurementType","temporary","defaultPolygonSymbol","outlineColor","color","outlineWidth","width","workingFeatures","_clearMeasurementLabels","measurement","label","removeLabel","_addPointToMeasurement","_updateMeasurementDisplay","_updateMeasurementPreview","originalEvent","preventDefault","_completeMeasurement","key","_removeLastPoint","pointFeature","measurementId","applyElevationData","_updateMeasurementGeometry","lastPoint","polygonCoordinates","previewCoordinates","preview","measurementValue","measurementUnit","segmentValues","lineCoordinates","_calculateDistance","_calculateSegmentDistances","areaCoordinates","_calculateArea","perimeterCoords","volumeCoordinates","_calculateVolume","formattedValue","_formatMeasurementValue","unit","vertices","labelPosition","_calculateLabelPosition","measurementLabel","createLabel","position","text","segment","_index","formattedSegment","segmentLabel","midpoint","getCentroid","minPoints","finalMeasurement","areaRings","volumeRings","totalDistance","_convertDistance","segmentDistance","convertedDistance","closedCoordinates","_convertArea","volume","_calculateVolumeDirectly","_convertVolume","baseArea","totalHeight","validPoints","fromUnit","toUnit","meters","squareMeters","cubicMeters","unitDisplay","round","setMode","setUnits","setEnable3D","enable","completeMeasurement","getMeasurements","clearAllMeasurements","OffsetTool","defaultDistance","defaultBearing","distanceSnap","bearingSnap","sourceSymbol","targetSymbol","dashArray","previewSymbol","sourceFeature","targetFeature","previewFeature","offsetLine","offsetDistance","offsetBearing","selectedPoint","snapEnabled","_handleFeatureSelected","_setOffsetMode","_clearPreviewFeatures","currentBearing","currentMode","_createOffsetPoint","_updatePointOffsetPreview","_createSourcePoint","isTemporary","_addPointToSourceLine","_createOffsetFromLine","selectedLine","find","f","_updateLineOffsetPreview","_startCreatingSourceLine","_updateTemporarySourceLine","_completeSourceLine","_cancelSourceLine","parseInt","shiftKey","setOffsetDistance","adjustOffsetBearing","adjustOffsetDistance","sourcePoint","sourceCoord","mouseBearing","offsetCoord","sourceCoordinate","targetCoordinate","sourceFeatureId","sourceLine","line","previewCoords","sourceCoords","nearestInfo","perpendicular","perpendicularInfo","offsetFeature","setOffsetBearing","amount","newDistance","newBearing","toggleSnap","getSettings","DrawingTool","continuousDrawing","freehandSamplingInterval","useDualMarker","previewLineSymbol","opacity","polygonSymbol","previewPolygonSymbol","vertexSymbol","activeVertexSymbol","activeFeature","isDragging","lastFreehandPoint","_handleMapMouseDown","_handleMapMouseUp","_startNewDrawing","_clearActiveDrawing","_completeDrawing","drawingType","isPreview","initialCoords","vertex","hasCoordinate","hasLatLng","latLng","hasOriginalEvent","hasPixel","pixel","snappingManager","getSnapPoint","_createPoint","_addVertex","setTimeout","getCoordinateFromPixel","clientX","clientY","debug","_handleFreehandDrawing","_updatePreview","button","_addFreehandPoint","_event","finalCoordinate","_removeLastVertex","validCoord","pointStyle","pointId","JSON","stringify","deactivateActiveTool","enhancedVertexStyle","vertexFeature","drawingId","vertexIndex","lastUpdate","workingFeatureCount","lineFeatures","pointFeatures","pointCoordinate","mouseCoordinate","lastPreviewUpdate","lastVertex","vertexCount","finalFeature","startLat","startLng","endLat","endLng","centerLat","centerLng","freehandCoords","featureCount","tryCompleteCurrentDrawing","setContinuousDrawing","setFreehandSamplingInterval","EditingTool","vertexDistanceTolerance","allowVertexAddition","allowVertexDeletion","snapToTerrain","dragDistanceThreshold","selectedVertexSymbol","insertionVertexSymbol","originalFeature","insertionVertices","selectedVertex","dragStartPosition","operationMode","operationComplete","draggedDistance","snapTargets","_updateVertexControls","selectedFeatures","_startEditingFeature","_completeEditing","_clearVertexControls","_findVertexAtPosition","_selectVertex","insertionVertex","_findInsertionVertexAtPosition","_addVertexAtInsertion","_isPositionOnFeature","_stopEditingFeature","_selectFeatureAtPosition","_handleDrag","_highlightVertex","setCursor","_highlightInsertionVertex","_deleteSelectedVertex","_cancelDrag","_deselectVertex","_cancelEditing","_createVertexControls","_applyEditingStyle","_restoreOriginalStyle","originalStyle","_createVertexFeature","_createInsertionVertices","ringVertices","isSelected","segmentCount","interpolate","startVertex","endVertex","closestVertex","closestDistance","vertexScreenPos","lineCoords","nearestScreenPos","containsPoint","editableFeatures","selectFeature","currentStyle","startIndex","endIndex","beforeIndex","afterIndex","startScreenPos","_moveSelectedVertex","_moveFeature","startElevation","currentLat","currentLng","currentElevation","offset","pointCoord","pointLat","pointLng","pointElevation","newLineCoords","newRings","setAllowVertexAddition","allow","setAllowVertexDeletion","setSnapToTerrain","SnappingManager","snapToVertex","snapToEdge","snapToGrid","gridSize","highlightSnap","includeTemporaryFeatures","vertexSnapSymbol","edgeSnapSymbol","gridSnapSymbol","state","currentSnap","snapIndicator","snapSourceFeature","lastMousePosition","_clearSnap","setSnapTargets","targets","targetArray","clearSnapTargets","setSnapSourceFeature","snap","_findSnapPoint","_updateSnap","_findVertexSnap","_findEdgeSnap","_findGridSnap","_getSnapFeatures","bestDistance","bestSnap","vertexPixel","isSnapped","nearestPixel","gridSizeLat","gridSizeLng","validWorkingFeatures","_createSnapIndicator","wasSnapped","symbol","indicator","snapType","snapPointAt","setSnapToVertex","setSnapToEdge","setSnapToGrid","setGridSize","setTolerance","SurveyManager","autoSave","undoLevels","elevationProvider","snapTolerance","history","undoStack","redoStack","maxSize","activeTool","activeMode","isDrawing","isEditing","isMeasuring","projectName","created","modified","owner","description","customProperties","_initializeTools","tools","drawing","editing","snappingActive","_recordHistoryAction","featureData","previousData","_lastFeatureState","activateTool","toolName","tool","shift","canUndo","canRedo","undo","silent","redo","saveState","surveyData","loadState","featureObj","toggle","deselectFeature","addToSelection","clearSelection","featureArray","getElevation","connectGnssModule","gnssModule","gnssOptions","centerMapOnPosition","trackedPositionMarker","trackedPositionMarkerStyle","accuracyCircle","qualityIndicator","_setupGnssEventHandlers","_createPositionMarker","_handlePositionUpdate","currentPosition","positionMarker","_updatePositionMarker","setCenter","createMarker","zIndex","strokeWeight","_getPositionStyleByQuality","quality","setPosition","setVisible","accuracy","setRadius","baseStyle","captureGnssPosition","PointFeature$1","Coordinate$1","toLocaleTimeString","satellites","toISOString","disconnectGnssModule","setMap","createPoint","require","createLine","createPolygon","createFeatureCollection","importFromGeoJSON","_createFeatureFromGeoJSON","Boolean","MapInterface","_cursorType","initialize","_container","setZoom","_zoomLevel","addMarker","removeMarker","_marker","addPolyline","_coordinates","removePolyline","_polyline","addPolygon","removePolygon","_polygon","fitBounds","_bounds","_eventType","_listener","_listenerHandle","getElevationsForPath","pixelToCoordinate","_pixel","Map3DInterface","setTilt","_angle","setHeading","getCameraPosition","setCameraPosition","_position","addModel","removeModel","_model","addTerrain","removeTerrain","setTerrainExaggeration","_factor","ElevationService","getElevationsForLocations","GoogleMapsAdapter","mapInstance","apiLoaded","window","google","maps","apiKey","mapOptions","zoom","mapTypeId","mapTypeControl","fullscreenControl","streetViewControl","eventListeners","cursorType","getDiv","cursor","_loadGoogleMapsAPI","reject","callbackName","script","createElement","src","defer","onerror","head","appendChild","container","element","getElementById","addListenerOnce","_toLatLng","LatLng","_toCoordinate","zoomLevel","markerOptions","title","icon","draggable","marker","Marker","polylineOptions","path","strokeOpacity","polyline","Polyline","originalCoordinates","polygonOptions","paths","fillOpacity","Polygon","ne","getNorthEast","sw","getSouthWest","googleBounds","LatLngBounds","extend","fitOptions","padding","eventType","googleEventType","lastMoveTime","lastClickTime","handle","addListener","placeId","normalizedOriginalEvent","domEvent","stopPropagation","convertedEvent","getProjection","fromLatLngToPoint","scale","getZoom","worldPoint","Point","mapBounds","getBoundingClientRect","left","scrollX","top","scrollY","listenerOrHandle","removeListener","elevationService","locations","getElevationForLocations","results","status","ElevationStatus","OK","samples","getElevationAlongPath","topLeft","fromPointToLatLng","_labels","fontStyle","LabelOverlay","OverlayView","div","onAdd","borderRadius","backgroundColor","textShadow","whiteSpace","userSelect","pointerEvents","innerHTML","getPanes","overlayLayer","draw","fromLatLngToDivPixel","onRemove","parentNode","removeChild","setText","indexOf","LeafletAdapter","minZoom","maxZoom","tileLayerUrl","tileLayerOptions","attribution","getContainer","_loadLeafletAPI","L","loadCSS","link","rel","href","integrity","crossOrigin","onload","loadJS","all","tileLayer","addTo","setView","iconUrl","iconSize","iconAnchor","popupAnchor","removeLayer","latLngs","weight","leafletBounds","latLngBounds","animate","leafletEventType","handlerFunction","latlng","latLngToContainerPoint","containerPointToLatLng","GoogleMapsElevationService","batches","flat","MapFactory$1","createMap","providerType","toLowerCase","isProviderAvailable","getSupportedProviders","RenderingStrategy","renderPoint","_feature","renderLine","renderPolygon","_renderedFeature","_updatedFeature","highlightFeature","unhighlightFeature","GoogleMapsRenderingStrategy","googleMap","renderedFeatures","defaultPointStyle","_isAdvancedMarkerAvailable","iconConfig","_createMarkerIcon","gmpDraggable","content","AdvancedMarkerElement","onClick","selectable","stopImmediatePropagation","renderedFeature","_handleFeatureClick","defaultLineStyle","singleCoord","geodesic","clickable","stop","defaultPolygonStyle","outlineOpacity","renderFeatureByType","mapObject","updatedFeature","originalStyles","_storeOriginalStyles","_highlightMarker","_highlightPolyline","_highlightPolygon","_unhighlightMarker","_unhighlightPolyline","_unhighlightPolygon","boxShadow","highlightColor","_originalStyles","transition","setOptions","onFeatureClick","_getFeatureType","_getQualityColor","showPinAndDot","svg","createElementNS","setAttribute","dotElement","border","img","circleDiv","boxSizing","margin","showCrosshair","hLine","vLine","LayerManager","renderingStrategy","layers","defaultLayer","createLayer","_setupFeatureEventListeners","catch","layerId","layer","removePromises","setLayerVisibility","promises","highlighted","existingFeature","updatedRenderedFeature","getLayers","getLayer","getLayerFeatures","fitLayerToView","allCoordinates","featureCoords","_getFeatureCoordinates","provider","MapFactory","SimplifiedDrawingTool","listeners","currentFeature","markers","_addMapListeners","_removeMapListeners","clickListener","moveListener","_addLineVertex","_addPolygonVertex","_updateLinePreview","_updatePolygonPreview","animation","Animation","DROP","SymbolPath","CIRCLE","setPath","_lastClickTime","_completeLine","_completePolygon","setPaths","previewPath","finalLine","finalPolygon","core","version","VERSION","initialized","Survey","Manager","Core","Features","Tools","BUILD_DATE","mapType","surveyManager","initializeLayers","layerManager"],"mappings":";;;;;;;;iPAKO,MAAMA,EACX,WAAAC,GACEC,KAAKC,OAAS,CAAE,EAChBD,KAAKE,WAAY,CACrB,CAQE,EAAAC,CAAGC,EAAOC,GAQR,OAPKL,KAAKC,OAAOG,KACfJ,KAAKC,OAAOG,GAAS,IAGvBJ,KAAKC,OAAOG,GAAOE,KAAKD,GAGjB,KACLL,KAAKC,OAAOG,GAASJ,KAAKC,OAAOG,GAAOG,QAAOC,GAAKA,IAAMH,GAAS,CAEzE,CAOE,gBAAAI,CAAiBL,EAAOC,GACtB,OAAOL,KAAKG,GAAGC,EAAOC,EAC1B,CAOE,IAAAK,CAAKN,EAAOC,GACV,MAAMM,EAASX,KAAKG,GAAGC,GAAO,IAAIQ,KAChCD,IACAN,KAAYO,EAAK,GAEvB,CAOE,IAAAC,CAAKT,EAAOU,GACNd,KAAKE,WACPa,QAAQC,IAAI,kBAAkBZ,KAAUU,GAGtCd,KAAKC,OAAOG,IACdJ,KAAKC,OAAOG,GAAOa,SAAQZ,IACzB,IACEA,EAASS,EACV,CAAC,MAAOI,GACPH,QAAQG,MAAM,gCAAgCd,MAAWc,EACnE,IAGA,CAOE,GAAAC,CAAIf,EAAOC,GACLL,KAAKC,OAAOG,KACdJ,KAAKC,OAAOG,GAASJ,KAAKC,OAAOG,GAAOG,QAAOC,GAAKA,IAAMH,IAEhE,CAOE,mBAAAe,CAAoBhB,EAAOC,GACzB,OAAOL,KAAKmB,IAAIf,EAAOC,EAC3B,CAME,kBAAAgB,CAAmBjB,GACbA,SACKJ,KAAKC,OAAOG,GAEnBJ,KAAKC,OAAS,CAAE,CAEtB,CAME,QAAAqB,CAASC,GACPvB,KAAKE,UAAYqB,CACrB,ECjGO,MAAMC,EAKX,WAAAzB,GACE,GAAIC,KAAKD,cAAgByB,EACvB,MAAM,IAAIC,MAAM,kFAIlBzB,KAAK0B,gBAAkB,IAAIC,IAC3B3B,KAAK4B,YAAc,IAAID,IACvB3B,KAAK6B,kBAAmB,CAC5B,CAUE,SAAAC,CAAUC,EAAaC,EAAiBC,GACtC,MAAM,IAAIR,MAAM,uDACpB,CAOE,uBAAAS,GACE,MAAM,IAAIT,MAAM,qEACpB,CAQE,+BAAAU,CAAgCJ,GAC9B,MAAM,IAAIN,MAAM,6EACpB,CAQE,+BAAAW,CAAgCL,GAC9B,MAAM,IAAIN,MAAM,6EACpB,CAKE,UAAAY,GACErC,KAAK0B,gBAAgBY,QACrBtC,KAAK4B,YAAYU,OACrB,CAUE,gBAAAC,CAAiBR,EAAaC,EAAiBC,GAG7C,OAAIO,KAAKC,IAAIV,EAAYW,KAAO,GAKpC,CAUE,YAAAC,CAAaC,EAAYC,EAAgBC,GAMvC,MAAO,GAJKF,EAAWG,IAAIC,QAAQ,MACvBJ,EAAWF,IAAIM,QAAQ,MACtBJ,EAAWK,UAAUD,QAAQ,MAEVH,KAAkBC,GACtD,CAUE,uBAAAI,CAAwBN,EAAYC,EAAgBC,GAElD,GAAI9C,KAAK6B,iBAEP,OADA7B,KAAK6B,kBAAmB,EACjB7B,KAAKmD,aAAaP,EAAYC,EAAgBC,GAMvD,IAAIM,EAHJpD,KAAK6B,kBAAmB,EAMtBuB,EAFER,EAAWF,IAAM,EAEH,IAAIW,EAClBT,EAAWG,IACXH,EAAWF,IAAM,IACjBE,EAAWK,UACXL,EAAWU,gBACXT,GAIc,IAAIQ,EAClBT,EAAWG,IACXH,EAAWF,IAAM,IACjBE,EAAWK,UACXL,EAAWU,gBACXT,GAKJ,MAAMU,EAAcvD,KAAK8B,UAAUsB,EAAeP,EAAgBC,GAUlE,OAPIS,EAAYb,SACda,EAAYb,KAAO,IACVa,EAAYb,IAAM,MAC3Ba,EAAYb,KAAO,KAGrB1C,KAAK6B,kBAAmB,EACjB0B,CACX,CAUE,uBAAAC,CAAwBtC,EAAO0B,EAAYC,EAAgBC,GACzD/B,QAAQG,MAAM,yBAAyBA,EAAMuC,UAAW,CACtDC,OAAQ,CACNC,WAAYd,EACZE,IAAKH,EAAWG,IAChBL,IAAKE,EAAWF,IAChBkB,KAAMhB,EAAWK,WAEnBY,OAAQf,EACR5B,MAAOA,EAAM4C,OAEnB,EC1KO,MAAMC,EASX,gBAAOC,CAAUjB,EAAKL,GASpB,GAAIK,GAAS,IAAIA,EAAM,IAAML,GAAU,KAAIA,EAAM,IAC/C,MAAM,IAAIjB,MAAM,wBAAwBsB,MAAQL,KAIlD,GAAIK,GAAO,IAAMA,GAAO,IAAML,IAAW,KAAIA,OAC3C,OAAO1C,KAAKiE,0BAA0BlB,EAAKL,GAI7C,IAAIwB,EAAS,EAMXA,EADEnB,GAAO,GAAKA,GAAO,GACLA,EAAM,GAAM,GAAnB,GAEOA,GAAM,GAAO,GAApB,GAOX,OAFAmB,GAD0D,EAAxC1B,KAAK2B,KAAKzB,EAAM,KAAOF,KAAK4B,GAAK,KAG5CF,CACX,CASE,gCAAOD,CAA0BlB,EAAKL,GAGpC,MAAM2B,EAAU,CACd,CAAEtB,IAAK,GAAIL,KAAK,IAAMwB,QAAQ,MAC9B,CAAEnB,IAAK,GAAIL,KAAK,GAAKwB,QAAQ,MAC7B,CAAEnB,IAAK,GAAIL,KAAK,IAAMwB,QAAQ,MAC9B,CAAEnB,IAAK,GAAIL,KAAK,GAAKwB,QAAQ,KAIzBI,GAAiBvB,EAAM,IAAO,GAC9BwB,GAAiB7B,IAAO,KAAK,GAWnC,OARW2B,EAAQ,GAAGH,QAAU,EAAIK,GAAiBF,EAAQ,GAAGH,OAASK,IAG/C,EAAID,IAFnBD,EAAQ,GAAGH,QAAU,EAAIK,GAAiBF,EAAQ,GAAGH,OAASK,GAErBD,EAG7B9B,KAAK2B,IAAU,EAANpB,GAAWP,KAAK2B,IAAU,EAANzB,GAAW,GAGnE,CASE,sBAAa8B,CAAUC,GAErB,OADA1D,QAAQ2D,KAAK,yBAAyBD,2CAC/BE,QAAQC,SAAQ,EAC3B,qDCxFO,MAAMC,UAA+BrD,EAI1C,WAAAzB,GACE+E,QAGA9E,KAAK+E,YAAc,CACjBC,MAAS,CACPC,MAAO,QACPC,KAAM,aACNC,KAAM,OACNC,OAAQ,CAAE,GAEZC,MAAS,CACPJ,MAAO,QACPC,KAAM,aACNC,KAAM,OACNC,OAAQ,CAAE,GAEZE,MAAS,CACPL,MAAO,QACPC,KAAM,aACNC,KAAM,OACNC,OAAQ,CAAE,GAEZG,YAAe,CACbN,MAAO,QACPC,KAAM,MACNE,OAAQ,CAAEI,OAAO,IAEnBC,YAAe,CACbR,MAAO,QACPC,KAAM,MACNE,OAAQ,CAAEI,OAAO,IAEnBE,iBAAoB,CAClBT,MAAO,QACPC,KAAM,aACNE,OAAQ,CAAE,IAKdpF,KAAK2F,YAAc,CACjBC,eAAkB,CAChBC,GAAI,OACJC,IAAY,QACZC,IAAY,OACZC,GAAI,QACJC,GAAI,QACJC,GAAI,QACJC,IAAY,OAEdC,eAAkB,CAGhBP,IAAQ,EACRC,GAAI,IACJC,GAAI,KAGZ,CAME,uBAAA7D,GACE,OAAOmE,OAAOC,KAAKtG,KAAK+E,YAC5B,CAUE,SAAAjD,CAAUc,EAAYC,EAAgBC,GAMpC,GAJA9C,KAAKuG,oBAAoB1D,GACzB7C,KAAKuG,oBAAoBzD,GAGrBD,IAAmBC,EACrB,OAAOF,EAAW4D,QAIpB,MAAMC,EAAWzG,KAAK2C,aAAaC,EAAYC,EAAgBC,GACzD4D,EAAS1G,KAAK0B,gBAAgBiF,IAAIF,GACxC,GAAIC,EACF,OAAOA,EAIT,GAAI1G,KAAKuC,iBAAiBK,EAAYC,EAAgBC,GACpD,OAAO9C,KAAKkD,wBAAwBN,EAAYC,EAAgBC,GAIlE,IAAI8D,EAEJ,IAEE,IAAIC,EAYAC,EAXJ,GAA8C,eAA1C9G,KAAK+E,YAAYlC,GAAgBqC,KACnC2B,EAAmBjE,EAAW4D,aACzB,GAA8C,QAA1CxG,KAAK+E,YAAYlC,GAAgBqC,KAC1C2B,EAAmB7G,KAAK+G,iBAAiBnE,EAAY5C,KAAK+E,YAAYlC,GAAgBuC,YACjF,IAA8C,eAA1CpF,KAAK+E,YAAYlC,GAAgBqC,KAG1C,MAAM,IAAIzD,MAAM,gCAAgCzB,KAAK+E,YAAYlC,GAAgBqC,QAFjF2B,EAAmB7G,KAAKgH,wBAAwBpE,EAGxD,CAIM,MAAMqE,EAAcjH,KAAK+E,YAAYlC,GAAgBoC,MAC/CiC,EAAclH,KAAK+E,YAAYjC,GAAcmC,MASnD,GANE6B,EADEG,IAAgBC,EACCL,EAEA7G,KAAKmH,gBAAgBN,EAAkBI,EAAaC,GAI7B,eAAxClH,KAAK+E,YAAYjC,GAAcoC,KACjC0B,EAASE,EAAiBN,QAC1BI,EAAOjD,WAAab,OACf,GAA4C,QAAxC9C,KAAK+E,YAAYjC,GAAcoC,KACxC0B,EAAS5G,KAAKoH,iBAAiBN,EAAkB9G,KAAK+E,YAAYjC,GAAcsC,QAChFwB,EAAOjD,WAAab,MACf,IAA4C,eAAxC9C,KAAK+E,YAAYjC,GAAcoC,KAIxC,MAAM,IAAIzD,MAAM,gCAAgCzB,KAAK+E,YAAYjC,GAAcoC,QAH/E0B,EAAS5G,KAAKqH,wBAAwBP,GACtCF,EAAOjD,WAAab,CAG5B,CAKM,OAFA9C,KAAK0B,gBAAgB4F,IAAIb,EAAUG,GAE5BA,CACR,CAAC,MAAO1F,GAEP,MADAlB,KAAKwD,wBAAwBtC,EAAO0B,EAAYC,EAAgBC,GAC1D,IAAIrB,MAAM,8BAA8BoB,QAAqBC,MAAiB5B,EAAMuC,UAChG,CACA,CAOE,+BAAAtB,CAAgCS,GAC9B,MAAM2E,EAAcvH,KAAKwH,gBAAgB5E,EAAWG,IAAKH,EAAWF,KAEpE,OAAO,IAAIW,EACTT,EAAWG,IACXH,EAAWF,IACXE,EAAWK,UAAYsE,EACvB,cACA3E,EAAWe,WAEjB,CAOE,+BAAAvB,CAAgCQ,GAC9B,MAAM2E,EAAcvH,KAAKwH,gBAAgB5E,EAAWG,IAAKH,EAAWF,KAEpE,OAAO,IAAIW,EACTT,EAAWG,IACXH,EAAWF,IACXE,EAAWK,UAAYsE,EACvB,cACA3E,EAAWe,WAEjB,CASE,eAAA6D,CAAgBzE,EAAKL,GAEnB,MAAM+D,EAAW,GAAG1D,EAAIC,QAAQ,MAAMN,EAAIM,QAAQ,KAC5C0D,EAAS1G,KAAK4B,YAAY+E,IAAIF,GACpC,QAAegB,IAAXf,EACF,OAAOA,EAIT,MAAMa,EAAcxD,EAAWC,UAAUjB,EAAKL,GAK9C,OAFA1C,KAAK4B,YAAY0F,IAAIb,EAAUc,GAExBA,CACX,CAQE,mBAAAhB,CAAoB5C,GAClB,IAAK3D,KAAK+E,YAAYpB,GACpB,MAAM,IAAIlC,MAAM,2BAA2BkC,iCAA0C3D,KAAKkC,0BAA0BwF,KAAK,QAE/H,CAUE,eAAAP,CAAgBvE,EAAY+E,EAAWC,GACrC,GAAID,IAAcC,EAChB,OAAOhF,EAAW4D,QAIpB,GAAkB,UAAdmB,GAAqC,UAAZC,EAC3B,OAAO5H,KAAK6H,4BAA4BjF,EAAY5C,KAAK2F,YAAYC,gBAGvE,GAAkB,UAAd+B,GAAqC,UAAZC,EAC3B,OAAO5H,KAAK6H,4BAA4BjF,EAAY5C,KAAK8H,qBAAqB9H,KAAK2F,YAAYC,iBAGjG,GAAkB,UAAd+B,GAAqC,UAAZC,EAC3B,OAAO5H,KAAK6H,4BAA4BjF,EAAY5C,KAAK2F,YAAYS,gBAGvE,GAAkB,UAAduB,GAAqC,UAAZC,EAC3B,OAAO5H,KAAK6H,4BAA4BjF,EAAY5C,KAAK8H,qBAAqB9H,KAAK2F,YAAYS,iBAGjG,GAAkB,UAAduB,GAAqC,UAAZC,EAAqB,CAEhD,MAAMG,EAAQ/H,KAAKmH,gBAAgBvE,EAAY,QAAS,SACxD,OAAO5C,KAAKmH,gBAAgBY,EAAO,QAAS,QAClD,CAEI,GAAkB,UAAdJ,GAAqC,UAAZC,EAAqB,CAEhD,MAAMG,EAAQ/H,KAAKmH,gBAAgBvE,EAAY,QAAS,SACxD,OAAO5C,KAAKmH,gBAAgBY,EAAO,QAAS,QAClD,CAEI,MAAM,IAAItG,MAAM,qCAAqCkG,QAAgBC,IACzE,CASE,2BAAAC,CAA4BjF,EAAYwC,GAEtC,MAAM4C,EAAOhI,KAAKiI,kBAAkBrF,GAG9BiD,EAAKT,EAAOS,IAAM,EAClBC,EAAKV,EAAOU,IAAM,EAClBC,EAAKX,EAAOW,IAAM,EAClBC,GAAMZ,EAAOY,IAAM,GAAKxD,KAAK4B,GAAE,MAC/B6B,GAAMb,EAAOa,IAAM,GAAKzD,KAAK4B,SAC7B8B,GAAMd,EAAOc,IAAM,GAAK1D,KAAK4B,SAC7B+B,GAAMf,EAAOe,IAAM,GAAK,IAExB+B,GAAM,EAAI/B,IAAO6B,EAAKG,EAAIjC,EAAK8B,EAAKI,EAAInC,EAAK+B,EAAKK,GAAKxC,EACvDyC,GAAM,EAAInC,KAAQD,EAAK8B,EAAKG,EAAIH,EAAKI,EAAIpC,EAAKgC,EAAKK,GAAKvC,EACxDyC,GAAM,EAAIpC,IAAOF,EAAK+B,EAAKG,EAAInC,EAAKgC,EAAKI,EAAIJ,EAAKK,GAAKtC,EAG7D,OAAO/F,KAAKwI,kBAAkB,CAAEL,EAAGD,EAAIE,EAAGE,EAAID,EAAGE,GAAM3F,EAAWU,gBACtE,CAQE,oBAAAwE,CAAqB1C,GACnB,MAAO,CACLS,KAAMT,EAAOS,IAAM,GACnBC,KAAMV,EAAOU,IAAM,GACnBC,KAAMX,EAAOW,IAAM,GACnBC,KAAMZ,EAAOY,IAAM,GACnBC,KAAMb,EAAOa,IAAM,GACnBC,KAAMd,EAAOc,IAAM,GACnBC,KAAMf,EAAOe,IAAM,GAEzB,CAQE,iBAAA8B,CAAkBrF,GAChB,MACM6F,EAAK,gBAGL1F,OAAyB0E,IAAnB7E,EAAWG,IAAoBH,EAAWG,IAAMH,EAAWwF,EACjE1F,OAAyB+E,IAAnB7E,EAAWF,IAAoBE,EAAWF,IAAME,EAAWuF,EACjElF,OAAqCwE,IAAzB7E,EAAWK,UAA0BL,EAAWK,eAC9CwE,IAAjB7E,EAAWyF,EAAkBzF,EAAWyF,EAAI,EAG/C,QAAYZ,IAAR1E,QAA6B0E,IAAR/E,EACvB,MAAM,IAAIjB,MAAM,qDAGlB,MAAM,EAAIsB,EAAMP,KAAK4B,GAAK,IACpB,EAAI1B,EAAMF,KAAK4B,GAAK,IACpBsE,EAAIzF,EAEJ,EAAOT,KAAK2B,IAAI,GAChB,EAAO3B,KAAKmG,IAAI,GAChB,EAAOnG,KAAK2B,IAAI,GAChB,EAAO3B,KAAKmG,IAAI,GAEhBC,EAvBI,QAuBIpG,KAAKqG,KAAK,EAAIJ,EAAK,EAAO,GAOxC,MAAO,CACLN,GANSS,EAAIF,GAAK,EAAO,EAMtBN,GALMQ,EAAIF,GAAK,EAAO,EAKnBL,GAJGO,GAAK,EAAIH,GAAMC,GAAK,EAK7B3F,MAAKL,MAAKO,YACV6F,eAAgB,aAEtB,CASE,iBAAAN,CAAkBR,EAAM1E,GACtB,MAAMyF,EAAI,QACJN,EAAK,gBACLO,EAAID,EAAIvG,KAAKqG,KAAK,EAAIJ,GAGtBN,EAAIH,EAAKG,EACTC,EAAIJ,EAAKI,EACTC,EAAIL,EAAKK,EAGf,QAAUZ,IAANU,QAAyBV,IAANW,QAAyBX,IAANY,EACxC,MAAM,IAAI5G,MAAM,yDAGlB,MAAMwH,EAAIzG,KAAKqG,KAAKV,EAAEA,EAAIC,EAAEA,GACtB,EAAI5F,KAAK0G,MAAMb,EAAIU,EAAGE,EAAID,GAE1B,EAAOxG,KAAK2B,IAAI,GAChB,EAAO3B,KAAKmG,IAAI,GAEhB,EAAInG,KAAK0G,MACbb,EAAII,EAAKO,EAAI,EAAO,EAAO,EAC3BC,EAAIR,EAAKM,EAAI,EAAO,EAAO,GAGvB,EAAIvG,KAAK0G,MAAMd,EAAGD,GAElB,EAAO3F,KAAK2B,IAAI,GAChByE,EAAIG,EAAIvG,KAAKqG,KAAK,EAAIJ,EAAK,EAAO,GAElCC,EAAIO,EAAIzG,KAAKmG,IAAI,GAAKC,EAEtB7F,EAAU,IAAJ,EAAUP,KAAK4B,GACrB1B,EAAU,IAAJ,EAAUF,KAAK4B,GAG3B,OAAO,IAAIf,EAAWN,EAAKL,EAAKgG,EAAGpF,EACvC,CASE,gBAAAyD,CAAiBhF,EAAaoH,GAS5B,MAAM,IAAI1H,MAAM,+EACpB,CASE,gBAAA2F,CAAiBrF,EAAaoH,GAK5B,MAAM,IAAI1H,MAAM,+EACpB,CAQE,uBAAAuF,CAAwBjF,GAKtB,MAAM,IAAIN,MAAM,uFACpB,CAQE,uBAAA4F,CAAwBtF,GAKtB,MAAM,IAAIN,MAAM,uFACpB,ECrdO,MAAM2H,EAEXC,kBAAoB,IAAI1H,IAGxB0H,oBAAsB,SAMtB,qBAAOC,CAAepE,GACpB,IAAK,CAAC,SAAU,WAAWqE,SAASrE,GAClC,MAAM,IAAIzD,MAAM,6BAA6ByD,oCAG/ClF,KAAKwJ,aAAetE,CACxB,CAOE,qBAAOuE,CAAevE,EAAO,MAC3B,MAAMwE,EAAkBxE,GAAQlF,KAAKwJ,aAGrC,GAAIxJ,KAAK2J,WAAWC,IAAIF,GACtB,OAAO1J,KAAK2J,WAAWhD,IAAI+C,GAI7B,IAAIG,EAEJ,OAAQH,GACR,IAAK,SACHG,EAAc,IAAIhF,EAClB,MAEF,IAAK,UAKH,MAHA7E,KAAK8J,mBAGC,IAAIrI,MAAM,kEAElB,QACE,MAAM,IAAIA,MAAM,6BAA6BiI,KAM/C,OAFA1J,KAAK2J,WAAWrC,IAAIoC,EAAiBG,GAE9BA,CACX,CAME,uBAAOC,GAEL,MAAqB,oBAAVC,QACThJ,QAAQ2D,KAAK,yIAEN,EAGb,CAKE,iBAAOrC,GAEL,IAAK,MAAMwH,KAAe7J,KAAK2J,WAAWK,SACxCH,EAAYxH,aAGdrC,KAAK2J,WAAWrH,OACpB,CAOE,kBAAO2H,CAAY/E,GACjB,OAAQA,GACR,IAAK,SACH,OAAO,EAET,IAAK,UACH,OAAOlF,KAAK8J,mBAEd,QACE,OAAO,EAEb,CAME,iCAAOI,GACL,MAAMtD,EAAS,CAAE,EAYjB,OATAA,EAAOuD,QAAS,IAAItF,GAAyB3C,0BAGzClC,KAAK8J,qBAGPlD,EAAOwD,QAAU,CAAC,qDAGbxD,CACX,6DCvHO,MAAMvD,EASX,WAAAtD,CAAYgD,EAAKL,EAAKO,EAAY,EAAGK,EAAkB,cAAeK,EAAa,SACjF,IAEqB,iBAARZ,IAAkBA,EAAMsH,WAAWtH,IAC3B,iBAARL,IAAkBA,EAAM2H,WAAW3H,IACrB,iBAAdO,IAAwBA,EAAYoH,WAAWpH,KAGtDF,SAAqCuH,MAAMvH,MAC7ChC,QAAQ2D,KAAK,8CACb3B,EAAM,IAGJL,SAAqC4H,MAAM5H,MAC7C3B,QAAQ2D,KAAK,+CACbhC,EAAM,IAIJK,GAAO,IAAMA,EAAM,MACrBhC,QAAQ2D,KAAK,YAAY3B,4CACzBA,EAAMP,KAAK+H,KAAK,GAAI/H,KAAKgI,IAAI,GAAIzH,MAG/BL,GAAO,KAAOA,EAAM,OACtB3B,QAAQ2D,KAAK,aAAahC,4CAC1BA,EAAMF,KAAK+H,KAAK,IAAK/H,KAAKgI,IAAI,IAAK9H,KAIrC,MAAM+H,EAAgBxH,SAAkDqH,MAAMrH,GAE1E,EADAA,EAI0B,CAAC,cAAe,eACnBsG,SAASjG,KAClCvC,QAAQ2D,KAAK,6BAA6BpB,kCAC1CA,EAAkB,eAGpBtD,KAAK+C,IAAMA,EACX/C,KAAK0C,IAAMA,EACX1C,KAAKiD,UAAYwH,EACjBzK,KAAKsD,gBAAkBA,EACvBtD,KAAK2D,WAAaA,GAAc,QAIhC3D,KAAK6J,YAAcT,EAAmBK,gBAKvC,CAAC,MAAOvI,GACPH,QAAQG,MAAM,mCAAoCA,GAElDlB,KAAK+C,IAAM,EACX/C,KAAK0C,IAAM,EACX1C,KAAKiD,UAAY,EACjBjD,KAAKsD,gBAAkB,cACvBtD,KAAK2D,WAAa,QAClB3D,KAAK6J,YAAcT,EAAmBK,gBAC5C,CACA,CAkBE,iBAAOiB,CAAWC,GAChB,IACE,IAAKA,GAAsB,iBAARA,EAEjB,OADA5J,QAAQ2D,KAAK,iDAAkDiG,GACxD,IAAItH,EAAW,EAAG,EAAG,GAI9B,IAAIN,OAAkB0E,IAAZkD,EAAI5H,IAAoB4H,EAAI5H,SACnB0E,IAAjBkD,EAAIC,SAAyBD,EAAIC,cACrBnD,IAAVkD,EAAIvC,EAAkBuC,EAAIvC,EAAI,EAG9B1F,OAAkB+E,IAAZkD,EAAIjI,IAAoBiI,EAAIjI,SAClB+E,IAAlBkD,EAAIE,UAA0BF,EAAIE,eACtBpD,IAAVkD,EAAIxC,EAAkBwC,EAAIxC,EAAI,EAGlC,MAAMlF,OAA8BwE,IAAlBkD,EAAI1H,UAA0B0H,EAAI1H,eACjCwE,IAAjBkD,EAAIG,SAAyBH,EAAIG,cACnBrD,IAAZkD,EAAII,IAAoBJ,EAAII,SAChBtD,IAAVkD,EAAItC,EAAkBsC,EAAItC,EAAI,EAGpC,GAAuB,mBAAZsC,EAAI5H,KAAyC,mBAAZ4H,EAAIjI,IAC9C,IACEK,EAAM4H,EAAI5H,MACVL,EAAMiI,EAAIjI,KACX,CAAC,MAAOsI,GACPjK,QAAQ2D,KAAK,0DAA2DsG,EAClF,CAMM,OAAO,IAAI3H,EACTN,EACAL,EACAO,EACA0H,EAAIrH,iBAAmB,cACvBqH,EAAIhH,YAAc,QAErB,CAAC,MAAOzC,GAEP,OADAH,QAAQG,MAAM,kCAAmCA,GAC1C,IAAImC,EAAW,EAAG,EAAG,EAClC,CACA,CAOE,YAAAP,CAAamI,GACX,OAAIjL,KAAK2D,aAAesH,EACfjL,KAAKwG,QAGPxG,KAAK6J,YAAY/H,UAAU9B,KAAMA,KAAK2D,WAAYsH,EAC7D,CAOE,iBAAAC,CAAkBC,GAChB,GAAInL,KAAKsD,kBAAoB6H,EAC3B,OAAOnL,KAAKwG,QAGd,GAAkB,gBAAd2E,GAAwD,gBAAzBnL,KAAKsD,gBAEtC,OAAOtD,KAAK6J,YAAY1H,gCAAgCnC,MAG1D,GAAkB,gBAAdmL,GAAwD,gBAAzBnL,KAAKsD,gBAEtC,OAAOtD,KAAK6J,YAAYzH,gCAAgCpC,MAG1D,MAAM,IAAIyB,MAAM,4CAA4CzB,KAAKsD,sBAAsB6H,IAC3F,CAOE,UAAAC,CAAWC,GAET,IAAIC,EAAaD,EAEbA,EAAM1H,aAAe3D,KAAK2D,aAC5B2H,EAAaD,EAAMvI,aAAa9C,KAAK2D,aAGnC2H,EAAWhI,kBAAoBtD,KAAKsD,kBACtCgI,EAAaA,EAAWJ,kBAAkBlL,KAAKsD,kBAIjD,MACM,EAAKtD,KAAK+C,IAAMP,KAAK4B,GAAK,IAC1B,EAAKkH,EAAWvI,IAAMP,KAAK4B,GAAK,IAChC,GAAMkH,EAAWvI,IAAM/C,KAAK+C,KAAOP,KAAK4B,GAAK,IAC7C,GAAMkH,EAAW5I,IAAM1C,KAAK0C,KAAOF,KAAK4B,GAAK,IAE7C2E,EAAIvG,KAAK2B,IAAI,EAAG,GAAK3B,KAAK2B,IAAI,EAAG,GAC7B3B,KAAKmG,IAAI,GAAMnG,KAAKmG,IAAI,GACxBnG,KAAK2B,IAAI,EAAG,GAAK3B,KAAK2B,IAAI,EAAG,GAEjCoH,EAVI,QASA,EAAI/I,KAAK0G,MAAM1G,KAAKqG,KAAKE,GAAIvG,KAAKqG,KAAK,EAAEE,KAI7CyC,EAAWF,EAAWrI,UAAYjD,KAAKiD,UAG7C,OAAOT,KAAKqG,KAAK0C,EAAqBA,EAAqBC,EAAWA,EAC1E,CAOE,SAAAC,CAAUJ,GAER,MAAMC,EAAaD,EAAM1H,aAAe3D,KAAK2D,WACzC0H,EAAMvI,aAAa9C,KAAK2D,YACxB0H,EAEE,EAAKrL,KAAK+C,IAAMP,KAAK4B,GAAK,IAC1B,EAAKkH,EAAWvI,IAAMP,KAAK4B,GAAK,IAChC,EAAKpE,KAAK0C,IAAMF,KAAK4B,GAAK,IAC1B,EAAKkH,EAAW5I,IAAMF,KAAK4B,GAAK,IAEhCgE,EAAI5F,KAAK2B,IAAI,EAAK,GAAM3B,KAAKmG,IAAI,GACjCR,EAAI3F,KAAKmG,IAAI,GAAMnG,KAAK2B,IAAI,GACxB3B,KAAK2B,IAAI,GAAM3B,KAAKmG,IAAI,GAAMnG,KAAKmG,IAAI,EAAK,GAEtD,IAAI+C,EAA6B,IAAnBlJ,KAAK0G,MAAMd,EAAGD,GAAW3F,KAAK4B,GAG5C,OAFAsH,GAAWA,EAAU,KAAO,IAErBA,CACX,CAOE,UAAAC,CAAWN,GAET,IAAIC,EAAaD,EAEbA,EAAM1H,aAAe3D,KAAK2D,aAC5B2H,EAAaD,EAAMvI,aAAa9C,KAAK2D,aAGnC2H,EAAWhI,kBAAoBtD,KAAKsD,kBACtCgI,EAAaA,EAAWJ,kBAAkBlL,KAAKsD,kBAIjD,MAAM,EAAKtD,KAAK+C,IAAMP,KAAK4B,GAAK,IAC1B,EAAKpE,KAAK0C,IAAMF,KAAK4B,GAAK,IAC1B,EAAKkH,EAAWvI,IAAMP,KAAK4B,GAAK,IAChC,EAAKkH,EAAW5I,IAAMF,KAAK4B,GAAK,IAEhCwH,EAAKpJ,KAAKmG,IAAI,GAAMnG,KAAKmG,IAAI,EAAK,GAClCkD,EAAKrJ,KAAKmG,IAAI,GAAMnG,KAAK2B,IAAI,EAAK,GAElC,EAAK3B,KAAK0G,MACd1G,KAAK2B,IAAI,GAAM3B,KAAK2B,IAAI,GACxB3B,KAAKqG,MAAMrG,KAAKmG,IAAI,GAAMiD,IAAOpJ,KAAKmG,IAAI,GAAMiD,GAAMC,EAAKA,IAGvD,EAAK,EAAKrJ,KAAK0G,MAAM2C,EAAIrJ,KAAKmG,IAAI,GAAMiD,GAGxCE,GAAgB9L,KAAKiD,UAAYqI,EAAWrI,WAAa,EAE/D,OAAO,IAAII,EACJ,IAAL,EAAWb,KAAK4B,GACX,IAAL,EAAW5B,KAAK4B,GAChB0H,EACA9L,KAAKsD,gBACLtD,KAAK2D,WAEX,CAME,KAAA6C,GACE,OAAO,IAAInD,EACTrD,KAAK+C,IACL/C,KAAK0C,IACL1C,KAAKiD,UACLjD,KAAKsD,gBACLtD,KAAK2D,WAEX,CAME,QAAAoI,GACE,MAAO,CACLhJ,IAAK/C,KAAK+C,IACVL,IAAK1C,KAAK0C,IACVO,UAAWjD,KAAKiD,UAChBK,gBAAiBtD,KAAKsD,gBACtBK,WAAY3D,KAAK2D,WAEvB,CAME,SAAAqI,GAEE,MAAMC,EAAiC,UAApBjM,KAAK2D,WACpB3D,KAAK8C,aAAa,SAClB9C,KAEJ,MAAO,CACLkF,KAAM,QACNgH,YAAa,CAACD,EAAWvJ,IAAKuJ,EAAWlJ,IAAKkJ,EAAWhJ,WAE/D,CAME,QAAAkJ,GACE,MAAO,GAAGnM,KAAK+C,IAAIC,QAAQ,MAAMhD,KAAK0C,IAAIM,QAAQ,MAAMhD,KAAKiD,UAAUD,QAAQ,OAAOhD,KAAK2D,eAAe3D,KAAKsD,kBACnH,CAME,eAAA8I,GACE,MAAO,GAAGpM,KAAK+C,IAAIC,QAAQ,MAAMhD,KAAK0C,IAAIM,QAAQ,IACtD,CAOE,IAAAqJ,CAAKpJ,GAEH,MAAMwH,EAAgBxH,QAAgDA,EAAY,EAElF,IAAKqJ,OAAOC,SAAS9B,GACnB,MAAM,IAAIhJ,MAAM,sBAAsBwB,wBAIxC,OADAjD,KAAKiD,UAAYwH,EACVzK,IACX,qDCvWY,MAACwM,EAAkB,CAQ7B,qBAAAC,CAAsB7J,GACpB,IAAKA,GAAoC,iBAAfA,EAExB,OADA7B,QAAQ2D,KAAK,+DACN,KAIT,MAAM3B,OAAyB0E,IAAnB7E,EAAWG,IAAoBH,EAAWG,SAC5B0E,IAAxB7E,EAAWgI,SAAyBhI,EAAWgI,cAC5BnD,IAAjB7E,EAAWwF,EAAkBxF,EAAWwF,EAAI,KAG1C1F,OAAyB+E,IAAnB7E,EAAWF,IAAoBE,EAAWF,SAC3B+E,IAAzB7E,EAAWiI,UAA0BjI,EAAWiI,eAC7BpD,IAAjB7E,EAAWuF,EAAkBvF,EAAWuF,EAAI,KAG1ClF,OAAqCwE,IAAzB7E,EAAWK,UAA0BL,EAAWK,eACxCwE,IAAxB7E,EAAWkI,SAAyBlI,EAAWkI,cAC1BrD,IAAnB7E,EAAWmI,IAAoBnI,EAAWmI,SACvBtD,IAAjB7E,EAAWyF,EAAkBzF,EAAWyF,EAAI,EAGlD,OAAY,OAARtF,GAAwB,OAARL,GAClB3B,QAAQ2D,KAAK,mEACN9B,GAMF,CAELG,MACAL,MACAO,YAGA2H,SAAU7H,EACV8H,UAAWnI,EAGXyF,EAAGzF,EACH0F,EAAGrF,EACHsF,EAAGpF,KAGAL,EAEN,EAQD,YAAA8J,CAAa9J,GAEX,OAAIA,aAAsBS,EACjBT,EAIFS,EAAWqH,WAAW1K,KAAKyM,sBAAsB7J,GACzD,EAQD,qBAAA+J,CAAsB/J,GACpB,MAAMgK,EAAe5M,KAAKyM,sBAAsB7J,GAEhD,MAAO,CACLG,IAAK6J,EAAa7J,IAClBL,IAAKkK,EAAalK,IAClBO,UAAW2J,EAAa3J,UAE3B,EAQD,2BAAA4J,CAA4BjK,GAC1B,MAAMgK,EAAe5M,KAAKyM,sBAAsB7J,GAGhD,MAAO,CACLG,IAAK6J,EAAa7J,IAClBL,IAAKkK,EAAalK,IAClBO,UAAW2J,EAAa3J,UAE3B,GCzGI,MAAM6J,EAMX,6BAAOC,CAAuBb,GAC5B,IAAKA,GAAeA,EAAYc,OAAS,EACvC,OAAO,EAGT,IAAIC,EAAY,EAEhB,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAYc,OAAQE,IAAK,CAC3C,MAAMC,EAAOjB,EAAYgB,EAAI,GACvBE,EAAOlB,EAAYgB,GAGzB,QAAuBzF,IAAnB0F,EAAKlK,WAA8C,OAAnBkK,EAAKlK,gBAClBwE,IAAnB2F,EAAKnK,WAA8C,OAAnBmK,EAAKnK,UACvC,SAIF,MAAMoK,EAAOD,EAAKnK,UAAYkK,EAAKlK,UAC/BoK,EAAO,IACTJ,GAAaI,EAErB,CAEI,OAAOJ,CACX,CAOE,6BAAOK,CAAuBpB,GAC5B,IAAKA,GAAeA,EAAYc,OAAS,EACvC,OAAO,EAGT,IAAIO,EAAY,EAEhB,IAAK,IAAIL,EAAI,EAAGA,EAAIhB,EAAYc,OAAQE,IAAK,CAC3C,MAAMC,EAAOjB,EAAYgB,EAAI,GACvBE,EAAOlB,EAAYgB,GAGzB,QAAuBzF,IAAnB0F,EAAKlK,WAA8C,OAAnBkK,EAAKlK,gBAClBwE,IAAnB2F,EAAKnK,WAA8C,OAAnBmK,EAAKnK,UACvC,SAIF,MAAMoK,EAAOD,EAAKnK,UAAYkK,EAAKlK,UAC/BoK,EAAO,IACTE,GAAa/K,KAAKC,IAAI4K,GAE9B,CAEI,OAAOE,CACX,CAME,0BAAOC,GACL,MAAO,CAAEnK,aACb,CAMEgG,uBAAyB,OACzBA,8BAAgC,QAChCA,8BAAgC,eAChCA,yBAA2B,EAAI,cAU/B,qBAAAoE,CAAsBC,EAAOC,EAAKC,GAChC,OAAOd,EAAeW,sBAAsBC,EAAOC,EAAKC,EAC5D,CAUE,wBAAOC,CAAkBC,EAAQC,EAAQC,EAAU,CAAA,GAEjD,IAAKF,IAAWC,GACU,iBAAXD,GAAyC,iBAAXC,EAE3C,OADAhN,QAAQG,MAAM,sDACP,EAGT,MAAM+M,GAAgD,IAA7BD,EAAQC,iBAG3BC,EAAUC,QAEO1G,IAAd0G,EAAMpL,IAAoBoL,EAAMpL,SAClB0E,IAAnB0G,EAAMvD,SAAyBuD,EAAMvD,SAAW,KAI9CwD,EAAUD,QAEO1G,IAAd0G,EAAMzL,IAAoByL,EAAMzL,SACjB+E,IAApB0G,EAAMtD,UAA0BsD,EAAMtD,UAAY,KAIhDwD,EAAOH,EAAOJ,GACdQ,EAAOF,EAAON,GACdS,EAAOL,EAAOH,GACdS,EAAOJ,EAAOL,GAGpB,GAAa,OAATM,GAA0B,OAATC,GAA0B,OAATC,GAA0B,OAATC,EAErD,OADAzN,QAAQG,MAAM,mEACP,EAIT,MAAMuN,EAAe,CACnB1L,IAAKsL,EACL3L,IAAK4L,EACLrL,eAAgCwE,IAArBqG,EAAO7K,UAA0B6K,EAAO7K,UAAY,GAG3DyL,EAAe,CACnB3L,IAAKwL,EACL7L,IAAK8L,EACLvL,eAAgCwE,IAArBsG,EAAO9K,UAA0B8K,EAAO9K,UAAY,GAIjE,GAAIgL,GACIH,aAAkBzK,GAClB0K,aAAkB1K,GACW,mBAAtByK,EAAO1C,WACpB,OAAO0C,EAAO1C,WAAW2C,GAI3B,GAAIE,EAAkB,CAEpB,MAAMU,EAAa3O,KAAK4O,8BAA8BH,EAAcC,GAO9DlD,QAHmC/D,IAA3BiH,EAAazL,UAA0ByL,EAAazL,UAAY,SADrCwE,IAA3BgH,EAAaxL,UAA0BwL,EAAaxL,UAAY,GAK9E,OAAOT,KAAKqG,KAAK8F,EAAaA,EAAanD,EAAWA,EAC5D,CAGI,OAAOxL,KAAK4O,8BAA8BH,EAAcC,EAC5D,CASE,oBAAOG,CAAc3C,EAAa8B,EAAU,IAC1C,MAAMC,GAAgD,IAA7BD,EAAQC,iBAGjC,GAAI/B,EAAYc,OAAS,EACvB,OAAO,EAIT,MAAM8B,EAAa5C,EAAY,GACzB6C,EAAY7C,EAAYA,EAAYc,OAAS,GAK7CgC,EAJWF,EAAW/L,MAAQgM,EAAUhM,KACtC+L,EAAWpM,MAAQqM,EAAUrM,IAGLwJ,EAAc,IAAIA,EAAaA,EAAY,IAG3E,OAAIlM,KAAKiP,oBAAoBD,GAEpBhP,KAAKkP,gCAAgCF,EAAchB,GAGxDC,EAEKjO,KAAKmP,iBAAiBH,GAGtBhP,KAAKoP,0BAA0BJ,EAE5C,CASE,yBAAOK,CAAmBnD,EAAa8B,EAAU,IAC/C,MAAMC,GAAgD,IAA7BD,EAAQC,iBAEjC,GAAI/B,EAAYc,OAAS,EACvB,OAAO,EAGT,IAAIsC,EAAY,EAGhB,IAAK,IAAIpC,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAC1CoC,GAAatP,KAAK6N,kBAChB3B,EAAYgB,GACZhB,EAAYgB,EAAI,GAChB,CAAEe,qBAKN,GAAI/B,EAAYc,QAAU,EAAG,CAE3B,MAAM8B,EAAa5C,EAAY,GACzB6C,EAAY7C,EAAYA,EAAYc,OAAS,GAClC8B,EAAW/L,MAAQgM,EAAUhM,KACpC+L,EAAWpM,MAAQqM,EAAUrM,MAIrC4M,GAAatP,KAAK6N,kBAChB3B,EAAYA,EAAYc,OAAS,GACjCd,EAAY,GACZ,CAAE+B,qBAGZ,CAEI,OAAOqB,CACX,CAUE,0BAAOC,CAAoBrD,EAAa8B,EAAU,IAChD,OAAOhO,KAAKqP,mBAAmBnD,EAAa8B,EAChD,CAYE,mCAAOwB,CAA6BtD,EAAauD,EAAYC,EAAiBC,EAAU3B,EAAU,IAChG,GAAI9B,EAAYc,OAAS,GAAKyC,EAAa,GAAKA,GAAcvD,EAAYc,OAAS,EACjF,MAAM,IAAIvL,MAAM,+DAGlB,MAAMmO,GAAgC,IAArB5B,EAAQ4B,SAGnBC,EAAa3D,EAAYuD,GACzBK,EAAW5D,EAAYuD,EAAa,GAGpCM,EAAkBvN,KAAK+H,IAAI,EAAG/H,KAAKgI,IAAI,EAAGkF,IAG1CM,EAAe,IAAI3M,EACvBwM,EAAW9M,IAAMgN,GAAmBD,EAAS/M,IAAM8M,EAAW9M,KAC9D8M,EAAWnN,IAAMqN,GAAmBD,EAASpN,IAAMmN,EAAWnN,KAC9DkN,EAAWC,EAAW5M,UAAY8M,GAAmBD,EAAS7M,UAAY4M,EAAW5M,WAAa,KAClG4M,EAAWvM,gBACXuM,EAAWlM,YAIPsM,EAAiBJ,EAAWpE,UAAUqE,GAGtCI,GAAwBD,EAAiB,IAAM,IAG/CE,EAAcnQ,KAAKoQ,2BACvBJ,EACAL,EACAO,GAQF,OAJIN,GAAuC,OAA3BI,EAAa/M,gBAAiDwE,IAA3BuI,EAAa/M,YAC9DkN,EAAYlN,UAAY+M,EAAa/M,WAGhC,CACL+M,aAAcA,EACdG,YAAaA,EACbV,WAAYA,EACZC,gBAAiBK,EACjBE,eAAgBA,EAChBC,qBAAsBA,EAE5B,CAQE,uBAAOG,CAAiBC,EAAMC,GAE5B,OAAOD,EAAK7E,UAAU8E,EAC1B,CAWE,gBAAOC,CAAUC,EAAQC,EAAcC,EAAa,EAAGC,EAAW,IAAKC,EAAW,IAChF,MAAMjK,EAAS,GAITkK,GAHaF,EAAWD,GAGME,EAEpC,IAAK,IAAI3D,EAAI,EAAGA,GAAK2D,EAAU3D,IAAK,CAClC,MAAM6D,GAASJ,EAAazD,EAAI4D,GAAkBtO,KAAK4B,GAAK,IACtDwJ,EAAQ5N,KAAKoQ,2BACjBK,EACAC,EACAK,GAEFnK,EAAOtG,KAAKsN,EAClB,CAEI,OAAOhH,CACX,CASE,mBAAOoK,CAAaP,EAAQC,EAAcG,EAAW,IACnD,OAAO7Q,KAAKwQ,UAAUC,EAAQC,EAAc,EAAG,IAAKG,EACxD,CAUE,sBAAOI,CAAgBR,EAAQS,EAAaC,EAAcC,EAAkB,GAC1E,MAAMC,EAAkBD,EAAkB5O,KAAK4B,GAAK,IAC9CkN,EAAYJ,EAAc,EAC1BK,EAAaJ,EAAe,EAG5BK,EAAW,CACfhP,KAAK0G,OAAOqI,GAAaD,GAAaD,EACtC7O,KAAK0G,OAAOqI,EAAYD,GAAaD,EACrC7O,KAAK0G,MAAMqI,EAAYD,GAAaD,EACpC7O,KAAK0G,MAAMqI,GAAaD,GAAaD,GAGjCI,EAAY,CAChBjP,KAAKqG,KAAKyI,EAAYA,EAAYC,EAAaA,GAC/C/O,KAAKqG,KAAKyI,EAAYA,EAAYC,EAAaA,GAC/C/O,KAAKqG,KAAKyI,EAAYA,EAAYC,EAAaA,GAC/C/O,KAAKqG,KAAKyI,EAAYA,EAAYC,EAAaA,IAI3ClN,EAAU,GAChB,IAAK,IAAI6I,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,MAAMxB,GAAyB,IAAd8F,EAAStE,GAAW1K,KAAK4B,GAAK,KAAO,IACtDC,EAAQ/D,KAAKN,KAAKoQ,2BAChBK,EACAgB,EAAUvE,GACVxB,GAER,CAKI,OAFArH,EAAQ/D,KAAK+D,EAAQ,IAEdA,CACX,CAQE,uBAAOqN,CAAiB9D,EAAO+D,GAE7B,IAAIC,GAAS,EAGb,MAEMC,EAFkBF,EAAQ,GAAG5O,MAAQ4O,EAAQA,EAAQ3E,OAAS,GAAGjK,KAC/D4O,EAAQ,GAAGjP,MAAQiP,EAAQA,EAAQ3E,OAAS,GAAGtK,IACfiP,EAAU,IAAIA,EAASA,EAAQ,IAGjE1G,EAAmB2C,EAAMjK,WACzBmO,EAAoBD,EAAcE,KAAI5D,GAC1CA,EAAMxK,aAAesH,EACnBkD,EAAMrL,aAAamI,GACnBkD,IAGJ,IAAK,IAAIjB,EAAI,EAAG8E,EAAIF,EAAkB9E,OAAS,EAAGE,EAAI4E,EAAkB9E,OAAQgF,EAAI9E,IAAK,CACvF,MAAM+E,EAAKH,EAAkB5E,GAAGxK,IAC1BwP,EAAKJ,EAAkB5E,GAAGnK,IAC1BoP,EAAKL,EAAkBE,GAAGtP,IAC1B0P,EAAKN,EAAkBE,GAAGjP,IAEZmP,EAAKtE,EAAM7K,KAAUqP,EAAKxE,EAAM7K,KACzC6K,EAAMlL,KAAOyP,EAAKF,IAAOrE,EAAM7K,IAAMmP,IAAOE,EAAKF,GAAMD,IAEnDL,GAAUA,EAC/B,CAEI,OAAOA,CACX,CAQE,qBAAOS,CAAezE,EAAO+D,GAC3B,OAAO3R,KAAK0R,iBAAiB9D,EAAO+D,EACxC,CAOE,wBAAOW,CAAkBpG,GAEvB,GAAIA,EAAYc,OAAS,EACvB,MAAM,IAAIvL,MAAM,0DAKlB,IAAI8Q,EAAS,EACTC,EAAS,EACTC,EAAU,EAEd,IAAK,MAAMtE,KAASjC,EAClBqG,GAAUpE,EAAMpL,IAChByP,GAAUrE,EAAMzL,IAChB+P,GAAWtE,EAAMlL,UAGnB,OAAO,IAAII,EACTkP,EAASrG,EAAYc,OACrBwF,EAAStG,EAAYc,OACrByF,EAAUvG,EAAYc,OACtBd,EAAY,GAAG5I,gBACf4I,EAAY,GAAGvI,WAErB,CAQE,+BAAO+O,CAAyBC,EAAcC,EAAQ,IAEpD,IAAKD,GAAgBA,EAAa3F,OAAS,EAIzC,OAHAjM,QAAQ2D,KAAK,oFAGTiO,GAAgBA,EAAa3F,OAAS,EACjC2F,EAAa,GAAGnM,QAElB,KAIT,IAAKoM,GAA0B,IAAjBA,EAAM5F,OAClB,OAAOhN,KAAKsS,kBAAkBK,GAYhC,MAAME,EAAmB7S,KAAKsS,kBAAkBK,GAG1CG,EAAaF,EAAMrS,QAAOwS,GAAQA,GAAQA,EAAK/F,QAAU,IAE/D,GAA0B,IAAtB8F,EAAW9F,OACb,OAAO6F,EAIT,MAAMG,EAAehT,KAAK6O,cAAc8D,GACxC,GAAqB,IAAjBK,EACF,OAAOH,EAIT,IAAII,EAAYD,EACZE,EAAcL,EAAiB9P,IAAMiQ,EACrCG,EAAcN,EAAiBnQ,IAAMsQ,EACrCI,EAAeP,EAAiB5P,UAAY+P,EAEhD,IAAK,MAAMD,KAAQD,EAAY,CAC7B,MAAMO,EAAerT,KAAKsS,kBAAkBS,GACtCO,EAAWtT,KAAK6O,cAAckE,GAEpCE,GAAaK,EACbJ,GAAeG,EAAatQ,IAAMuQ,EAClCH,GAAeE,EAAa3Q,IAAM4Q,EAClCF,GAAgBC,EAAapQ,UAAYqQ,CAC/C,CAGI,OAAIL,GAAa,EACRJ,EAIF,IAAIxP,EACT6P,EAAcD,EACdE,EAAcF,EACdG,EAAeH,EACfN,EAAa,GAAGrP,gBAChBqP,EAAa,GAAGhP,WAEtB,CAOE,0BAAO4P,CAAoBrH,GAEzB,GAA2B,IAAvBA,EAAYc,OACd,MAAM,IAAIvL,MAAM,yDAIlB,GAA2B,IAAvByK,EAAYc,OACd,OAAOd,EAAY,GAAG1F,QAIxB,GAA2B,IAAvB0F,EAAYc,OAAc,CAC5B,MAAMjK,GAAOmJ,EAAY,GAAGnJ,IAAMmJ,EAAY,GAAGnJ,KAAO,EAClDL,GAAOwJ,EAAY,GAAGxJ,IAAMwJ,EAAY,GAAGxJ,KAAO,EAClDO,GAAaiJ,EAAY,GAAGjJ,UAAYiJ,EAAY,GAAGjJ,WAAa,EAE1E,OAAO,IAAII,EACTN,EACAL,EACAO,EACAiJ,EAAY,GAAG5I,gBACf4I,EAAY,GAAGvI,WAEvB,CAGI,MACM6P,EADcxT,KAAKuP,oBAAoBrD,GACR,EAGrC,IAAIuH,EAAkB,EAEtB,IAAK,IAAIvG,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAAK,CAC/C,MAAMwG,EAAgB1T,KAAK6N,kBACzB3B,EAAYgB,GACZhB,EAAYgB,EAAI,GAChB,CAAEe,kBAAkB,IAGtB,GAAIwF,EAAkBC,GAAiBF,EAAgB,CAErD,MACMG,GADoBH,EAAiBC,GACNC,EAG/BhI,EAAUQ,EAAYgB,GAAGzB,UAAUS,EAAYgB,EAAI,IACnDuD,EAASzQ,KAAKoQ,2BAClBlE,EAAYgB,GACZwG,EAAgBC,EAChBjI,GAOF,OAHA+E,EAAOxN,UAAYiJ,EAAYgB,GAAGjK,WACrBiJ,EAAYgB,EAAI,GAAGjK,UAAYiJ,EAAYgB,GAAGjK,WAAa0Q,EAEjElD,CACf,CAEMgD,GAAmBC,CACzB,CAGI,IAAInB,EAAS,EACTC,EAAS,EACTC,EAAU,EAEd,IAAK,MAAMtE,KAASjC,EAClBqG,GAAUpE,EAAMpL,IAChByP,GAAUrE,EAAMzL,IAChB+P,GAAWtE,EAAMlL,UAGnB,OAAO,IAAII,EACTkP,EAASrG,EAAYc,OACrBwF,EAAStG,EAAYc,OACrByF,EAAUvG,EAAYc,OACtBd,EAAY,GAAG5I,gBACf4I,EAAY,GAAGvI,WAErB,CAUE,uBAAOiQ,CAAiB1H,EAAa2H,EAAc7F,EAAU,CAAA,GAC3D,GAAI9B,EAAYc,OAAS,EACvB,MAAM,IAAIvL,MAAM,qDAGlB,MAAMqS,EAAS9F,EAAQ8F,SAAU,EAC3BlN,EAAS,GAGf,IAAK,IAAIsG,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAAK,CAC/C,MAAMQ,EAAQxB,EAAYgB,GACpBS,EAAMzB,EAAYgB,EAAI,GAMtB6G,GAHUrG,EAAMjC,UAAUkC,GAGD,IAAM,IAG/BqG,EAAchU,KAAKoQ,2BACvB1C,EACAmG,EACAE,GAMF,GAHAnN,EAAOtG,KAAK0T,GAGR9G,IAAMhB,EAAYc,OAAS,EAAG,CAChC,MAAMiH,EAAYjU,KAAKoQ,2BACrBzC,EACAkG,EACAE,GAEFnN,EAAOtG,KAAK2T,EACpB,CACA,CAOI,OAJIH,GAAUlN,EAAOoG,OAAS,GAC5BpG,EAAOtG,KAAKsG,EAAO,IAGdA,CACX,CASE,4BAAO6G,CAAsBC,EAAOC,EAAKC,GACvC,MAAMhH,EAAS5G,KAAKkU,+BAA+BtG,EAAOF,EAAOC,GACjE,MAAO,CACLC,MAAOhH,EAAOgH,MACd+B,SAAU/I,EAAO+I,SACjBgE,SAAU/M,EAAO+M,SACjBjE,gBAAiB9I,EAAO+M,SAE9B,CAUE,4BAAOQ,CAAsBvR,EAAY+M,EAAUjE,GACjD,OAAO1L,KAAKoQ,2BAA2BxN,EAAY+M,EAAUjE,EACjE,CAWE,iCAAO0E,CAA2B1C,EAAOiC,EAAUjE,GAEjD,MAAM0I,EAAgB5H,EAAgBC,sBAAsBiB,GAE5D,IAAK0G,EAEH,OADArT,QAAQG,MAAM,2DAA4DwM,GACnE,KAGT,MAAM2G,EAAcrU,KAAKsU,gBACnBC,EAAa7I,EAAUlJ,KAAK4B,GAAK,IACjCoQ,EAASJ,EAAcrR,IAAMP,KAAK4B,GAAK,IACvCqQ,EAASL,EAAc1R,IAAMF,KAAK4B,GAAK,IAEvCsQ,EAAY/E,EAAW0E,EACvBM,EAAenS,KAAK2B,IAAIuQ,GACxBE,EAAepS,KAAKmG,IAAI+L,GAExBG,EAAUrS,KAAK2B,IAAIqQ,GACnBM,EAAUtS,KAAKmG,IAAI6L,GAEnBO,EAAUF,EAAUD,EAAeE,EAAUH,EAAenS,KAAKmG,IAAI4L,GACrEhG,EAAO/L,KAAKwS,KAAKD,GAEjB3M,EAAI5F,KAAK2B,IAAIoQ,GAAcI,EAAeG,EAC1C3M,EAAIyM,EAAeC,EAAUE,EAC7BvG,EAAOiG,EAASjS,KAAK0G,MAAMd,EAAGD,GAG9B7E,EAAkBoK,EAAMpK,iBAC3BoK,aAAiBrK,EAD4BqK,EAAMpK,gBACG,cACnDK,EAAa+J,EAAM/J,YACtB+J,aAAiBrK,EADkBqK,EAAM/J,WACQ,QAEpD,OAAO,IAAIN,EACF,IAAPkL,EAAa/L,KAAK4B,IACT,IAAPoK,EAAahM,KAAK4B,GAAM,KAAO,IAAM,IACvCgQ,EAAcnR,UACdK,EACAK,EAEN,CAWE,qCAAOuQ,CAA+BtG,EAAOqH,EAAcC,GAEzD,MAAMC,EAAgB3I,EAAgBE,aAAakB,GAC7CwG,EAAgB5H,EAAgBE,aAAauI,GAC7CG,EAAc5I,EAAgBE,aAAawI,GAG3C/M,EAAIgN,EAAczS,IAAM0R,EAAc1R,IACtC0F,EAAI+M,EAAcpS,IAAMqR,EAAcrR,IACtC8C,EAAKuP,EAAY1S,IAAM0R,EAAc1R,IACrCoD,EAAKsP,EAAYrS,IAAMqR,EAAcrR,IAGrCsS,EAAMlN,EAAItC,EAAKuC,EAAItC,EAGnBwP,EAAOzP,EAAKA,EAAKC,EAAKA,EAGtByP,EAAID,EAAO,EAAI9S,KAAK+H,IAAI,EAAG/H,KAAKgI,IAAI,EAAG6K,EAAMC,IAAS,EAGtDE,EAAapB,EAAc1R,IAAM6S,EAAI1P,EACrC4P,EAAarB,EAAcrR,IAAMwS,EAAIzP,EAGrC4P,EAActB,EAAcnR,UAC1BsS,GAAKH,EAAYnS,UAAYmR,EAAcnR,WAG7C0S,EAAe,IAAItS,EACvBoS,EACAD,EACAE,EACAtB,EAAc9Q,gBACd8Q,EAAczQ,YAMhB,MAAO,CACLiK,MAAO+H,EACPhG,SAJewF,EAAc/J,WAAWuK,GAKxChC,SAAU4B,EAEhB,CAWE,6BAAOK,CAAuBC,EAAIC,EAAIC,EAAIC,GAExC,MAAMC,EAAM,CAAE9N,EAAG0N,EAAGnT,IAAK0F,EAAGyN,EAAG9S,KACzBmT,EAAM,CAAE/N,EAAG2N,EAAGpT,IAAK0F,EAAG0N,EAAG/S,KACzBoT,EAAM,CAAEhO,EAAG4N,EAAGrT,IAAK0F,EAAG2N,EAAGhT,KACzBqT,EAAM,CAAEjO,EAAG6N,EAAGtT,IAAK0F,EAAG4N,EAAGjT,KAGzBsT,EAAKrW,KAAKsW,WAAWH,EAAKC,EAAKH,GAC/BM,EAAKvW,KAAKsW,WAAWH,EAAKC,EAAKF,GAC/BM,EAAKxW,KAAKsW,WAAWL,EAAKC,EAAKC,GAC/BM,EAAKzW,KAAKsW,WAAWL,EAAKC,EAAKE,GAGrC,OAAUC,EAAK,GAAKE,EAAK,GAAOF,EAAK,GAAKE,EAAK,KACjCC,EAAK,GAAKC,EAAK,GAAOD,EAAK,GAAKC,EAAK,IACnC,IAAPJ,GAAYrW,KAAK0W,WAAWP,EAAKC,EAAKH,IAC/B,IAAPM,GAAYvW,KAAK0W,WAAWP,EAAKC,EAAKF,IAC/B,IAAPM,GAAYxW,KAAK0W,WAAWT,EAAKC,EAAKC,IAC/B,IAAPM,GAAYzW,KAAK0W,WAAWT,EAAKC,EAAKE,EACnD,CAUE,iBAAOE,CAAWvN,EAAGC,EAAG2N,GACtB,OAAQA,EAAExO,EAAIY,EAAEZ,IAAMa,EAAEZ,EAAIW,EAAEX,IAAMY,EAAEb,EAAIY,EAAEZ,IAAMwO,EAAEvO,EAAIW,EAAEX,EAC9D,CAUE,iBAAOsO,CAAW3N,EAAGC,EAAG2N,GACtB,OAAOA,EAAExO,GAAK3F,KAAK+H,IAAIxB,EAAEZ,EAAGa,EAAEb,IAAMwO,EAAExO,GAAK3F,KAAKgI,IAAIzB,EAAEZ,EAAGa,EAAEb,IACnDwO,EAAEvO,GAAK5F,KAAK+H,IAAIxB,EAAEX,EAAGY,EAAEZ,IAAMuO,EAAEvO,GAAK5F,KAAKgI,IAAIzB,EAAEX,EAAGY,EAAEZ,EAChE,CAQE,0BAAO6G,CAAoB/C,GAEzB,IAAK,IAAIgB,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAC1C,IAAK,IAAI8E,EAAI9E,EAAI,EAAG8E,EAAI9F,EAAYc,OAAS,EAAGgF,IAAK,CAEnD,GAAU,IAAN9E,GAAW8E,IAAM9F,EAAYc,OAAS,EAAG,SAE7C,MAAM6I,EAAK3J,EAAYgB,GACjB4I,EAAK5J,EAAYgB,EAAI,GACrB6I,EAAK7J,EAAY8F,GACjBgE,EAAK9J,EAAY8F,EAAI,GAE3B,GAAIhS,KAAK4V,uBAAuBC,EAAIC,EAAIC,EAAIC,GAC1C,OAAO,CAEjB,CAGI,OAAO,CACX,CAQE,2BAAOY,CAAqB1K,GAC1B,SAAKA,GAAeA,EAAYc,OAAS,IAIlChN,KAAKiP,oBAAoB/C,EACpC,CAQE,gCAAOkD,CAA0BlD,GAE/B,IAAI2K,EAAO,EAGX,IAAK,IAAI3J,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAC1C2J,GAAQ7W,KAAK8W,gCACX5K,EAAY,GACZA,EAAYgB,GACZhB,EAAYgB,EAAI,IAIpB,OAAO1K,KAAKC,IAAIoU,EACpB,CAUE,sCAAOC,CAAgCC,EAAGC,EAAGC,GAC3C,MAAMC,EAAIlX,KAAKsU,gBAGT6C,EAAKJ,EAAEhU,IAAMP,KAAK4B,GAAK,IACvBgT,EAAKL,EAAErU,IAAMF,KAAK4B,GAAK,IACvBiT,EAAKL,EAAEjU,IAAMP,KAAK4B,GAAK,IACvBkT,EAAKN,EAAEtU,IAAMF,KAAK4B,GAAK,IACvBmT,EAAKN,EAAElU,IAAMP,KAAK4B,GAAK,IACvBoT,EAAKP,EAAEvU,IAAMF,KAAK4B,GAAK,IAoB7B,OAjBU5B,KAAKiV,KACbjV,KAAK2B,IAAIkT,GAAM7U,KAAK2B,IAAIoT,GAClB/U,KAAKmG,IAAI0O,GAAM7U,KAAKmG,IAAI4O,GAAM/U,KAAKmG,IAAI2O,EAAKE,IAE1ChV,KAAKiV,KACbjV,KAAK2B,IAAIgT,GAAM3U,KAAK2B,IAAIoT,GAClB/U,KAAKmG,IAAIwO,GAAM3U,KAAKmG,IAAI4O,GAAM/U,KAAKmG,IAAIyO,EAAKI,IAE1ChV,KAAKiV,KACbjV,KAAK2B,IAAIgT,GAAM3U,KAAK2B,IAAIkT,GAClB7U,KAAKmG,IAAIwO,GAAM3U,KAAKmG,IAAI0O,GAAM7U,KAAKmG,IAAIyO,EAAKE,IAI9B9U,KAAK4B,IAGhB8S,EAAIA,CACnB,CASE,sCAAOhI,CAAgChD,EAAawL,GAOlD,OAHA3W,QAAQ2D,KAAK,2EAGN1E,KAAKoP,0BAA0BlD,EAC1C,CAQE,uBAAOiD,CAAiBjD,GAKtB,GAAIA,EAAYc,OAAS,EACvB,OAAO,EAIT,MAAM2K,EAAYzL,EAAY6F,KAAI5D,GAASnO,KAAK4X,uBAAuBzJ,KAGjE0J,EAAS7X,KAAK8X,6BAA6BH,GAG3CI,EAAkBJ,EAAU5F,KAAInE,GACpC5N,KAAKgY,uBAAuBpK,EAAOiK,EAAQF,EAAU,MAIvD,IAAId,EAAO,EACX,IAAK,IAAI3J,EAAI,EAAGA,EAAI6K,EAAgB/K,OAAS,EAAGE,IAAK,CACnD,MAAM2I,EAAKkC,EAAgB7K,GACrB4I,EAAKiC,EAAgB7K,EAAI,GAGzB+K,EAAejY,KAAKkY,cAAcrC,EAAIC,GAC5Ce,GAAQ,GAAM7W,KAAKmY,cAAcF,EACvC,CAEI,OAAOpB,CACX,CAQE,mCAAOiB,CAA6BM,GAIlC,GAAIA,EAAOpL,OAAS,EAClB,MAAO,CAAE7E,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAI1B,MAAMgQ,EAAK,CACTlQ,EAAGiQ,EAAO,GAAGjQ,EAAIiQ,EAAO,GAAGjQ,EAC3BC,EAAGgQ,EAAO,GAAGhQ,EAAIgQ,EAAO,GAAGhQ,EAC3BC,EAAG+P,EAAO,GAAG/P,EAAI+P,EAAO,GAAG/P,GAGvBiQ,EAAK,CACTnQ,EAAGiQ,EAAO,GAAGjQ,EAAIiQ,EAAO,GAAGjQ,EAC3BC,EAAGgQ,EAAO,GAAGhQ,EAAIgQ,EAAO,GAAGhQ,EAC3BC,EAAG+P,EAAO,GAAG/P,EAAI+P,EAAO,GAAG/P,GAIvBwP,EAAS7X,KAAKkY,cAAcG,EAAIC,GAGhCtL,EAAShN,KAAKmY,cAAcN,GAElC,MAAO,CACL1P,EAAG0P,EAAO1P,EAAI6E,EACd5E,EAAGyP,EAAOzP,EAAI4E,EACd3E,EAAGwP,EAAOxP,EAAI2E,EAEpB,CASE,6BAAO4K,CAAuBzJ,GAC5B,MAAMpF,EAAI/I,KAAKuY,uBACT9P,EAAK,gBAGL+P,EAAgBhM,EAAgBC,sBAAsB0B,GAE5D,IAAKqK,GAAuC,OAAtBA,EAAczV,KAAsC,OAAtByV,EAAc9V,IAGhE,OAFA3B,QAAQG,MAAM,4CAA6CiN,GAEpD,CAAEhG,EAAG,EAAGC,EAAG,EAAGC,EAAG,EAAGS,eAAgB,aAG7C,MAAM0L,EAASgE,EAAczV,IAAMP,KAAK4B,GAAK,IACvCqQ,EAAS+D,EAAc9V,IAAMF,KAAK4B,GAAK,IACvCsE,EAAI8P,EAAcvV,UAElBwV,EAASjW,KAAK2B,IAAIqQ,GAClBkE,EAASlW,KAAKmG,IAAI6L,GAClBmE,EAASnW,KAAK2B,IAAIsQ,GAClBmE,EAASpW,KAAKmG,IAAI8L,GAElB7L,EAAIG,EAAIvG,KAAKqG,KAAK,EAAIJ,EAAKgQ,EAASA,GAc1C,MAXe,CACbtQ,GAAIS,EAAIF,GAAKgQ,EAASE,EACtBxQ,GAAIQ,EAAIF,GAAKgQ,EAASC,EACtBtQ,GAAIO,GAAK,EAAIH,GAAMC,GAAK+P,EAExB1V,IAAKyV,EAAczV,IACnBL,IAAK8V,EAAc9V,IACnBO,UAAWuV,EAAcvV,UACzB6F,eAAgB,aAItB,CAUE,6BAAOkP,CAAuBpK,EAAOiK,EAAQgB,GAE3C,MAAMC,EAAI,CACR3Q,EAAGyF,EAAMzF,EAAI0Q,EAAW1Q,EACxBC,EAAGwF,EAAMxF,EAAIyQ,EAAWzQ,EACxBC,EAAGuF,EAAMvF,EAAIwQ,EAAWxQ,GAIpB0Q,EAAO/Y,KAAKgZ,YAAYF,EAAGjB,GAGjC,MAAO,CACL1P,EAAGyF,EAAMzF,EAAI4Q,EAAOlB,EAAO1P,EAC3BC,EAAGwF,EAAMxF,EAAI2Q,EAAOlB,EAAOzP,EAC3BC,EAAGuF,EAAMvF,EAAI0Q,EAAOlB,EAAOxP,EAEjC,CASE,kBAAO2Q,CAAYX,EAAIC,GACrB,OAAOD,EAAGlQ,EAAImQ,EAAGnQ,EAAIkQ,EAAGjQ,EAAIkQ,EAAGlQ,EAAIiQ,EAAGhQ,EAAIiQ,EAAGjQ,CACjD,CASE,oBAAO6P,CAAcG,EAAIC,GACvB,MAAO,CACLnQ,EAAGkQ,EAAGjQ,EAAIkQ,EAAGjQ,EAAIgQ,EAAGhQ,EAAIiQ,EAAGlQ,EAC3BA,EAAGiQ,EAAGhQ,EAAIiQ,EAAGnQ,EAAIkQ,EAAGlQ,EAAImQ,EAAGjQ,EAC3BA,EAAGgQ,EAAGlQ,EAAImQ,EAAGlQ,EAAIiQ,EAAGjQ,EAAIkQ,EAAGnQ,EAEjC,CAQE,oBAAOgQ,CAAcW,GACnB,OAAOtW,KAAKqG,KAAKiQ,EAAE3Q,EAAI2Q,EAAE3Q,EAAI2Q,EAAE1Q,EAAI0Q,EAAE1Q,EAAI0Q,EAAEzQ,EAAIyQ,EAAEzQ,EACrD,CASE,oCAAOuG,CAA8Bd,EAAQC,GAC3C,MAAMmJ,EAAIlX,KAAKsU,gBACTjG,EAAOP,EAAO/K,IAAMP,KAAK4B,GAAK,IAC9BmK,EAAOR,EAAOhL,IAAMP,KAAK4B,GAAK,IAC9B6U,EAAO1K,EAAOF,EACd6K,GAAQnL,EAAOrL,IAAMoL,EAAOpL,KAAOF,KAAK4B,GAAK,IAE7C2E,EAAIvG,KAAK2B,IAAI8U,EAAO,GAAKzW,KAAK2B,IAAI8U,EAAO,GACvCzW,KAAKmG,IAAI0F,GAAQ7L,KAAKmG,IAAI4F,GAC1B/L,KAAK2B,IAAI+U,EAAO,GAAK1W,KAAK2B,IAAI+U,EAAO,GAG7C,OAAOhC,GAFG,EAAI1U,KAAK0G,MAAM1G,KAAKqG,KAAKE,GAAIvG,KAAKqG,KAAK,EAAIE,IAGzD,EC/tCOoQ,eAAeC,EAAepL,EAAU,IAC7C,MAAMtE,gBACJA,EAAkB,SAAQ2P,WAC1BA,EAAa,WACXrL,EAGJ,GAAIA,EAAQtE,gBACV,IACE,MAAMN,mBAAEA,SAA6BzE,QAAiCC,UAAA0U,MAAA,WAAA,OAAAC,CAAA,IACtEnQ,EAAmBE,eAAeI,EACnC,CAAC,MAAOxI,GAEP,OADAH,QAAQG,MAAM,mCAAmCA,EAAMuC,YAChD,CACb,CAIE,GAAmB,YAAf4V,EACF,IACE,MAAMtV,WAAEA,SAAqBY,QAAyBC,UAAA0U,MAAA,WAAA,OAAAE,CAAA,UAChDzV,EAAWS,UAAU6U,EAC5B,CAAC,MAAOnY,GAEP,OADAH,QAAQG,MAAM,+BAA+BA,EAAMuC,YAC5C,CACb,CAGE,OAAO,CACT,CC7CO,MAAMgW,UAAoB3Z,EAU/B,WAAAC,CAAYiO,EAAU,IAGpB,GAFAlJ,QAEI9E,KAAKD,cAAgB0Z,EACvB,MAAM,IAAIhY,MAAM,iEAGlBzB,KAAK0Z,GAAK1L,EAAQ0L,IAAM,WAAWC,KAAKC,SAASpX,KAAKqX,MAAsB,IAAhBrX,KAAKsX,YACjE9Z,KAAK+Z,KAAO/L,EAAQ+L,MAAQ,WAAW/Z,KAAK0Z,GAAGM,QAAS,KACxDha,KAAKkF,KAAO,UACZlF,KAAKia,MAAQjM,EAAQiM,OAAS,CAAE,EAChCja,KAAKka,WAAalM,EAAQkM,YAAc,CAAE,EAC1Cla,KAAKma,SAAWnM,EAAQmM,UAAY,CAAE,EACtCna,KAAKoa,UAAW,EAChBpa,KAAKqa,SAA8B,IAApBrM,EAAQqM,QACvBra,KAAKsa,UAAgC,IAArBtM,EAAQsM,SACxBta,KAAKua,aAAsC,IAAxBvM,EAAQuM,YAC3Bva,KAAKwa,SAAW,KAChBxa,KAAKya,UAAYzM,EAAQyM,WAAad,KAAKC,MAC3C5Z,KAAK0a,WAAa1M,EAAQ0M,YAAc,IAC5C,CAME,OAAAC,GACE,OAAO3a,KAAKkF,IAChB,CAME,SAAA0V,GACE,MAAM,IAAInZ,MAAM,4CACpB,CAME,SAAAoZ,GACE,MAAM,IAAIpZ,MAAM,4CACpB,CAME,iBAAAqZ,GACE,MAAM,IAAIrZ,MAAM,oDACpB,CAQE,QAAAsZ,CAAShZ,EAAa2V,EAAW,IAC/B,MAAM,IAAIjW,MAAM,2CACpB,CAOE,OAAAuZ,CAAQjZ,GACN,MAAM,IAAIN,MAAM,0CACpB,CAOE,SAAAuK,CAAU0L,EAAW,IACnB,MAAM,IAAIjW,MAAM,4CACpB,CAQE,WAAAwZ,CAAYC,EAAUxD,EAAW,IAC/B,MAAM,IAAIjW,MAAM,8CACpB,CAME,KAAA+E,GACE,MAAM,IAAI/E,MAAM,wCACpB,CAOE,QAAA0Z,CAASlB,EAAOjM,EAAU,IACxBhO,KAAKia,MAAQ,IAAKja,KAAKia,SAAUA,GACjCja,KAAKa,KAAK,gBAAiB,CAAEua,QAASpb,KAAMia,MAAOja,KAAKia,MAAOjM,WACnE,CAME,QAAAqN,GACE,MAAO,IAAKrb,KAAKia,MACrB,CAME,aAAAqB,CAAcpB,GACZla,KAAKka,WAAa,IAAKla,KAAKka,cAAeA,GAC3Cla,KAAKa,KAAK,qBAAsB,CAAEua,QAASpb,KAAMka,WAAYla,KAAKka,YACtE,CAME,aAAAqB,GACE,MAAO,IAAKvb,KAAKka,WACrB,CAOE,WAAAsB,CAAYzB,GACV,OAAO/Z,KAAKka,WAAWH,EAC3B,CAOE,WAAA0B,CAAY1B,EAAM2B,GAChB1b,KAAKka,WAAWH,GAAQ2B,EACxB1b,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAM+Z,OAAM2B,SACzD,CAME,OAAAC,CAAQ5B,GACN/Z,KAAK+Z,KAAOA,EACZ/Z,KAAKa,KAAK,eAAgB,CAAEua,QAASpb,KAAM+Z,QAC/C,CAME,OAAA6B,GACE,OAAO5b,KAAK+Z,IAChB,CAME,MAAA8B,CAAO7N,EAAU,IACVhO,KAAKoa,WACRpa,KAAKoa,UAAW,EAChBpa,KAAKa,KAAK,WAAY,CAAEua,QAASpb,KAAMgO,YAE7C,CAME,QAAA8N,CAAS9N,EAAU,IACbhO,KAAKoa,WACPpa,KAAKoa,UAAW,EAChBpa,KAAKa,KAAK,aAAc,CAAEua,QAASpb,KAAMgO,YAE/C,CAOE,eAAA+N,CAAgB/N,EAAU,IAMxB,OALIhO,KAAKoa,SACPpa,KAAK8b,SAAS9N,GAEdhO,KAAK6b,OAAO7N,GAEPhO,KAAKoa,QAChB,CAKE,IAAA4B,GACOhc,KAAKqa,UACRra,KAAKqa,SAAU,EACfra,KAAKa,KAAK,qBAAsB,CAAEua,QAASpb,KAAMqa,SAAS,IAEhE,CAKE,IAAA4B,GACMjc,KAAKqa,UACPra,KAAKqa,SAAU,EACfra,KAAKa,KAAK,qBAAsB,CAAEua,QAASpb,KAAMqa,SAAS,IAEhE,CAME,gBAAA6B,GAGE,OAFAlc,KAAKqa,SAAWra,KAAKqa,QACrBra,KAAKa,KAAK,qBAAsB,CAAEua,QAASpb,KAAMqa,QAASra,KAAKqa,UACxDra,KAAKqa,OAChB,CAKE,aAAA8B,GACOnc,KAAKsa,WACRta,KAAKsa,UAAW,EAChBta,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAMsa,UAAU,IAE/D,CAKE,cAAA8B,GACMpc,KAAKsa,WACPta,KAAKsa,UAAW,EAChBta,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAMsa,UAAU,IAE/D,CAME,WAAA+B,CAAYC,GACVtc,KAAKwa,SAAW8B,CACpB,CAME,WAAAC,GACE,OAAOvc,KAAKwa,QAChB,CAME,UAAAgC,GACE,OAAyB,OAAlBxc,KAAKwa,QAChB,EC/RO,MAAMiC,UAAqBhD,EAWhC,WAAA1Z,CAAY6C,EAAYoL,EAAU,IAMhC,GALAlJ,MAAMkJ,GAENhO,KAAKkF,KAAO,QAGRtC,aAAsBS,EAExBrD,KAAK4C,WAAaA,MACb,IAA0B,iBAAfA,EAgDhB,MADA7B,QAAQG,MAAM,kCAAmC0B,GAC3C,IAAInB,MAAM,6CA/ChB,QAA4BgG,IAAxB7E,EAAWgI,eAAmDnD,IAAzB7E,EAAWiI,UAAyB,CAE3E,MAAM6R,OAAwCjV,IAAzB7E,EAAWK,UAA0BL,EAAWK,eAC/CwE,IAAnB7E,EAAWmI,IAAoBnI,EAAWmI,IAAM,KAGnD/K,KAAK4C,WAAa,CAChBG,IAAKH,EAAWgI,SAChBlI,IAAKE,EAAWiI,UAChB5H,UAAWyZ,EACXvQ,SAAU,WAAa,MAAO,GAAGnM,KAAK+C,QAAQ/C,KAAK0C,QAAQ1C,KAAKiD,WAAa,GAAM,EAE7F,MAAa,QAAuBwE,IAAnB7E,EAAWG,UAAwC0E,IAAnB7E,EAAWF,IAAmB,CAEvE,MAAMga,OAAwCjV,IAAzB7E,EAAWK,UAA0BL,EAAWK,eAC/CwE,IAAnB7E,EAAWmI,IAAoBnI,EAAWmI,IAAM,KAG9CnI,EAAWuJ,WACdvJ,EAAWuJ,SAAW,WAAa,MAAO,GAAGnM,KAAK+C,QAAQ/C,KAAK0C,QAAQ1C,KAAKiD,WAAa,GAAM,GAI7FyZ,UACF9Z,EAAWK,UAAYyZ,GAGzB1c,KAAK4C,WAAaA,CAC1B,KAAa,MAAI+Z,MAAMC,QAAQha,IAAeA,EAAWoK,QAAU,GAe3D,MADAjM,QAAQG,MAAM,6BAA8B0B,GACtC,IAAInB,MAAM,6BAf8C,CAE9D,MAAMsB,EAAMH,EAAW,GACjBF,EAAME,EAAW,GACjBK,EAAYL,EAAWoK,OAAS,EAAIpK,EAAW,GAAK,KAG1D5C,KAAK4C,WAAa,CAChBG,IAAKA,EACLL,IAAKA,EACLO,UAAWA,EACXkJ,SAAU,WAAa,MAAO,GAAGnM,KAAK+C,QAAQ/C,KAAK0C,QAAQ1C,KAAKiD,WAAa,GAAM,EAE7F,CAGA,CAIA,CAGI,IAAK+K,EAAQ+L,KAAM,CAEjB,MAAMhX,EAAM/C,KAAK4C,WAAWG,KAAO/C,KAAK4C,WAAWgI,SAC7ClI,EAAM1C,KAAK4C,WAAWF,KAAO1C,KAAK4C,WAAWiI,UACnD7K,KAAK+Z,KAAO,SAAShX,EAAIC,QAAQ,OAAON,EAAIM,QAAQ,IAC1D,CAGI,MAAMC,EAAYjD,KAAK4C,WAAWK,UAC9BA,UACFjD,KAAKka,WAAWjX,UAAYA,EAElC,CAME,aAAA4Z,GAGE,OAAO7c,KAAK4C,UAChB,CAME,aAAAka,CAAcla,GAEZ,IAAIA,KAAeA,aAAsBS,GACV,iBAAfT,SACa6E,IAAnB7E,EAAWG,UAA6C0E,IAAxB7E,EAAWgI,WAmBnD,MADA7J,QAAQG,MAAM,6BAA8B0B,GACtC,IAAInB,MAAM,qDAnB8D,CAG9EzB,KAAK4C,WAAaA,EAGlB,MAAMK,OAAqCwE,IAAzB7E,EAAWK,UAA0BL,EAAWK,eAC7CwE,IAAnB7E,EAAWmI,IAAoBnI,EAAWmI,IAAM,KAG9C9H,QACFjD,KAAKka,WAAWjX,UAAYA,SAErBjD,KAAKka,WAAWjX,UAGzBjD,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAM4C,WAAY5C,KAAK4C,YACtE,CAIA,CAME,SAAAgY,GAEE,MAAO,CACLmC,UAAW/c,KAAK4C,WAAW4D,QAC3BwW,UAAWhd,KAAK4C,WAAW4D,QAC3BhB,MAAOxF,KAAK4C,WAAWG,IACvBka,KAAMjd,KAAK4C,WAAWF,IACtBwa,MAAOld,KAAK4C,WAAWG,IACvBoa,KAAMnd,KAAK4C,WAAWF,IAE5B,CAME,SAAAmY,GACE,OAAO7a,KAAK4C,UAChB,CAME,iBAAAkY,GACE,MAAM7X,EAAYjD,KAAK4C,WAAWK,WAAa,EAC/C,MAAO,CACLuH,IAAKvH,EACLsH,IAAKtH,EACLma,MAAO,EAEb,CAUE,QAAArC,CAASnY,EAAYoL,EAAU,IAE7B,IAAKpL,GAAoC,iBAAfA,QACE6E,IAAnB7E,EAAWG,UAA6C0E,IAAxB7E,EAAWgI,SAElD,OADA7J,QAAQG,MAAM,6BAA8B0B,IACrC,EAGT,MAAMya,EAAYrP,EAAQqP,WAAa,EAEvC,GAAkB,IAAdA,EAAiB,CAEnB,MAAMC,EAAWtd,KAAK4C,WAAWG,KAAO/C,KAAK4C,WAAWgI,SAClD2S,EAAWvd,KAAK4C,WAAWF,KAAO1C,KAAK4C,WAAWiI,UAClD2S,EAAW5a,EAAWG,KAAOH,EAAWgI,SACxC6S,EAAW7a,EAAWF,KAAOE,EAAWiI,UAG9C,OAAOyS,IAAaE,GAAYD,IAAaE,CACnD,CAEM,IAME,OALiB3Q,EAAee,kBAC9B7N,KAAK4C,WACLA,EACA,CAAEqL,iBAAkBD,EAAQC,oBAEXoP,CACpB,CAAC,MAAOnc,GAEP,OADAH,QAAQG,MAAM,iDAAkDA,IACzD,CACf,CAEA,CAOE,OAAA8Z,CAAQpY,GAEN,IAAKA,GAAoC,iBAAfA,QACE6E,IAAnB7E,EAAWG,UAA6C0E,IAAxB7E,EAAWgI,SAElD,MADA7J,QAAQG,MAAM,6BAA8B0B,GACtC,IAAInB,MAAM,qDAGlB,IACE,MAAMkO,EAAW7C,EAAee,kBAC9B7N,KAAK4C,WACLA,EACA,CAAEqL,kBAAkB,IAItB,MAAO,CAELrL,WAAY5C,KAAK4C,WACjB+M,WAEH,CAAC,MAAOzO,GAEP,OADAH,QAAQG,MAAM,mCAAoCA,GAC3C,CACL0B,WAAY5C,KAAK4C,WACjB+M,SAAU+N,IAElB,CACA,CASE,SAAA1R,CAAUgC,EAAU,IAClB,MAAMC,GAAgD,IAA7BD,EAAQC,iBAC3B0P,GAAkD,IAA9B3P,EAAQ2P,kBAE5BC,EAAU,CACd1Y,KAAM,UACN2Y,SAAU,CACR3Y,KAAM,QACNgH,YAAa,CACXlM,KAAK4C,WAAWF,IAChB1C,KAAK4C,WAAWG,MAGpB2W,GAAI1Z,KAAK0Z,IAgBX,OAZIzL,GAAkD,OAA9BjO,KAAK4C,WAAWK,gBAAoDwE,IAA9BzH,KAAK4C,WAAWK,WAC5E2a,EAAQC,SAAS3R,YAAY5L,KAAKN,KAAK4C,WAAWK,WAIhD0a,IACFC,EAAQ1D,WAAa,CACnBH,KAAM/Z,KAAK+Z,QACR/Z,KAAKka,aAIL0D,CACX,CAQE,WAAA3C,CAAY2C,EAASlG,EAAW,IAC9B,IAAKkG,GAA4B,YAAjBA,EAAQ1Y,OAAuB0Y,EAAQC,UACrB,UAA1BD,EAAQC,SAAS3Y,OAAqByX,MAAMC,QAAQgB,EAAQC,SAAS3R,aAC3E,OAAO,EAGT,MAAM4R,EAASF,EAAQC,SAAS3R,YAChC,GAAI4R,EAAO9Q,OAAS,EAClB,OAAO,EAIT,MAAMnC,EAAYiT,EAAO,GACnBlT,EAAWkT,EAAO,GAClB7a,EAAY6a,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,KA0BlD,OAvBA9d,KAAK4C,WAAa,IAAIS,EAAWuH,EAAUC,EAAW5H,GAGlD2a,EAAQ1D,aACN0D,EAAQ1D,WAAWH,OACrB/Z,KAAK+Z,KAAO6D,EAAQ1D,WAAWH,YACxB6D,EAAQ1D,WAAWH,MAG5B/Z,KAAKka,WAAa,IAAK0D,EAAQ1D,aAI7B0D,EAAQlE,KACV1Z,KAAK0Z,GAAKkE,EAAQlE,IAIhBzW,UACFjD,KAAKka,WAAWjX,UAAYA,GAG9BjD,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAM4C,WAAY5C,KAAK4C,cACzD,CACX,CAME,KAAA4D,GAeE,OAde,IAAIiW,EACjBzc,KAAK4C,WAAW4D,QAChB,CACEkT,GAAI,SAAS1Z,KAAK0Z,KAClBK,KAAM,GAAG/Z,KAAK+Z,cACdE,MAAO,IAAKja,KAAKia,OACjBC,WAAY,IAAKla,KAAKka,YACtBC,SAAU,IAAKna,KAAKma,UACpBE,QAASra,KAAKqa,QACdC,SAAUta,KAAKsa,SACfC,YAAava,KAAKua,aAK1B,CASE,UAAAnP,CAAWwC,EAAOI,EAAU,IAC1B,MAAM1C,EAAasC,aAAiB6O,EAAe7O,EAAMiP,gBAAkBjP,EAE3E,KAAMtC,aAAsBjI,GAC1B,MAAM,IAAI5B,MAAM,8CAGlB,OAAOqL,EAAee,kBACpB7N,KAAK4C,WACL0I,EACA,CAAE2C,kBAA+C,IAA7BD,EAAQC,kBAElC,CAOE,SAAAxC,CAAUmC,GACR,MAAMtC,EAAasC,aAAiB6O,EAAe7O,EAAMiP,gBAAkBjP,EAE3E,KAAMtC,aAAsBjI,GAC1B,MAAM,IAAI5B,MAAM,8CAGlB,OAAOqL,EAAeuD,iBAAiBrQ,KAAK4C,WAAY0I,EAC5D,CAUE,wBAAAyS,CAAyBpO,EAAUjE,EAASsC,EAAU,CAAA,GACpD,MAAMgQ,GAAkD,IAA9BhQ,EAAQgQ,kBAC5B/a,EAAY+a,EAAoBhe,KAAK4C,WAAWK,UAAY,KAE5Dgb,EAAWnR,EAAeqH,sBAC9BnU,KAAK4C,WACL+M,EACAjE,GAQF,OALIsS,SAAqB/a,IACvBgb,EAAShb,UAAYA,GAGvBjD,KAAK8c,cAAcmB,GACZje,IACX,CAOE,MAAAke,CAAOtb,GAEL,OADA5C,KAAK8c,cAAcla,GACZ5C,IACX,uDCtaO,MAAMme,UAAoB1E,EAY/B,WAAA1Z,CAAYmM,EAAc,GAAI8B,EAAU,CAAA,GACtClJ,MAAMkJ,GAENhO,KAAKkF,KAAO,OACZlF,KAAK8T,OAAS9F,EAAQ8F,SAAU,EAGhC9T,KAAKkM,YAAclM,KAAKoe,qBAAqBlS,GAG7ClM,KAAKqe,oBAGArQ,EAAQ+L,OACX/Z,KAAK+Z,KAAO/Z,KAAK8T,OACf,gBAAgB9T,KAAKkM,YAAYc,mBACjC,SAAShN,KAAKkM,YAAYc,mBAElC,CAQE,oBAAAoR,CAAqBlS,GACnB,IAAKyQ,MAAMC,QAAQ1Q,GACjB,MAAM,IAAIzK,MAAM,gCAGlB,OAAOyK,EAAY6F,KAAI5D,IACrB,GAAIA,aAAiB9K,EACnB,OAAO8K,EACF,GAAqB,iBAAVA,EAAoB,CACpC,QAAuB1G,IAAnB0G,EAAMvD,eAA8CnD,IAApB0G,EAAMtD,UAAyB,CAEjE,MAAM5H,OAAgCwE,IAApB0G,EAAMlL,UAA0BkL,EAAMlL,eACvCwE,IAAd0G,EAAMpD,IAAoBoD,EAAMpD,IAAM,KACzC,OAAO,IAAI1H,EAAW8K,EAAMvD,SAAUuD,EAAMtD,UAAW5H,EACjE,CAAe,QAAkBwE,IAAd0G,EAAMpL,UAAmC0E,IAAd0G,EAAMzL,IAAmB,CAE7D,MAAMO,OAAgCwE,IAApB0G,EAAMlL,UAA0BkL,EAAMlL,eACvCwE,IAAd0G,EAAMpD,IAAoBoD,EAAMpD,IAAM,KACzC,OAAO,IAAI1H,EAAW8K,EAAMpL,IAAKoL,EAAMzL,IAAKO,EACtD,CAAe,GAAI0Z,MAAMC,QAAQzO,IAAUA,EAAMnB,QAAU,EAEjD,OAAO,IAAI3J,EAAW8K,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAAM,KAEhE,CAEM,MAAM,IAAI1M,MAAM,qCAAqC,GAE3D,CAME,iBAAA4c,GACE,GAAIre,KAAKkM,YAAYc,OAAS,EAE5B,YADAhN,KAAKka,WAAWlN,OAAS,GAK3BhN,KAAKka,WAAWlN,OAASF,EAAeyC,oBAAoBvP,KAAKkM,YAAa,CAAE+B,kBAAkB,IAGlG,MAAMqQ,EAAate,KAAKkM,YACrB6F,KAAI5D,GAASA,EAAMlL,YACnB1C,QAAOqD,GAAQA,UAEd0a,EAAWtR,OAAS,IACtBhN,KAAKka,WAAWqE,aAAe/b,KAAKgI,OAAO8T,GAC3Cte,KAAKka,WAAWsE,aAAehc,KAAK+H,OAAO+T,GAC3Cte,KAAKka,WAAWuE,cAAgB3R,EAAeC,uBAAuB/M,KAAKkM,aAC3ElM,KAAKka,WAAWwE,cAAgB5R,EAAeQ,uBAAuBtN,KAAKkM,aAEjF,CAME,cAAAyS,GACE,MAAO,IAAI3e,KAAKkM,YACpB,CAME,cAAA0S,CAAe1S,GACblM,KAAKkM,YAAclM,KAAKoe,qBAAqBlS,GAC7ClM,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAMkM,YAAalM,KAAKkM,aACrE,CAOE,aAAA2S,CAAcjc,EAAYkc,EAAQ,MAChC,KAAMlc,aAAsBS,GAC1B,MAAM,IAAI5B,MAAM,sDAGJ,OAAVqd,EAEF9e,KAAKkM,YAAY5L,KAAKsC,GAGtB5C,KAAKkM,YAAY6S,OAAOD,EAAO,EAAGlc,GAGpC5C,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KACTkM,YAAalM,KAAKkM,YAClB8S,OAAQ,MACRpc,aACAkc,MAAiB,OAAVA,EAAiB9e,KAAKkM,YAAYc,OAAS,EAAI8R,GAE5D,CAOE,gBAAAG,CAAiBH,GACf,GAAIA,EAAQ,GAAKA,GAAS9e,KAAKkM,YAAYc,OACzC,OAAO,KAGT,MAAMkS,EAAUlf,KAAKkM,YAAY6S,OAAOD,EAAO,GAAG,GAWlD,OAVA9e,KAAKqe,oBAELre,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KACTkM,YAAalM,KAAKkM,YAClB8S,OAAQ,SACRpc,WAAYsc,EACZJ,UAGKI,CACX,CAQE,gBAAAC,CAAiBL,EAAOlc,GACtB,GAAIkc,EAAQ,GAAKA,GAAS9e,KAAKkM,YAAYc,OACzC,OAAO,EAGT,KAAMpK,aAAsBS,GAC1B,MAAM,IAAI5B,MAAM,sDAGlB,MAAM2d,EAAWpf,KAAKkM,YAAY4S,GAalC,OAZA9e,KAAKkM,YAAY4S,GAASlc,EAC1B5C,KAAKqe,oBAELre,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KACTkM,YAAalM,KAAKkM,YAClB8S,OAAQ,SACRK,cAAeD,EACfE,cAAe1c,EACfkc,WAGK,CACX,CAME,cAAAS,GACE,OAAOvf,KAAKkM,YAAYc,MAC5B,CAOE,SAAAwS,CAAUV,GACR,OAAIA,EAAQ,GAAKA,GAAS9e,KAAKkM,YAAYc,OAClC,KAGFhN,KAAKkM,YAAY4S,EAC5B,CAME,YAAAW,GASE,OARAzf,KAAK8T,QAAU9T,KAAK8T,OACpB9T,KAAKqe,oBAELre,KAAKa,KAAK,iBAAkB,CAC1Bua,QAASpb,KACT8T,OAAQ9T,KAAK8T,SAGR9T,KAAK8T,MAChB,CAME,SAAA4L,CAAU5L,GACJ9T,KAAK8T,SAAWA,IAClB9T,KAAK8T,OAASA,EACd9T,KAAKqe,oBAELre,KAAKa,KAAK,iBAAkB,CAC1Bua,QAASpb,KACT8T,OAAQ9T,KAAK8T,SAGrB,CAME,QAAA6L,GACE,OAAO3f,KAAK8T,MAChB,CAME,SAAA8G,GACE,GAAgC,IAA5B5a,KAAKkM,YAAYc,OACnB,OAAO,KAGT,IAAIxH,GAAW,GACX0X,EAAQ,GACRD,GAAW,IACXE,EAAO,IAEX,IAAK,MAAMhP,KAASnO,KAAKkM,YACvB1G,EAAQhD,KAAK+H,IAAI/E,EAAO2I,EAAMpL,KAC9Bma,EAAQ1a,KAAKgI,IAAI0S,EAAO/O,EAAMpL,KAC9Bka,EAAOza,KAAK+H,IAAI0S,EAAM9O,EAAMzL,KAC5Bya,EAAO3a,KAAKgI,IAAI2S,EAAMhP,EAAMzL,KAG9B,MAAO,CACL8C,QACA0X,QACAD,OACAE,OACAJ,UAAW,IAAI1Z,EAAWmC,EAAOyX,GACjCD,UAAW,IAAI3Z,EAAW6Z,EAAOC,GAEvC,CAME,SAAAtC,GACE,OAAgC,IAA5B7a,KAAKkM,YAAYc,OACZ,KAC8B,IAA5BhN,KAAKkM,YAAYc,OACnBhN,KAAKkM,YAAY,GAInBY,EAAeyG,oBAAoBvT,KAAKkM,YACnD,CAME,iBAAA4O,GACE,GAAgC,IAA5B9a,KAAKkM,YAAYc,OACnB,MAAO,CAAExC,IAAK,EAAGD,IAAK,EAAG6S,MAAO,GAGlC,MAAMkB,EAAate,KAAKkM,YACrB6F,KAAI5D,GAASA,EAAMlL,YACnB1C,QAAOqD,GAAQA,UAElB,GAA0B,IAAtB0a,EAAWtR,OACb,MAAO,CAAExC,IAAK,EAAGD,IAAK,EAAG6S,MAAO,GAGlC,MAAM5S,EAAMhI,KAAKgI,OAAO8T,GAClB/T,EAAM/H,KAAK+H,OAAO+T,GAExB,MAAO,CACL9T,MACAD,MACA6S,MAAO7S,EAAMC,EAEnB,CAUE,QAAAuQ,CAASnY,EAAYoL,EAAU,IAC7B,GAAIhO,KAAKkM,YAAYc,OAAS,EAC5B,OAAO,EAGT,KAAMpK,aAAsBS,GAC1B,MAAM,IAAI5B,MAAM,sDAGlB,MAAM4b,EAAYrP,EAAQqP,WAAa,EAKvC,OAFgBrd,KAAKgb,QAAQpY,GAEd+M,UAAY0N,CAC/B,CAOE,OAAArC,CAAQpY,GACN,GAAI5C,KAAKkM,YAAYc,OAAS,EAAG,CAC/B,GAAgC,IAA5BhN,KAAKkM,YAAYc,OAAc,CACjC,MAAM2C,EAAW7C,EAAee,kBAC9B7N,KAAKkM,YAAY,GACjBtJ,EACA,CAAEqL,kBAAkB,IAGtB,MAAO,CACLrL,WAAY5C,KAAKkM,YAAY,GAAG1F,QAChCmJ,WACAiQ,aAAc,EACd7P,gBAAiB,EAE3B,CAEM,MAAO,CACLnN,WAAY,KACZ+M,SAAU+N,IACVkC,cAAgB,EAChB7P,gBAAiB,EAEzB,CAEI,KAAMnN,aAAsBS,GAC1B,MAAM,IAAI5B,MAAM,sDAIlB,OAAOqL,EAAe+S,4BAA4B7f,KAAKkM,YAAatJ,EAAY,CAAEkR,OAAQ9T,KAAK8T,QACnG,CASE,SAAA9H,CAAUgC,EAAU,IAClB,MAAMC,GAAgD,IAA7BD,EAAQC,iBAC3B0P,GAAkD,IAA9B3P,EAAQ2P,kBAG5BzY,EAAOlF,KAAK8T,OAAS,UAAY,aAEvC,IAAI5H,EAEJ,GAAa,eAAThH,EAEFgH,EAAclM,KAAKkM,YAAY6F,KAAI5D,IAEjC,MAAMP,EAAQ,CAACO,EAAMzL,IAAKyL,EAAMpL,KAIhC,OAHIkL,GAAwC,OAApBE,EAAMlL,gBAA0CwE,IAApB0G,EAAMlL,WACxD2K,EAAMtN,KAAK6N,EAAMlL,WAEZ2K,CAAK,QAET,CAGL,MAAMkS,EAAO,IAAI9f,KAAKkM,aAClB4T,EAAK9S,OAAS,IACP8S,EAAK,GAAG/c,MAAQ+c,EAAKA,EAAK9S,OAAS,GAAGjK,KACtC+c,EAAK,GAAGpd,MAAQod,EAAKA,EAAK9S,OAAS,GAAGtK,MAC/Cod,EAAKxf,KAAKwf,EAAK,IAGjB5T,EAAc,CAAC4T,EAAK/N,KAAI5D,IAEtB,MAAMP,EAAQ,CAACO,EAAMzL,IAAKyL,EAAMpL,KAIhC,OAHIkL,GAAwC,OAApBE,EAAMlL,gBAA0CwE,IAApB0G,EAAMlL,WACxD2K,EAAMtN,KAAK6N,EAAMlL,WAEZ2K,CAAK,IAEpB,CAEI,MAAMgQ,EAAU,CACd1Y,KAAM,UACN2Y,SAAU,CACR3Y,OACAgH,eAEFwN,GAAI1Z,KAAK0Z,IAWX,OAPIiE,IACFC,EAAQ1D,WAAa,CACnBH,KAAM/Z,KAAK+Z,QACR/Z,KAAKka,aAIL0D,CACX,CAQE,WAAA3C,CAAY2C,EAASlG,EAAW,IAC9B,IAAKkG,GAA4B,YAAjBA,EAAQ1Y,OAAuB0Y,EAAQC,SACrD,OAAO,EAGT,MAAMkC,EAAenC,EAAQC,SAAS3Y,KACtC,IAAI8a,EAAiB,GACjBL,GAAW,EAEf,GAAqB,eAAjBI,EAA+B,CACjC,IAAKpD,MAAMC,QAAQgB,EAAQC,SAAS3R,aAClC,OAAO,EAIT8T,EAAiBpC,EAAQC,SAAS3R,YAAY6F,KAAI+L,IAChD,IAAKnB,MAAMC,QAAQkB,IAAWA,EAAO9Q,OAAS,EAC5C,MAAM,IAAIvL,MAAM,0CAGlB,OAAO,IAAI4B,EACTya,EAAO,GACPA,EAAO,GACPA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,KACjC,IAIH,MAAMmC,EAAQD,EAAe,GACvBE,EAAOF,EAAeA,EAAehT,OAAS,GAEhDiT,GAASC,GACHD,EAAMld,MAAQmd,EAAKnd,KACnBkd,EAAMvd,MAAQwd,EAAKxd,MAC3Bid,GAAW,EAGnB,KAAW,IAAqB,YAAjBI,EAmCT,OAAO,EAnC8B,CACrC,IAAKpD,MAAMC,QAAQgB,EAAQC,SAAS3R,eACzByQ,MAAMC,QAAQgB,EAAQC,SAAS3R,YAAY,IACpD,OAAO,EAMT8T,EAFapC,EAAQC,SAAS3R,YAAY,GAEpB6F,KAAI+L,IACxB,IAAKnB,MAAMC,QAAQkB,IAAWA,EAAO9Q,OAAS,EAC5C,MAAM,IAAIvL,MAAM,uCAGlB,OAAO,IAAI4B,EACTya,EAAO,GACPA,EAAO,GACPA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,KACjC,IAIH,MAAMmC,EAAQD,EAAe,GACvBE,EAAOF,EAAeA,EAAehT,OAAS,GAEhDiT,GAASC,GACHD,EAAMrV,WAAasV,EAAKtV,UACxBqV,EAAMpV,YAAcqV,EAAKrV,WAEjCmV,EAAeG,MAGjBR,GAAW,CAEjB,CAEA,CAwBI,OArBA3f,KAAKkM,YAAc8T,EACnBhgB,KAAK8T,OAAS6L,EAGV/B,EAAQ1D,aACN0D,EAAQ1D,WAAWH,OACrB/Z,KAAK+Z,KAAO6D,EAAQ1D,WAAWH,YACxB6D,EAAQ1D,WAAWH,MAG5B/Z,KAAKka,WAAa,IAAK0D,EAAQ1D,aAI7B0D,EAAQlE,KACV1Z,KAAK0Z,GAAKkE,EAAQlE,IAGpB1Z,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAMkM,YAAalM,KAAKkM,eAE1D,CACX,CAME,KAAA1F,GACE,MAAM4Z,EAAoBpgB,KAAKkM,YAAY6F,KAAI5D,GAASA,EAAM3H,UAiB9D,OAfe,IAAI2X,EACjBiC,EACA,CACE1G,GAAI,SAAS1Z,KAAK0Z,KAClBK,KAAM,GAAG/Z,KAAK+Z,cACdE,MAAO,IAAKja,KAAKia,OACjBC,WAAY,IAAKla,KAAKka,YACtBC,SAAU,IAAKna,KAAKma,UACpBE,QAASra,KAAKqa,QACdC,SAAUta,KAAKsa,SACfC,YAAava,KAAKua,YAClBzG,OAAQ9T,KAAK8T,QAKrB,CAQE,eAAAuM,CAAgBrS,EAAU,IACxB,OAAIhO,KAAKkM,YAAYc,OAAS,EACrB,EAGFF,EAAeyC,oBACpBvP,KAAKkM,YACL,CACE+B,kBAA+C,IAA7BD,EAAQC,iBAC1B6F,OAAQ9T,KAAK8T,QAGrB,CAOE,aAAAjF,CAAcb,EAAU,IACtB,OAAKhO,KAAK8T,QAAU9T,KAAKkM,YAAYc,OAAS,EACrC,EAGFF,EAAe+B,cAAc7O,KAAKkM,YAAa8B,EAC1D,CAME,sBAAAsS,GACE,OAAItgB,KAAKkM,YAAYc,OAAS,EACrB,GAGFF,EAAewT,uBAAuBtgB,KAAKkM,YACtD,CAME,wBAAAqU,GACE,OAAIvgB,KAAKkM,YAAYc,OAAS,EACrB,CAAEwT,KAAM,EAAGC,KAAM,GAGnB,CACLD,KAAM1T,EAAeC,uBAAuB/M,KAAKkM,aACjDuU,KAAM3T,EAAeQ,uBAAuBtN,KAAKkM,aAEvD,CAQE,gBAAA0H,CAAiBjE,EAAU3B,EAAU,IACnC,GAAIhO,KAAKkM,YAAYc,OAAS,EAC5B,OAAOhN,KAAKwG,QAGd,MAAMka,EAAe5T,EAAe8G,iBAClC5T,KAAKkM,YACLyD,EACA,CACEmE,OAAQ9T,KAAK8T,UACV9F,IAIP,OAAO,IAAImQ,EACTuC,EACA,CACE3G,KAAM,GAAG/Z,KAAK+Z,gBAAgBpK,MAC9BsK,MAAO,IAAKja,KAAKia,OACjBnG,OAAQ9T,KAAK8T,QAGrB,CAOE,QAAA6M,CAAStD,GACP,GAAIrd,KAAKkM,YAAYc,OAAS,GAAKqQ,GAAa,EAC9C,OAAOrd,KAGT,MAAM4gB,EAAa9T,EAAe+T,aAAa7gB,KAAKkM,YAAamR,GAGjE,OAFArd,KAAK4e,eAAegC,GAEb5gB,IACX,CAQE,mBAAA8gB,CAAoBC,EAAU/S,EAAU,IACtC,OAAIhO,KAAKkM,YAAYc,OAAS,GAAK+T,GAAY,EACtC,GAGFjU,EAAekU,6BACpBhhB,KAAKkM,YACL6U,EACA,CACEjN,OAAQ9T,KAAK8T,UACV9F,GAGX,CAOE,oBAAAiT,CAAqBC,GACnB,GAAIlhB,KAAKkM,YAAYc,OAAS,EAC5B,OAAO,KAGLkU,EAAa,IAAGA,EAAa,GAC7BA,EAAa,MAAKA,EAAa,KAEnC,MAAMvR,EAAYuR,EAAa,IAAOlhB,KAAKqgB,kBAC3C,OAAOrgB,KAAKmhB,mBAAmBxR,EACnC,CAOE,kBAAAwR,CAAmBxR,GACjB,OAAI3P,KAAKkM,YAAYc,OAAS,EACrB,KAGFF,EAAeqU,mBAAmBnhB,KAAKkM,YAAayD,EAAU,CAAEmE,OAAQ9T,KAAK8T,QACxF,CAOE,aAAAsN,CAActC,GACZ,GAAIA,GAAS,GAAKA,GAAS9e,KAAKkM,YAAYc,OAAS,EACnD,MAAO,CAAChN,KAAKwG,SAqBf,MAAO,CAlBO,IAAI2X,EAChBne,KAAKkM,YAAYmV,MAAM,EAAGvC,EAAQ,GAClC,CACE/E,KAAM,GAAG/Z,KAAK+Z,gBACdE,MAAO,IAAKja,KAAKia,OACjBnG,QAAQ,IAIE,IAAIqK,EAChBne,KAAKkM,YAAYmV,MAAMvC,GACvB,CACE/E,KAAM,GAAG/Z,KAAK+Z,gBACdE,MAAO,IAAKja,KAAKia,OACjBnG,QAAQ,IAKhB,CAME,OAAAwN,GAGE,OAFAthB,KAAKkM,YAAYoV,UACjBthB,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,KAAMkM,YAAalM,KAAKkM,cAC1DlM,IACX,EC/wBO,MAAMuhB,UAAuB9H,EAYlC,WAAA1Z,CAAYmM,EAAc,GAAI8B,EAAU,CAAA,GAWtC,GAVAlJ,MAAMkJ,GAENhO,KAAKkF,KAAO,UAGZlF,KAAK2S,aAAe,IAAIwL,EAAYjS,EAAa,CAAE4H,QAAQ,IAG3D9T,KAAKwhB,cAAgB,GAEjBxT,EAAQ4E,OAAS+J,MAAMC,QAAQ5O,EAAQ4E,OACzC,IAAK,MAAM6O,KAAczT,EAAQ4E,MAC/B5S,KAAKwhB,cAAclhB,KACjB,IAAI6d,EAAYsD,EAAY,CAAE3N,QAAQ,KAM5C9T,KAAKqe,oBAGArQ,EAAQ+L,OACX/Z,KAAK+Z,KAAO,YAAY/Z,KAAK2S,aAAa4M,8BAI5Cvf,KAAK0hB,uBACT,CAME,qBAAAA,GAEE1hB,KAAK2S,aAAaxS,GAAG,oBAAoBC,IACvCJ,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KACT8f,KAAM,WACN6B,WAAa,KACVvhB,GACH,IAIJ,IAAK,IAAI8M,EAAI,EAAGA,EAAIlN,KAAKwhB,cAAcxU,OAAQE,IAAK,CACrClN,KAAKwhB,cAActU,GAE3B/M,GAAG,oBAAoBC,IAC1BJ,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KACT8f,KAAM,WACN6B,UAAWzU,KACR9M,GACH,GAEV,CACA,CAME,iBAAAie,GAEE,MAAMuD,EAAiB5hB,KAAK2S,aAAagM,iBACzC,GAAIiD,EAAe5U,OAAS,EAI1B,OAFAhN,KAAKka,WAAWrD,KAAO,OACvB7W,KAAKka,WAAW5K,UAAY,GAK9BtP,KAAKka,WAAWrD,KAAO7W,KAAK6O,gBAG5B7O,KAAKka,WAAW5K,UAAYtP,KAAK2S,aAAa0N,kBAG9C,MAAM/B,EAAasD,EAChB7P,KAAI5D,GAASA,EAAMlL,YACnB1C,QAAOqD,GAAQA,UAEd0a,EAAWtR,OAAS,IACtBhN,KAAKka,WAAWqE,aAAe/b,KAAKgI,OAAO8T,GAC3Cte,KAAKka,WAAWsE,aAAehc,KAAK+H,OAAO+T,GAC3Cte,KAAKka,WAAW2H,iBAAmBvD,EAAWwD,QAAO,CAACC,EAAKne,IAASme,EAAMne,GAAM,GAAK0a,EAAWtR,QAIlG,IACE,MAAMyD,EAASzQ,KAAKsS,oBAChB7B,IACFzQ,KAAKka,WAAW8H,SAAW,CACzBjf,IAAK0N,EAAO1N,IACZL,IAAK+N,EAAO/N,KAGjB,CAAC,MAAOxB,GACPH,QAAQ2D,KAAK,iCAAiCxD,EAAMuC,UAC1D,CACA,CAME,cAAAkb,GACE,OAAO3e,KAAK2S,aAAagM,gBAC7B,CAME,cAAAC,CAAe1S,GACblM,KAAK2S,aAAaiM,eAAe1S,EAErC,CAME,QAAA+V,GACE,OAAOjiB,KAAKwhB,cAAczP,KAAI+N,GAAQA,EAAKnB,kBAC/C,CAME,QAAAuD,GAEE,MADc,CAACliB,KAAK2S,aAAagM,kBACpBwD,OAAOniB,KAAKiiB,WAC7B,CAME,QAAAG,CAASC,GACP,IAAKA,IAAU1F,MAAMC,QAAQyF,IAA2B,IAAjBA,EAAMrV,OAC3C,MAAM,IAAIvL,MAAM,sEAIlBzB,KAAK2S,aAAaiM,eAAeyD,EAAM,IAGvCriB,KAAKwhB,cAAgB,GAGrB,IAAK,IAAItU,EAAI,EAAGA,EAAImV,EAAMrV,OAAQE,IAChClN,KAAKsiB,QAAQD,EAAMnV,IAIrBlN,KAAKqe,mBACT,CAOE,OAAAkE,CAAQzD,GACN,OAAIA,EAAQ,GAAKA,GAAS9e,KAAKwhB,cAAcxU,OACpC,KAGFhN,KAAKwhB,cAAc1C,GAAOH,gBACrC,CAOE,OAAA2D,CAAQpW,GACN,MAAM6G,EAAO,IAAIoL,EAAYjS,EAAa,CAAE4H,QAAQ,IAG9C0O,EAAYxiB,KAAKwhB,cAAcxU,OAqBrC,OAnBA+F,EAAK5S,GAAG,oBAAoBC,IAC1BJ,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KACT8f,KAAM,WACN6B,UAAWa,KACRpiB,GACH,IAGJJ,KAAKwhB,cAAclhB,KAAKyS,GACxB/S,KAAKqe,oBAELre,KAAKa,KAAK,aAAc,CACtBua,QAASpb,KACTwiB,YACAtW,YAAa6G,EAAK4L,mBAGb6D,CACX,CAOE,UAAAC,CAAW3D,GACT,GAAIA,EAAQ,GAAKA,GAAS9e,KAAKwhB,cAAcxU,OAC3C,OAAO,EAGT,MAAMkS,EAAUlf,KAAKwhB,cAAczC,OAAOD,EAAO,GAAG,GASpD,OARA9e,KAAKqe,oBAELre,KAAKa,KAAK,eAAgB,CACxBua,QAASpb,KACTwiB,UAAW1D,EACX5S,YAAagT,EAAQP,oBAGhB,CACX,CAQE,UAAA+D,CAAW5D,EAAO5S,GAChB,QAAI4S,EAAQ,GAAKA,GAAS9e,KAAKwhB,cAAcxU,UAI7ChN,KAAKwhB,cAAc1C,GAAOF,eAAe1S,IAGlC,EACX,CAME,YAAAyW,GACE,OAAO3iB,KAAKwhB,cAAcxU,MAC9B,CAOE,SAAA4V,CAAUhgB,EAAYkc,EAAQ,MAC5B9e,KAAK2S,aAAakM,cAAcjc,EAAYkc,EAEhD,CAOE,YAAA+D,CAAa/D,GACX,OAAO9e,KAAK2S,aAAasM,iBAAiBH,EAE9C,CAQE,YAAAgE,CAAahE,EAAOlc,GAClB,OAAO5C,KAAK2S,aAAawM,iBAAiBL,EAAOlc,EAErD,CAME,cAAA2c,GACE,OAAOvf,KAAK2S,aAAa4M,gBAC7B,CAOE,SAAAC,CAAUV,GACR,OAAO9e,KAAK2S,aAAa6M,UAAUV,EACvC,CAME,SAAAlE,GACE,OAAO5a,KAAK2S,aAAaiI,WAC7B,CAME,SAAAC,GACE,OAAO7a,KAAKsS,mBAChB,CAME,iBAAAA,GACE,OAAOxF,EAAe4F,yBACpB1S,KAAK2S,aAAagM,iBAClB3e,KAAKiiB,WAEX,CAME,iBAAAnH,GAEE,MAAMiI,EAAgB/iB,KAAK2S,aAAamI,oBAGxC,GAAkC,IAA9B9a,KAAKwhB,cAAcxU,OACrB,OAAO+V,EAIT,IAAIvY,EAAMuY,EAAcvY,IACpBD,EAAMwY,EAAcxY,IAExB,IAAK,MAAMuV,KAAQ9f,KAAKwhB,cAAe,CACrC,MAAMwB,EAAYlD,EAAKhF,oBAEnBkI,EAAUxY,IAAMA,IAAKA,EAAMwY,EAAUxY,KACrCwY,EAAUzY,IAAMA,IAAKA,EAAMyY,EAAUzY,IAC/C,CAEI,MAAO,CACLC,MACAD,MACA6S,MAAO7S,EAAMC,EAEnB,CAQE,QAAAuQ,CAASnY,EAAY8U,EAAW,IAC9B,KAAM9U,aAAsBS,GAC1B,MAAM,IAAI5B,MAAM,sDAGlB,MAAMmgB,EAAiB5hB,KAAK2S,aAAagM,iBACzC,GAAIiD,EAAe5U,OAAS,EAC1B,OAAO,EAOT,IAHmBF,EAAeuF,eAAezP,EAAYgf,GAI3D,OAAO,EAIT,IAAK,MAAM7O,KAAQ/S,KAAKwhB,cACtB,GAAI1U,EAAeuF,eAAezP,EAAYmQ,EAAK4L,kBAEjD,OAAO,EAKX,OAAO,CACX,CAOE,OAAA3D,CAAQpY,GACN,KAAMA,aAAsBS,GAC1B,MAAM,IAAI5B,MAAM,sDAIlB,GAAIzB,KAAK+a,SAASnY,GAEhB,MAAO,CACLA,WAAYA,EAAW4D,QACvBmJ,SAAU,EACVsT,YAAY,GAKhB,MAAMC,EAAkBljB,KAAK2S,aAAaqI,QAAQpY,GAGlD,IAAIugB,EAAcD,EAAgBvT,SAC9BK,EAAekT,EAAgBtgB,WAEnC,IAAK,MAAMmQ,KAAQ/S,KAAKwhB,cAAe,CACrC,MAAM4B,EAAcrQ,EAAKiI,QAAQpY,GAE7BwgB,EAAYzT,SAAWwT,IACzBA,EAAcC,EAAYzT,SAC1BK,EAAeoT,EAAYxgB,WAEnC,CAEI,MAAO,CACLA,WAAYoN,EACZL,SAAUwT,EACVF,YAAY,EAElB,CASE,SAAAjX,CAAUgC,EAAU,IAClB,MAAMC,GAAgD,IAA7BD,EAAQC,iBAC3B0P,GAAkD,IAA9B3P,EAAQ2P,kBAI5BhL,EAAe,IADE3S,KAAK2S,aAAagM,kBAIrChM,EAAa3F,OAAS,IACjB2F,EAAa,GAAG5P,MAAQ4P,EAAaA,EAAa3F,OAAS,GAAGjK,KAC9D4P,EAAa,GAAGjQ,MAAQiQ,EAAaA,EAAa3F,OAAS,GAAGtK,MACrEiQ,EAAarS,KAAKqS,EAAa,IAIjC,MA+BMiL,EAAU,CACd1Y,KAAM,UACN2Y,SAAU,CACR3Y,KAAM,UACNgH,YAAa,CAnCWyG,EAAaZ,KAAI5D,IAE3C,MAAMP,EAAQ,CAACO,EAAMzL,IAAKyL,EAAMpL,KAIhC,OAHIkL,GAAwC,OAApBE,EAAMlL,gBAA0CwE,IAApB0G,EAAMlL,WACxD2K,EAAMtN,KAAK6N,EAAMlL,WAEZ2K,CAAK,OAIe5N,KAAKwhB,cAAczP,KAAI+N,IAClD,IAAI2B,EAAa3B,EAAKnB,iBAStB,OANI8C,EAAWzU,OAAS,IACbyU,EAAW,GAAG1e,MAAQ0e,EAAWA,EAAWzU,OAAS,GAAGjK,KACxD0e,EAAW,GAAG/e,MAAQ+e,EAAWA,EAAWzU,OAAS,GAAGtK,OACjE+e,EAAa,IAAIA,EAAYA,EAAW,KAGnCA,EAAW1P,KAAI5D,IAEpB,MAAMP,EAAQ,CAACO,EAAMzL,IAAKyL,EAAMpL,KAIhC,OAHIkL,GAAwC,OAApBE,EAAMlL,gBAA0CwE,IAApB0G,EAAMlL,WACxD2K,EAAMtN,KAAK6N,EAAMlL,WAEZ2K,CAAK,GACZ,MAUF8L,GAAI1Z,KAAK0Z,IAWX,OAPIiE,IACFC,EAAQ1D,WAAa,CACnBH,KAAM/Z,KAAK+Z,QACR/Z,KAAKka,aAIL0D,CACX,CAQE,WAAA3C,CAAY2C,EAASlG,EAAW,IAC9B,IAAKkG,GAA4B,YAAjBA,EAAQ1Y,OAAuB0Y,EAAQC,UACrB,YAA1BD,EAAQC,SAAS3Y,OAAuByX,MAAMC,QAAQgB,EAAQC,SAAS3R,aAC7E,OAAO,EAGT,MAAMmW,EAAQzE,EAAQC,SAAS3R,YAC/B,GAAqB,IAAjBmW,EAAMrV,SAAiB2P,MAAMC,QAAQyF,EAAM,IAC7C,OAAO,EAIT,MAAMgB,EAAqBhB,EAAM,GAAGtQ,KAAI+L,IACtC,IAAKnB,MAAMC,QAAQkB,IAAWA,EAAO9Q,OAAS,EAC5C,MAAM,IAAIvL,MAAM,uCAGlB,OAAO,IAAI4B,EACTya,EAAO,GACPA,EAAO,GACPA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,KACjC,IAKCuF,EAAmBrW,OAAS,GACxBqW,EAAmB,GAAGC,OAAOD,EAAmBA,EAAmBrW,OAAS,KAClFqW,EAAmBlD,MAIrBngB,KAAK2S,aAAaiM,eAAeyE,GAGjCrjB,KAAKwhB,cAAgB,GAGrB,IAAK,IAAItU,EAAI,EAAGA,EAAImV,EAAMrV,OAAQE,IAAK,CACrC,MAEMuU,EAFOY,EAAMnV,GAEK6E,KAAI+L,IAC1B,IAAKnB,MAAMC,QAAQkB,IAAWA,EAAO9Q,OAAS,EAC5C,MAAM,IAAIvL,MAAM,4CAGlB,OAAO,IAAI4B,EACTya,EAAO,GACPA,EAAO,GACPA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,KACjC,IAIC2D,EAAWzU,OAAS,GACdyU,EAAW,GAAG6B,OAAO7B,EAAWA,EAAWzU,OAAS,KAC5DyU,EAAWtB,MAIbngB,KAAKsiB,QAAQb,EACnB,CAoBI,OAjBI7D,EAAQ1D,aACN0D,EAAQ1D,WAAWH,OACrB/Z,KAAK+Z,KAAO6D,EAAQ1D,WAAWH,YACxB6D,EAAQ1D,WAAWH,MAG5B/Z,KAAKka,WAAa,IAAK0D,EAAQ1D,aAI7B0D,EAAQlE,KACV1Z,KAAK0Z,GAAKkE,EAAQlE,IAGpB1Z,KAAKqe,oBACLre,KAAKa,KAAK,mBAAoB,CAAEua,QAASpb,QAElC,CACX,CAME,KAAAwG,GACE,MAAM+c,EAAuBvjB,KAAK2S,aAAagM,iBAAiB5M,KAAI5D,GAASA,EAAM3H,UAE7Egd,EAAcxjB,KAAKwhB,cAAczP,KAAI+N,GACzCA,EAAKnB,iBAAiB5M,KAAI5D,GAASA,EAAM3H,YAkB3C,OAfe,IAAI+a,EACjBgC,EACA,CACE7J,GAAI,SAAS1Z,KAAK0Z,KAClBK,KAAM,GAAG/Z,KAAK+Z,cACdE,MAAO,IAAKja,KAAKia,OACjBC,WAAY,IAAKla,KAAKka,YACtBC,SAAU,IAAKna,KAAKma,UACpBE,QAASra,KAAKqa,QACdC,SAAUta,KAAKsa,SACfC,YAAava,KAAKua,YAClB3H,MAAO4Q,GAKf,CAQE,aAAA3U,CAAcb,EAAU,IACtB,MAAMyV,GAAwC,IAAzBzV,EAAQyV,aAEvB7B,EAAiB5hB,KAAK2S,aAAagM,iBACzC,GAAIiD,EAAe5U,OAAS,EAC1B,OAAO,EAIT,IAAI6J,EAAO/J,EAAe+B,cAAc+S,GAGxC,GAAI6B,GAAgBzjB,KAAKwhB,cAAcxU,OAAS,EAC9C,IAAK,MAAM+F,KAAQ/S,KAAKwhB,cAAe,CACrC,MAAMC,EAAa1O,EAAK4L,iBACxB,GAAI8C,EAAWzU,OAAS,EAAG,SAG3B6J,GADiB/J,EAAe+B,cAAc4S,EAEtD,CAGI,OAAO5K,CACX,CAQE,kBAAAxH,CAAmBrB,EAAU,IAC3B,MAAMyV,GAAwC,IAAzBzV,EAAQyV,aAG7B,IAAInU,EAAYtP,KAAK2S,aAAa0N,kBAGlC,GAAIoD,GAAgBzjB,KAAKwhB,cAAcxU,OAAS,EAC9C,IAAK,MAAM+F,KAAQ/S,KAAKwhB,cACtBlS,GAAayD,EAAKsN,kBAItB,OAAO/Q,CACX,CAOE,QAAAqR,CAAStD,GACP,GAAIA,GAAa,EACf,OAAOrd,KAAKwG,QAGd,MAAMkd,EAAqB5W,EAAe+T,aACxC7gB,KAAK2S,aAAagM,iBAClBtB,GAGIsG,EAAkB3jB,KAAKwhB,cAAczP,KAAI+N,GAC7ChT,EAAe+T,aAAaf,EAAKnB,iBAAkBtB,KAGrD,OAAO,IAAIkE,EACTmC,EACA,CACE3J,KAAM,GAAG/Z,KAAK+Z,oBACdE,MAAO,IAAKja,KAAKia,OACjBrH,MAAO+Q,GAGf,CAQE,MAAAC,CAAOjU,EAAU3B,EAAU,IACzB,MAAM4T,EAAiB5hB,KAAK2S,aAAagM,iBACzC,GAAIiD,EAAe5U,OAAS,EAC1B,OAAOhN,KAAKwG,QAGd,MAAMqd,EAAmB/W,EAAegX,cACtClC,EACAjS,EACA3B,GAKF,OAAO,IAAIuT,EACTsC,EACA,CACE9J,KAAM,GAAG/Z,KAAK+Z,gBAAgBpK,MAC9BsK,MAAO,IAAKja,KAAKia,QAGzB,CAME,OAAA8J,GACE,MAAMnC,EAAiB5hB,KAAK2S,aAAagM,iBACzC,GAAIiD,EAAe5U,OAAS,EAC1B,OAAO,EAIT,GAAIF,EAAe8J,qBAAqBgL,GACtC,OAAO,EAIT,IAAK,MAAM7O,KAAQ/S,KAAKwhB,cAAe,CACrC,MAAMC,EAAa1O,EAAK4L,iBACxB,GAAI8C,EAAWzU,OAAS,EAAG,SAE3B,GAAIF,EAAe8J,qBAAqB6K,GACtC,OAAO,EAIT,MAAMuC,EAAalX,EAAeyG,oBAAoBkO,GACtD,IAAK3U,EAAeuF,eAAe2R,EAAYpC,GAC7C,OAAO,EAIT,GAAI9U,EAAemX,iBAAiBrC,EAAgBH,GAClD,OAAO,EAIT,IAAK,MAAMyC,KAAalkB,KAAKwhB,cAAe,CAC1C,GAAIzO,IAASmR,EAAW,SAExB,MAAMC,EAAkBD,EAAUvF,iBAClC,GAAI7R,EAAemX,iBAAiBxC,EAAY0C,GAC9C,OAAO,CAEjB,CACA,CAEI,OAAO,CACX,CAME,sBAAAC,GAGE,OAAOtX,EAAeuX,8BACpBrkB,KAAK2S,aAAagM,iBAClB3e,KAAKiiB,WAEX,CAQE,eAAAqC,CAAgBtW,EAAU,IACxB,IAAIuW,EAEJ,QAA8B9c,IAA1BuG,EAAQuW,cACVA,EAAgBvW,EAAQuW,kBACnB,CAGLA,EADkBvkB,KAAK8a,oBACGtQ,GAChC,CAEI,OAAOsC,EAAe0X,uBACpBxkB,KAAK2S,aAAagM,iBAClB3e,KAAKiiB,WACLsC,EAEN,ECv0BO,MAAME,UAA0B3kB,EAQrC,WAAAC,CAAY2kB,EAAW,GAAI1W,EAAU,CAAA,GACnClJ,QAEA9E,KAAK0Z,GAAK1L,EAAQ0L,IAAM,cAAcC,KAAKC,SAASpX,KAAKqX,MAAsB,IAAhBrX,KAAKsX,YACpE9Z,KAAK+Z,KAAO/L,EAAQ+L,MAAQ,cAAc/Z,KAAK0Z,GAAGM,QAAS,KAC3Dha,KAAK0kB,SAAW,IAAI/iB,IAGhBgb,MAAMC,QAAQ8H,IAChBA,EAASzjB,SAAQma,GAAWpb,KAAK2kB,WAAWvJ,IAElD,CAOE,UAAAuJ,CAAWvJ,GACT,KAAMA,aAAmB3B,GACvB,MAAM,IAAIhY,MAAM,8CAgClB,OA7BAzB,KAAK0kB,SAASpd,IAAI8T,EAAQ1B,GAAI0B,GAG9BA,EAAQjb,GAAG,oBAAoBC,IAC7BJ,KAAKa,KAAK,2BAA4B,IAAKT,EAAOwkB,WAAY5kB,MAAO,IAGvEob,EAAQjb,GAAG,sBAAsBC,IAC/BJ,KAAKa,KAAK,6BAA8B,IAAKT,EAAOwkB,WAAY5kB,MAAO,IAGzEob,EAAQjb,GAAG,iBAAiBC,IAC1BJ,KAAKa,KAAK,wBAAyB,IAAKT,EAAOwkB,WAAY5kB,MAAO,IAGpEob,EAAQjb,GAAG,YAAYC,IACrBJ,KAAKa,KAAK,mBAAoB,IAAKT,EAAOwkB,WAAY5kB,MAAO,IAG/Dob,EAAQjb,GAAG,cAAcC,IACvBJ,KAAKa,KAAK,qBAAsB,IAAKT,EAAOwkB,WAAY5kB,MAAO,IAGjEob,EAAQjb,GAAG,sBAAsBC,IAC/BJ,KAAKa,KAAK,6BAA8B,IAAKT,EAAOwkB,WAAY5kB,MAAO,IAGzEA,KAAKa,KAAK,gBAAiB,CAAEua,UAASwJ,WAAY5kB,OAE3Cob,EAAQ1B,EACnB,CAOE,aAAAmL,CAAcC,GACZ,MAAMC,EAAYD,aAAuBrL,EAAcqL,EAAYpL,GAAKoL,EAExE,IAAK9kB,KAAK0kB,SAAS9a,IAAImb,GACrB,OAAO,EAGT,MAAM3J,EAAUpb,KAAK0kB,SAAS/d,IAAIoe,GAQlC,OAPA/kB,KAAK0kB,SAASM,OAAOD,GAGrB3J,EAAQ/Z,qBAERrB,KAAKa,KAAK,kBAAmB,CAAEua,UAASwJ,WAAY5kB,QAE7C,CACX,CAOE,UAAAilB,CAAWvL,GACT,OAAO1Z,KAAK0kB,SAAS/d,IAAI+S,EAC7B,CAOE,UAAAwL,CAAWJ,GACT,MAAMC,EAAYD,aAAuBrL,EAAcqL,EAAYpL,GAAKoL,EACxE,OAAO9kB,KAAK0kB,SAAS9a,IAAImb,EAC7B,CAME,cAAAI,GACE,OAAOxI,MAAMrM,KAAKtQ,KAAK0kB,SAAS1a,SACpC,CAOE,iBAAAob,CAAkBlgB,GAChB,OAAOlF,KAAKmlB,iBAAiB5kB,QAAO6a,GAAWA,EAAQlW,OAASA,GACpE,CAOE,YAAAmgB,CAAaC,GACX,OAAOtlB,KAAKmlB,iBAAiB5kB,OAAO+kB,EACxC,CAME,eAAAC,GACE,OAAOvlB,KAAK0kB,SAASc,IACzB,CAME,sBAAAC,GACE,MAAMC,EAAS,CAAE,EAMjB,OAJA1lB,KAAKmlB,iBAAiBlkB,SAAQma,IAC5BsK,EAAOtK,EAAQlW,OAASwgB,EAAOtK,EAAQlW,OAAS,GAAK,CAAC,IAGjDwgB,CACX,CAKE,KAAApjB,GAC2BtC,KAAKmlB,iBAEblkB,SAAQma,IACvBpb,KAAK6kB,cAAczJ,EAAQ,IAG7Bpb,KAAKa,KAAK,qBAAsB,CAAE+jB,WAAY5kB,MAClD,CAME,SAAA2lB,CAAU3X,EAAU,IAClBhO,KAAKmlB,iBAAiBlkB,SAAQma,IACvBA,EAAQhB,UACXgB,EAAQS,OAAO7N,EACvB,GAEA,CAME,WAAA4X,CAAY5X,EAAU,IACpBhO,KAAKmlB,iBAAiBlkB,SAAQma,IACxBA,EAAQhB,UACVgB,EAAQU,SAAS9N,EACzB,GAEA,CAME,mBAAA6X,GACE,OAAO7lB,KAAKmlB,iBAAiB5kB,QAAO6a,GAAWA,EAAQhB,UAC3D,CAME,aAAA0L,CAAczL,GACZra,KAAKmlB,iBAAiBlkB,SAAQma,IACxBA,EAAQf,UAAYA,IAClBA,EACFe,EAAQY,OAERZ,EAAQa,OAElB,GAEA,CAME,kBAAA8J,GACE,OAAO/lB,KAAKmlB,iBAAiB5kB,QAAO6a,GAAWA,EAAQf,SAC3D,CAOE,SAAArO,CAAUgC,EAAU,IAClBjN,QAAQC,IAAI,yDAA0DhB,KAAK0kB,SAASc,MA0BpF,MAAO,CACLtgB,KAAM,oBACNwf,SA1Be1kB,KAAKmlB,iBACnB5kB,QAAO6a,GAAWpN,EAAQgY,eAAiB5K,EAAQf,UACnDtI,KAAIqJ,IACHra,QAAQC,IAAI,kCAAkCoa,EAAQ1B,aAAa0B,EAAQlW,QACtD,SAAjBkW,EAAQlW,MAAoC,YAAjBkW,EAAQlW,MACrCnE,QAAQC,IAAI,wBAAwBoa,EAAQuD,iBAAiB3R,UAE/D,MAAM4Q,EAAUxC,EAAQpP,UAAUgC,GAclC,OAXI4P,EAAQC,SACoB,eAA1BD,EAAQC,SAAS3Y,MAAyByX,MAAMC,QAAQgB,EAAQC,SAAS3R,aAC3EnL,QAAQC,IAAI,8BAA8B4c,EAAQC,SAAS3R,YAAYc,sBACpC,YAA1B4Q,EAAQC,SAAS3Y,MAAsByX,MAAMC,QAAQgB,EAAQC,SAAS3R,cAC7D0R,EAAQC,SAAS3R,YAAYc,OAAS,GACxDjM,QAAQC,IAAI,2BAA2B4c,EAAQC,SAAS3R,YAAY,GAAGc,uCAGzEjM,QAAQ2D,KAAK,8CAA8C0W,EAAQ1B,MAG9DkE,CAAO,IAOtB,CAQE,WAAA3C,CAAY2C,EAAS5P,EAAU,IAC7B,IAAK4P,EACH,OAAO,EAGT,IAAI8G,EAAW,GAGM,sBAAjB9G,EAAQ1Y,MAAgCyX,MAAMC,QAAQgB,EAAQ8G,UAChEA,EAAW9G,EAAQ8G,SAGK,YAAjB9G,EAAQ1Y,OACfwf,EAAW,CAAC9G,IAId,IAAIqI,EAAc,EAElB,IAAK,MAAMC,KAAexB,EACxB,GAAKwB,GAAgBA,EAAYrI,UAAaqI,EAAYrI,SAAS3Y,KAInE,IAEE,IAAIkW,EAEJ,OAAQ8K,EAAYrI,SAAS3Y,MAC7B,IAAK,QACHkW,EAAU,IAAIqB,EAAayJ,EAAYrI,SAAS3R,YAAa,CAAEwN,GAAIwM,EAAYxM,KAC/E,MACF,IAAK,aAEH0B,EAAU,IAAI+C,EACZ+H,EAAYrI,SAAS3R,YAAY6F,KAAI+L,GACnC,IAAIza,EAAWya,EAAO,GAAIA,EAAO,GAAIA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,QAEvE,CAAEpE,GAAIwM,EAAYxM,KAEpB,MACF,IAAK,UAEH,GAAIwM,EAAYrI,SAAS3R,aAAega,EAAYrI,SAAS3R,YAAYc,OAAS,EAAG,CACnF,MAAM2F,EAAeuT,EAAYrI,SAAS3R,YAAY,GAAG6F,KAAI+L,GAC3D,IAAIza,EAAWya,EAAO,GAAIA,EAAO,GAAIA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,QAIjElL,EAAQ,GACd,IAAK,IAAI1F,EAAI,EAAGA,EAAIgZ,EAAYrI,SAAS3R,YAAYc,OAAQE,IAC3D0F,EAAMtS,KACJ4lB,EAAYrI,SAAS3R,YAAYgB,GAAG6E,KAAI+L,GACtC,IAAIza,EAAWya,EAAO,GAAIA,EAAO,GAAIA,EAAO9Q,OAAS,EAAI8Q,EAAO,GAAK,SAK3E1C,EAAU,IAAImG,EAAe5O,EAAc,CACzC+G,GAAIwM,EAAYxM,GAChB9G,MAAOA,GAErB,MACYwI,EAAU,IAAImG,EAAe,GAAI,CAAE7H,GAAIwM,EAAYxM,KAErD,MACF,QACE3Y,QAAQ2D,KAAK,sCAAsCwhB,EAAYrI,SAAS3Y,QACxE,SAIgC,eAA9BghB,EAAYrI,SAAS3Y,MAAuD,YAA9BghB,EAAYrI,SAAS3Y,MAEjEghB,EAAYhM,aACVgM,EAAYhM,WAAWH,OACzBqB,EAAQrB,KAAOmM,EAAYhM,WAAWH,MAGxCqB,EAAQlB,WAAa,IAAKgM,EAAYhM,aAGxCla,KAAK2kB,WAAWvJ,GAChB6K,KAGO7K,EAAQH,YAAYiL,EAAalY,KACxChO,KAAK2kB,WAAWvJ,GAChB6K,IAEH,CAAC,MAAOE,GACPplB,QAAQG,MAAM,mCAAoCilB,EAC1D,CAUI,OAPIF,EAAc,GAChBjmB,KAAKa,KAAK,oBAAqB,CAC7BulB,MAAOH,EACPrB,WAAY5kB,OAITimB,CACX,CAME,SAAArL,GACE,MAAM8J,EAAW1kB,KAAKmlB,iBAEtB,GAAwB,IAApBT,EAAS1X,OACX,OAAO,KAIT,MAAMqZ,EAAc3B,EAAS,GAAG9J,YAChC,IAAKyL,EACH,OAAO,KAGT,IAAI7gB,EAAQ6gB,EAAY7gB,MACpB0X,EAAQmJ,EAAYnJ,MACpBD,EAAOoJ,EAAYpJ,KACnBE,EAAOkJ,EAAYlJ,KAGvB,IAAK,IAAIjQ,EAAI,EAAGA,EAAIwX,EAAS1X,OAAQE,IAAK,CACxC,MAAMoZ,EAAS5B,EAASxX,GAAG0N,YACtB0L,IAEDA,EAAO9gB,MAAQA,IAAOA,EAAQ8gB,EAAO9gB,OACrC8gB,EAAOpJ,MAAQA,IAAOA,EAAQoJ,EAAOpJ,OACrCoJ,EAAOrJ,KAAOA,IAAMA,EAAOqJ,EAAOrJ,MAClCqJ,EAAOnJ,KAAOA,IAAMA,EAAOmJ,EAAOnJ,MAC5C,CAII,MAAO,CACL3X,QACA0X,QACAD,OACAE,OACAJ,UAAW,IAAI1Z,EAAWmC,EAAOyX,GACjCD,UAAW,IAAI3Z,EAAW6Z,EAAOC,GAEvC,CAOE,eAAAoJ,CAAgBtM,EAAOjM,EAAU,IAC/BhO,KAAKmlB,iBAAiBlkB,SAAQma,IAC5BA,EAAQD,SAASlB,EAAOjM,EAAQ,GAEtC,CASE,cAAAwY,CAAe5jB,EAAYoL,EAAU,IACnC,OAAOhO,KAAKmlB,iBAAiB5kB,QAAO6a,GAClCA,EAAQf,SAAWe,EAAQL,SAASnY,EAAYoL,IAEtD,CAWE,qBAAAyY,CAAsB7jB,EAAYoL,EAAU,IAC1C,MAAMqP,EAAYrP,EAAQqP,WAAa,GACjCqJ,EAAiB1Y,EAAQ0Y,eACzBC,EAAe3Y,EAAQ2Y,aAG7B,OAAID,GAAkBC,EACb3mB,KAAKmlB,iBAAiB5kB,QAAO6a,IAElC,IAAKA,EAAQf,QAAS,OAAO,EAG7B,GAAqB,UAAjBe,EAAQlW,KAAkB,CAC5B,MAAM0hB,EAAexL,EAAQyB,gBAC7B,IAAK+J,EAAc,OAAO,EAE1B,IACE,MAAMC,EAAmBF,EAAaG,kBAAkBF,GACxD,IAAKC,EAAkB,OAAO,EAO9B,OALiBrkB,KAAKqG,KACpBrG,KAAKukB,IAAIF,EAAiB,GAAKH,EAAe,GAAI,GACpClkB,KAAKukB,IAAIF,EAAiB,GAAKH,EAAe,GAAI,KAG/CrJ,CACpB,CAAC,MAAOrS,GAEP,OADAjK,QAAQ2D,KAAK,qCAAsCsG,IAC5C,CACnB,CACA,CAGQ,OAAOoQ,EAAQL,SAASnY,EAAY,CAAEya,aAAY,IAK/Crd,KAAKwmB,eAAe5jB,EAAY,CAAEya,aAC7C,CAUE,kBAAA2J,CAAmBpkB,EAAYoL,EAAU,IACvC,IAAI0W,EAAW1kB,KAAKmlB,iBAAiB5kB,QAAO6a,GAAWA,EAAQf,UAM/D,GAJIrM,EAAQiZ,cACVvC,EAAWA,EAASnkB,QAAO6a,GAAWA,EAAQlW,OAAS8I,EAAQiZ,eAGzC,IAApBvC,EAAS1X,OACX,OAAO,KAGT,IAAIka,EAAiB,KACjB/D,EAAczF,IAalB,OAXAgH,EAASzjB,SAAQma,IACf,MAAMJ,EAAUI,EAAQJ,QAAQpY,GAE5BoY,GAAWA,EAAQrL,SAAWwT,KAC3BnV,EAAQmZ,aAAenM,EAAQrL,UAAY3B,EAAQmZ,eACtDD,EAAiB9L,EACjB+H,EAAcnI,EAAQrL,SAEhC,IAGQuX,EACK,CACL9L,QAAS8L,EACTvX,SAAUwT,GAIP,IACX,CAOE,aAAAiE,CAAchM,GACZ,KAAMA,aAAmB3B,GACvB,MAAM,IAAIhY,MAAM,8CAIlB,QAAKzB,KAAK0kB,SAAS9a,IAAIwR,EAAQ1B,MAK/B1Z,KAAK0kB,SAASpd,IAAI8T,EAAQ1B,GAAI0B,GAG9Bpb,KAAKa,KAAK,kBAAmB,CAAEua,UAASwJ,WAAY5kB,QAE7C,EACX,ECviBO,MAAMqnB,UAAiBvnB,EAK5B,WAAAC,CAAYiO,EAAU,IAGpB,GAFAlJ,SAEKkJ,EAAQsZ,QACX,MAAM,IAAI7lB,MAAM,wDAGlB,IAAKuM,EAAQ2Y,aACX,MAAM,IAAIllB,MAAM,qDAIlBzB,KAAKsnB,QAAUtZ,EAAQsZ,QACvBtnB,KAAK2mB,aAAe3Y,EAAQ2Y,aAC5B3mB,KAAKunB,eAAiBvZ,EAAQuZ,gBAAkBvnB,KAAKsnB,QAAQC,eAG7DvnB,KAAKwnB,UAAW,EAChBxnB,KAAKgO,QAAUA,EACfhO,KAAKynB,YAAc,CAAE,EAGrBznB,KAAK0nB,sBACT,CAOE,oBAAAA,GAGF,CAME,QAAAC,CAAS3Z,EAAU,IACbhO,KAAKwnB,WAKTxnB,KAAK4nB,kBAAoBvhB,OAAOwhB,OAAO,CAAA,EAAI7Z,GAI3ChO,KAAKgO,QAAU3H,OAAOwhB,OAAO,CAAA,EAAI7nB,KAAKgO,QAASA,GAE/CjN,QAAQC,IAAI,sCAAuCgN,GACnDjN,QAAQC,IAAI,8CAA+ChB,KAAKgO,SAGhEhO,KAAKwnB,UAAW,EAGhBxnB,KAAK8nB,YAGL9nB,KAAKa,KAAK,YAAab,KAAK4nB,mBAChC,CAOE,SAAAE,GACE,MAAM,IAAIrmB,MAAM,qDACpB,CAKE,UAAAsmB,GACO/nB,KAAKwnB,WAKVxnB,KAAKwnB,UAAW,EAGhBxnB,KAAKgoB,cAOLhoB,KAAKa,KAAK,eACd,CAOE,WAAAmnB,GACE,MAAM,IAAIvmB,MAAM,uDACpB,CAME,KAAAwmB,GAEEjoB,KAAKkoB,SAOLloB,KAAKa,KAAK,QACd,CAOE,MAAAqnB,GAGF,CAME,aAAAC,CAAcna,EAAU,IACtBhO,KAAKgO,QAAU3H,OAAOwhB,OAAO7nB,KAAKgO,QAASA,GAG3ChO,KAAKooB,kBAGLpoB,KAAKa,KAAK,iBAAkBb,KAAKgO,QACrC,CAOE,eAAAoa,GAGF,CAKE,OAAAC,GAEMroB,KAAKwnB,UACPxnB,KAAK+nB,aAIP/nB,KAAKsoB,WAGLtoB,KAAKqB,qBAGLrB,KAAKsnB,QAAU,KACftnB,KAAK2mB,aAAe,KACpB3mB,KAAKunB,eAAiB,IAC1B,CAOE,QAAAe,GAGF,EC/KO,MAAMC,UAAwBlB,EAKnC,WAAAtnB,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAGNhO,KAAKgO,QAAU3H,OAAOwhB,OAAO,CAC3BW,KAAM,WACNC,MAAO,SACPC,UAAW,gBACXC,YAAa,eACb/Y,UAAU,EACVgZ,mBAAmB,EACnBC,oBAAoB,EACpBC,iBAAiB,EACjBC,WAAY/oB,KAAKsnB,QAAQ0B,SAASC,kBAClCC,YAAalpB,KAAKsnB,QAAQ0B,SAASG,mBACnCC,WAAY,CACVC,KAAM,aACNC,UAAW,QACXC,YAAa,QACbC,YAAa,IAEdxb,GAGHhO,KAAKynB,YAAc,CACjBgC,kBAAmB,KACnBC,aAAc,GACdtR,OAAQ,GACRuR,cAAe,KACfC,gBAAiB,KACjBC,kBAAmB,GACnBC,cAAe,IAKjB9pB,KAAKunB,eAAiBza,EAGtB9M,KAAK+pB,gBAAkB/pB,KAAK+pB,gBAAgBC,KAAKhqB,MACjDA,KAAKiqB,oBAAsBjqB,KAAKiqB,oBAAoBD,KAAKhqB,MACzDA,KAAKkqB,sBAAwBlqB,KAAKkqB,sBAAsBF,KAAKhqB,MAC7DA,KAAKmqB,qBAAuBnqB,KAAKmqB,qBAAqBH,KAAKhqB,MAC3DA,KAAKoqB,eAAiBpqB,KAAKoqB,eAAeJ,KAAKhqB,KACnD,CAOE,oBAAA0nB,GAEF,CAOE,SAAAI,GAEE9nB,KAAKqqB,yBAAyBrqB,KAAKgO,QAAQwa,MAG3CxoB,KAAK2mB,aAAalmB,iBAAiB,QAAST,KAAK+pB,iBACjD/pB,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAKiqB,qBACrDjqB,KAAK2mB,aAAalmB,iBAAiB,WAAYT,KAAKkqB,uBACpDlqB,KAAK2mB,aAAalmB,iBAAiB,cAAeT,KAAKmqB,sBAGvDG,SAAS7pB,iBAAiB,UAAWT,KAAKoqB,gBAG1CpqB,KAAKuqB,uBACT,CAOE,WAAAvC,GAEEhoB,KAAK2mB,aAAavlB,oBAAoB,QAASpB,KAAK+pB,iBACpD/pB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAKiqB,qBACxDjqB,KAAK2mB,aAAavlB,oBAAoB,WAAYpB,KAAKkqB,uBACvDlqB,KAAK2mB,aAAavlB,oBAAoB,cAAepB,KAAKmqB,sBAG1DG,SAASlpB,oBAAoB,UAAWpB,KAAKoqB,gBAG7CpqB,KAAKwqB,6BACT,CAOE,MAAAtC,GAEEloB,KAAKyqB,0BAGLzqB,KAAKuqB,uBACT,CAOE,wBAAAF,CAAyB7B,GAElB,CAAC,WAAY,OAAQ,UAAUjf,SAASif,KAC3CznB,QAAQG,MAAM,6BAA6BsnB,KAC3CA,EAAO,YAITxoB,KAAKgO,QAAQwa,KAAOA,EAGhBxoB,KAAKwnB,UACPxnB,KAAKkoB,SAIPloB,KAAKa,KAAK,eAAgB,CAAE2nB,QAChC,CAME,qBAAA+B,GAKE,OAHAvqB,KAAKyqB,0BAGGzqB,KAAKgO,QAAQwa,MACrB,IAAK,WACHxoB,KAAKynB,YAAYgC,kBAAoB,IAAItL,EAAY,GAAI,CACvDzE,GAAI,eAAeC,KAAKC,QACxBM,WAAY,CACVhV,KAAM,cACNwlB,gBAAiB,WACjBC,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQ+a,aAEtB,MAEF,IAAK,OACL,IAAK,SAEH/oB,KAAKynB,YAAYgC,kBAAoB,IAAIlI,EAAe,CAAC,IAAK,CAC5D7H,GAAI,eAAeC,KAAKC,QACxBM,WAAY,CACVhV,KAAM,cACNwlB,gBAAiB1qB,KAAKgO,QAAQwa,KAC9BmC,WAAW,GAEb1Q,MAAO5T,OAAOwhB,OAAO,CAAA,EAAI7nB,KAAKsnB,QAAQ0B,SAAS4B,qBAAsB,CACnEC,aAAc7qB,KAAKgO,QAAQ+a,WAAW+B,MACtCC,aAAc/qB,KAAKgO,QAAQ+a,WAAWiC,UAO5ChrB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAW3kB,KAAKynB,YAAYgC,mBAGzDzpB,KAAKynB,YAAYrP,OAAS,GAC1BpY,KAAKynB,YAAYoC,kBAAoB,GACrC7pB,KAAKynB,YAAYqC,cAAgB,EACrC,CAME,uBAAAW,GACMzqB,KAAKynB,YAAYgC,oBAEnBzpB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAYgC,mBAC5DzpB,KAAKynB,YAAYgC,kBAAoB,MAIvCzpB,KAAKynB,YAAYrP,OAAOnX,SAAQ2M,IAC9B5N,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcjX,EAAM,IAGnD5N,KAAKynB,YAAYrP,OAAS,GAG1BpY,KAAKkrB,yBACT,CAME,2BAAAV,GAEExqB,KAAKyqB,0BAGLzqB,KAAKynB,YAAYiC,aAAazoB,SAAQkqB,IACpCnrB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcsG,EAAY,IAGzDnrB,KAAKynB,YAAYiC,aAAe,EACpC,CAME,uBAAAwB,GAEElrB,KAAKynB,YAAYoC,kBAAkB5oB,SAAQmqB,IACzCprB,KAAK2mB,aAAa0E,YAAYD,EAAM,IAGtCprB,KAAKynB,YAAYqC,cAAc7oB,SAAQmqB,IACrCprB,KAAK2mB,aAAa0E,YAAYD,EAAM,IAGtCprB,KAAKynB,YAAYoC,kBAAoB,GACrC7pB,KAAKynB,YAAYqC,cAAgB,EACrC,CAOE,eAAAC,CAAgB3pB,GAEd,MAAMwC,EAAaxC,EAAMwC,WAGpBA,GAAe5C,KAAKynB,YAAYgC,oBAKrCzpB,KAAKsrB,uBAAuB1oB,GAG5B5C,KAAKurB,4BACT,CAOE,mBAAAtB,CAAoB7pB,GAWlB,GATAJ,KAAKynB,YAAYkC,cAAgBvpB,EAAMwC,WACvC5C,KAAKynB,YAAYmC,gBAAkBxpB,EAAMwC,WAGrC5C,KAAKynB,YAAYgC,mBAAqBzpB,KAAKynB,YAAYrP,OAAOpL,OAAS,GACzEhN,KAAKwrB,4BAIHxrB,KAAKgO,QAAQ4a,mBACb5oB,KAAKynB,YAAYgC,mBACjBzpB,KAAKynB,YAAYrP,OAAOpL,OAAS,EAAG,CAEtC,MACM+B,EADY/O,KAAKynB,YAAYrP,OAAOpY,KAAKynB,YAAYrP,OAAOpL,OAAS,GAC/C6P,gBACX7c,KAAKunB,eAAe1Z,kBAAkBkB,EAAW3O,EAAMwC,WACtE,CAAEqL,iBAAkBjO,KAAKgO,QAAQ4B,WAIpB,IACb5P,KAAKsrB,uBAAuBlrB,EAAMwC,YAClC5C,KAAKurB,4BAEb,CACA,CAOE,qBAAArB,CAAsB9pB,GAEhBA,EAAMqrB,eACRrrB,EAAMqrB,cAAcC,iBAItB1rB,KAAK2rB,sBACT,CAOE,oBAAAxB,CAAqB/pB,GAEfA,EAAMqrB,eACRrrB,EAAMqrB,cAAcC,iBAIlB1rB,KAAKynB,YAAYrP,OAAOpL,OAAS,EACnChN,KAAK2rB,uBAGL3rB,KAAKkoB,QAEX,CAOE,cAAAkC,CAAehqB,GAEK,WAAdA,EAAMwrB,MACJ5rB,KAAKynB,YAAYrP,OAAOpL,OAAS,EAEnChN,KAAK6rB,mBAGL7rB,KAAKkoB,UAKS,UAAd9nB,EAAMwrB,KAER5rB,KAAK2rB,sBAEX,CAOE,sBAAAL,CAAuB1oB,GAErB,MAAMkpB,EAAe,IAAIrP,EAAa7Z,EAAY,CAChD8W,GAAI,qBAAqBC,KAAKC,SAAS5Z,KAAKynB,YAAYrP,OAAOpL,SAC/DkN,WAAY,CACVhV,KAAM,oBACN6mB,cAAe/rB,KAAKynB,YAAYgC,kBAAkB/P,GAClDoF,MAAO9e,KAAKynB,YAAYrP,OAAOpL,OAC/B2d,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQkb,cAIlBlpB,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmBF,GAIlC9rB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAWmH,GACxC9rB,KAAKynB,YAAYrP,OAAO9X,KAAKwrB,GAG7B9rB,KAAKisB,4BACT,CAME,gBAAAJ,GACE,GAAuC,IAAnC7rB,KAAKynB,YAAYrP,OAAOpL,OAC1B,OAIF,MAAMkf,EAAYlsB,KAAKynB,YAAYrP,OAAO+H,MAC1CngB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcqH,GAG3ClsB,KAAKisB,6BAGLjsB,KAAKurB,2BACT,CAME,0BAAAU,GACE,IAAKjsB,KAAKynB,YAAYgC,kBACpB,OAIF,MAAMvd,EAAclM,KAAKynB,YAAYrP,OAAOrG,KAAInE,GAASA,EAAMiP,kBAG/D,OAAQ7c,KAAKgO,QAAQwa,MACrB,IAAK,WACHxoB,KAAKynB,YAAYgC,kBAAkB7K,eAAe1S,GAClD,MAEF,IAAK,OACL,IAAK,SAEH,GAAIA,EAAYc,QAAU,EAAG,CAE3B,MAAMmf,EAAqB,IAAIjgB,GAG/BlM,KAAKynB,YAAYgC,kBAAkBrH,SAAS,CAAC+J,GACrD,MAEQnsB,KAAKynB,YAAYgC,kBAAkBrH,SAAS,CAAClW,IAIrD,CAME,yBAAAsf,GACE,IAAKxrB,KAAKynB,YAAYgC,oBAAsBzpB,KAAKynB,YAAYkC,cAC3D,OAIF,MACMyC,EAAqB,IADPpsB,KAAKynB,YAAYrP,OAAOrG,KAAInE,GAASA,EAAMiP,kBACnB7c,KAAKynB,YAAYkC,eAG7D,OAAQ3pB,KAAKgO,QAAQwa,MACrB,IAAK,WACHxoB,KAAKynB,YAAYgC,kBAAkB7K,eAAewN,GAClD,MAEF,IAAK,OACL,IAAK,SAEDpsB,KAAKynB,YAAYgC,kBAAkBrH,SAAS,CAACgK,IAQjDpsB,KAAKurB,2BAA0B,EACnC,CAOE,yBAAAA,CAA0Bc,GAAU,GAIlC,GAFArsB,KAAKkrB,2BAEAlrB,KAAKynB,YAAYgC,kBACpB,OAIF,IAAI6C,EAAmB,EACnBC,EAAkB,GAClBC,EAAgB,GAEpB,OAAQxsB,KAAKgO,QAAQwa,MACrB,IAAK,WAEH,MAAMiE,EAAkBzsB,KAAKynB,YAAYrP,OAAOrG,KAAInE,GAASA,EAAMiP,kBAC/DwP,GAAWrsB,KAAKynB,YAAYkC,eAC9B8C,EAAgBnsB,KAAKN,KAAKynB,YAAYkC,eAIpC8C,EAAgBzf,QAAU,IAC5Bsf,EAAmBtsB,KAAK0sB,mBAAmBD,GAC3CF,EAAkBvsB,KAAKgO,QAAQya,MAG3BzoB,KAAKgO,QAAQ6a,qBACf2D,EAAgBxsB,KAAK2sB,2BAA2BF,KAGpD,MAEF,IAAK,OAEH,MAAMG,EAAkB5sB,KAAKynB,YAAYrP,OAAOrG,KAAInE,GAASA,EAAMiP,kBAMnE,GALIwP,GAAWrsB,KAAKynB,YAAYkC,eAC9BiD,EAAgBtsB,KAAKN,KAAKynB,YAAYkC,eAIpCiD,EAAgB5f,QAAU,IAC5Bsf,EAAmBtsB,KAAK6sB,eAAeD,GACvCL,EAAkBvsB,KAAKgO,QAAQ0a,UAG3B1oB,KAAKgO,QAAQ6a,oBAAoB,CAEnC,MAAMiE,EAAkB,IAAIF,EAAiBA,EAAgB,IAC7DJ,EAAgBxsB,KAAK2sB,2BAA2BG,EAC1D,CAEM,MAEF,IAAK,SAEH,MAAMC,EAAoB/sB,KAAKynB,YAAYrP,OAAOrG,KAAInE,GAASA,EAAMiP,kBAMrE,GALIwP,GAAWrsB,KAAKynB,YAAYkC,eAC9BoD,EAAkBzsB,KAAKN,KAAKynB,YAAYkC,eAItCoD,EAAkB/f,QAAU,GAAKhN,KAAKgO,QAAQ4B,WAChD0c,EAAmBtsB,KAAKgtB,iBAAiBD,GACzCR,EAAkBvsB,KAAKgO,QAAQ2a,YAG3B3oB,KAAKgO,QAAQ6a,oBAAoB,CAEnC,MAAMiE,EAAkB,IAAIC,EAAmBA,EAAkB,IACjEP,EAAgBxsB,KAAK2sB,2BAA2BG,EAC1D,EAMI,GAAIR,EAAmB,EAAG,CAExB,MAAMW,EAAiBjtB,KAAKktB,wBAAwBZ,EAAkBC,GActE,GAXAvsB,KAAKa,KAAK,sBAAuB,CAC/BqE,KAAMlF,KAAKgO,QAAQwa,KACnB9M,MAAO4Q,EACPa,KAAMZ,EACNU,eAAgBA,EAChBpc,SAAU2b,EAAcxf,OACxBogB,SAAUptB,KAAKynB,YAAYrP,OAAOpL,OAClCqf,QAASA,IAIPrsB,KAAKgO,QAAQ8a,gBAAiB,CAChC,MAAMuE,EAAgBrtB,KAAKstB,0BAErBC,EAAmBvtB,KAAK2mB,aAAa6G,YAAY,CACrDC,SAAUJ,EACVK,KAAMT,EACNhT,MAAOja,KAAKgO,QAAQob,aAGtBppB,KAAKynB,YAAYoC,kBAAkBvpB,KAAKitB,EAChD,CAGUvtB,KAAKgO,QAAQ6a,oBAAsB2D,EAAcxf,OAAS,GAC5Dwf,EAAcvrB,SAAQ,CAAC0sB,EAASC,KAE9B,GAAID,EAAQjS,OAAS,EACnB,OAIF,MAAMmS,EAAmB7tB,KAAKktB,wBAAwBS,EAAQjS,MAAO6Q,GAG/DuB,EAAe9tB,KAAK2mB,aAAa6G,YAAY,CACjDC,SAAUE,EAAQI,SAClBL,KAAMG,EACN5T,MAAO5T,OAAOwhB,OAAO,CAAE,EAAE7nB,KAAKgO,QAAQob,WAAY,CAChDC,KAAM,iBAIVrpB,KAAKynB,YAAYqC,cAAcxpB,KAAKwtB,EAAa,GAG3D,CACA,CAOE,uBAAAR,GACE,OAAQttB,KAAKgO,QAAQwa,MACrB,IAAK,WAEH,GAAIxoB,KAAKynB,YAAYrP,OAAOpL,OAAS,EAAG,CAEtC,OADkBhN,KAAKynB,YAAYrP,OAAOpY,KAAKynB,YAAYrP,OAAOpL,OAAS,GAC1D6P,eACzB,CACM,MAEF,IAAK,OACL,IAAK,SAEH,GAAI7c,KAAKynB,YAAYgC,kBACnB,OAAOzpB,KAAKynB,YAAYgC,kBAAkBuE,cAM9C,OAAIhuB,KAAKynB,YAAYrP,OAAOpL,OAAS,EAC5BhN,KAAKynB,YAAYrP,OAAO,GAAGyE,gBAG7B,IACX,CAME,oBAAA8O,GAEE,MAAMsC,EAAkC,aAAtBjuB,KAAKgO,QAAQwa,KAAsB,EAAI,EAEzD,IAAKxoB,KAAKynB,YAAYgC,mBAAqBzpB,KAAKynB,YAAYrP,OAAOpL,OAASihB,EAG1E,YADAjuB,KAAKkoB,SAKP,MAAMgG,EAAmBluB,KAAKynB,YAAYgC,kBAG1CzpB,KAAKisB,6BAGL,IAAIK,EAAmB,EACnBC,EAAkB,GAEtB,OAAQvsB,KAAKgO,QAAQwa,MACrB,IAAK,WACH,MAAMtc,EAAcgiB,EAAiBvP,iBACrC2N,EAAmBtsB,KAAK0sB,mBAAmBxgB,GAC3CqgB,EAAkBvsB,KAAKgO,QAAQya,MAC/B,MAEF,IAAK,OACH,MAAM0F,EAAYD,EAAiBhM,WAC/BiM,EAAUnhB,OAAS,IACrBsf,EAAmBtsB,KAAK6sB,eAAesB,EAAU,IACjD5B,EAAkBvsB,KAAKgO,QAAQ0a,WAEjC,MAEF,IAAK,SACH,MAAM0F,EAAcF,EAAiBhM,WACjCkM,EAAYphB,OAAS,IACvBsf,EAAmBtsB,KAAKgtB,iBAAiBoB,EAAY,IACrD7B,EAAkBvsB,KAAKgO,QAAQ2a,aAMnC,MAAMsE,EAAiBjtB,KAAKktB,wBAAwBZ,EAAkBC,GAGtE2B,EAAiBzS,YAAY,mBAAoB6Q,GACjD4B,EAAiBzS,YAAY,kBAAmB8Q,GAChD2B,EAAiBzS,YAAY,uBAAwBwR,GACrDiB,EAAiBzS,YAAY,aAAa,GAG1Czb,KAAKynB,YAAYrP,OAAOnX,SAAQ2M,IAC9BA,EAAM6N,YAAY,aAAa,EAAM,IAIvCzb,KAAKynB,YAAYiC,aAAappB,KAAK4tB,GAGnCluB,KAAKuqB,wBAGLvqB,KAAKa,KAAK,wBAAyB,CACjCua,QAAS8S,EACTxS,MAAO4Q,EACPa,KAAMZ,EACNU,eAAgBA,EAChBzE,KAAMxoB,KAAKgO,QAAQwa,MAEzB,CAQE,kBAAAkE,CAAmBxgB,GACjB,GAAIA,EAAYc,OAAS,EACvB,OAAO,EAGT,IAAIqhB,EAAgB,EAEpB,IAAK,IAAInhB,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAAK,CAO/CmhB,GANwBruB,KAAKunB,eAAe1Z,kBAC1C3B,EAAYgB,GACZhB,EAAYgB,EAAI,GAChB,CAAEe,iBAAkBjO,KAAKgO,QAAQ4B,UAIzC,CAGI,OAAO5P,KAAKsuB,iBAAiBD,EAAe,SAAUruB,KAAKgO,QAAQya,MACvE,CAQE,0BAAAkE,CAA2BzgB,GACzB,GAAIA,EAAYc,OAAS,EACvB,MAAO,GAGT,MAAM6D,EAAW,GAEjB,IAAK,IAAI3D,EAAI,EAAGA,EAAIhB,EAAYc,OAAS,EAAGE,IAAK,CAC/C,MAAMQ,EAAQxB,EAAYgB,GACpBS,EAAMzB,EAAYgB,EAAI,GAEtBqhB,EAAkBvuB,KAAKunB,eAAe1Z,kBAC1CH,EACAC,EACA,CAAEM,iBAAkBjO,KAAKgO,QAAQ4B,WAK7Bme,EAAW,CACfhrB,KAAM2K,EAAM3K,IAAM4K,EAAI5K,KAAO,EAC7BL,KAAMgL,EAAMhL,IAAMiL,EAAIjL,KAAO,EAC7BO,eAAgCwE,IAApBiG,EAAMzK,gBAA6CwE,IAAlBkG,EAAI1K,WAC9CyK,EAAMzK,UAAY0K,EAAI1K,WAAa,EAAI,GAItCurB,EAAoBxuB,KAAKsuB,iBAAiBC,EAAiB,SAAUvuB,KAAKgO,QAAQya,OAExF5X,EAASvQ,KAAK,CACZob,MAAO8S,EACPT,SAAUA,GAElB,CAEI,OAAOld,CACX,CAQE,cAAAgc,CAAe3gB,GACb,GAAIA,EAAYc,OAAS,EACvB,OAAO,EAIT,MAAMyhB,EAAoB,IAAIviB,GAGxB+T,EAAQwO,EAAkB,GAC1BvO,EAAOuO,EAAkBA,EAAkBzhB,OAAS,GACzCiT,EAAMld,MAAQmd,EAAKnd,KAAOkd,EAAMvd,MAAQwd,EAAKxd,KAG5D+rB,EAAkBnuB,KAAKmuB,EAAkB,IAI3C,MAAM5X,EAAO7W,KAAKunB,eAAe1Y,cAAc4f,EAAmB,CAChExgB,iBAAkBjO,KAAKgO,QAAQ4B,WAIjC,OAAO5P,KAAK0uB,aAAa7X,EAAM,gBAAiB7W,KAAKgO,QAAQ0a,UACjE,CAQE,gBAAAsE,CAAiB9gB,GACf,GAAIA,EAAYc,OAAS,IAAMhN,KAAKgO,QAAQ4B,SAC1C,OAAO,EAIT,MAAM6e,EAAoB,IAAIviB,GAGxB+T,EAAQwO,EAAkB,GAC1BvO,EAAOuO,EAAkBA,EAAkBzhB,OAAS,GACzCiT,EAAMld,MAAQmd,EAAKnd,KAAOkd,EAAMvd,MAAQwd,EAAKxd,KAG5D+rB,EAAkBnuB,KAAKmuB,EAAkB,IAI3C,MAAME,EAAS3uB,KAAKunB,eAAejD,gBACjCtkB,KAAKunB,eAAejD,gBAAgBmK,GACpCzuB,KAAK4uB,yBAAyBH,GAGhC,OAAOzuB,KAAK6uB,eAAeF,EAAQ,eAAgB3uB,KAAKgO,QAAQ2a,YACpE,CAQE,wBAAAiG,CAAyB1iB,GAEvB,MAAM4iB,EAAW9uB,KAAK6sB,eAAe3gB,GAGrC,IAAI6iB,EAAc,EACdC,EAAc,EAElB,IAAK,MAAM7gB,KAASjC,OACMzE,IAApB0G,EAAMlL,WAA+C,OAApBkL,EAAMlL,YACzC8rB,GAAe5gB,EAAMlL,UACrB+rB,KAKJ,GAAIA,EAAc,EAAG,CAEnB,OAAOF,GADWC,EAAcC,EAEtC,CAEI,OAAO,CACX,CAUE,gBAAAV,CAAiB3e,EAAUsf,EAAUC,GACnC,GAAID,IAAaC,EACf,OAAOvf,EAIT,IAAIwf,EAASxf,EACb,GAAiB,WAAbsf,EACF,OAAQA,GACR,IAAK,OACHE,EAAoB,MAAXxf,EACT,MACF,IAAK,aACHwf,EAAoB,IAAXxf,EACT,MACF,IAAK,QACHwf,EAAoB,SAAXxf,EAMb,OAAQuf,GACR,IAAK,SAQL,QACE,OAAOC,EAPT,IAAK,OACH,OAAOA,EAAS,MAClB,IAAK,aACH,OAAOA,EAAS,IAClB,IAAK,QACH,OAAOA,EAAS,SAItB,CAUE,YAAAT,CAAa7X,EAAMoY,EAAUC,GAC3B,GAAID,IAAaC,EACf,OAAOrY,EAIT,IAAIuY,EAAevY,EACnB,GAAiB,kBAAboY,EACF,OAAQA,GACR,IAAK,cACHG,EAAsB,QAAPvY,EACf,MACF,IAAK,WACHuY,EAAsB,IAAPvY,EACf,MACF,IAAK,QACHuY,EAAsB,SAAPvY,EAMnB,OAAQqY,GACR,IAAK,gBAQL,QACE,OAAOE,EAPT,IAAK,cACH,OAAOA,EAAe,QACxB,IAAK,WACH,OAAOA,EAAe,IACxB,IAAK,QACH,OAAOA,EAAe,SAI5B,CAUE,cAAAP,CAAeF,EAAQM,EAAUC,GAC/B,GAAID,IAAaC,EACf,OAAOP,EAIT,IAAIU,EAAcV,EAClB,GAAiB,iBAAbM,GAEG,eADGA,EAENI,EAAuB,SAATV,EAMlB,OAAQO,GACR,IAAK,eAIL,QACE,OAAOG,EAHT,IAAK,aACH,OAAOA,EAAc,SAI3B,CASE,uBAAAnC,CAAwBxR,EAAOyR,GAE7B,IAAIF,EACAqC,EAGJ,OAAQnC,GACR,IAAK,SACHF,EAAiBvR,EAAQ,GAAKA,EAAM1Y,QAAQ,GAAKR,KAAK+sB,MAAM7T,GAAOvP,WACnEmjB,EAAc,IACd,MACF,IAAK,OACHrC,EAAiBvR,EAAQ,GAAKA,EAAM1Y,QAAQ,GAAKR,KAAK+sB,MAAM7T,GAAOvP,WACnEmjB,EAAc,KACd,MACF,IAAK,aACHrC,EAAiBvR,EAAM1Y,QAAQ,GAC/BssB,EAAc,KACd,MACF,IAAK,QACHrC,EAAiBvR,EAAM1Y,QAAQ,GAC/BssB,EAAc,KACd,MACF,IAAK,gBACHrC,EAAiBvR,EAAQ,GAAKA,EAAM1Y,QAAQ,GAAKR,KAAK+sB,MAAM7T,GAAOvP,WACnEmjB,EAAc,KACd,MACF,IAAK,cACHrC,EAAiBvR,EAAQ,GAAKA,EAAM1Y,QAAQ,GAAKR,KAAK+sB,MAAM7T,GAAOvP,WACnEmjB,EAAc,MACd,MACF,IAAK,WACHrC,EAAiBvR,EAAM1Y,QAAQ,GAC/BssB,EAAc,KACd,MACF,IAAK,QACHrC,EAAiBvR,EAAM1Y,QAAQ,GAC/BssB,EAAc,KACd,MACF,IAAK,eACHrC,EAAiBvR,EAAQ,GAAKA,EAAM1Y,QAAQ,GAAKR,KAAK+sB,MAAM7T,GAAOvP,WACnEmjB,EAAc,KACd,MACF,IAAK,aACHrC,EAAiBvR,EAAQ,GAAKA,EAAM1Y,QAAQ,GAAKR,KAAK+sB,MAAM7T,GAAOvP,WACnEmjB,EAAc,MACd,MACF,QACErC,EAAiBvR,EAAMvP,WACvBmjB,EAAcnC,EAGhB,MAAO,GAAGF,KAAkBqC,GAChC,CAOE,OAAAE,CAAQhH,GACN,MAAK,CAAC,WAAY,OAAQ,UAAUjf,SAASif,IAM7CxoB,KAAKgO,QAAQwa,KAAOA,EAGhBxoB,KAAKwnB,UACPxnB,KAAKkoB,SAIPloB,KAAKa,KAAK,eAAgB,CAAE2nB,UAErB,IAfLznB,QAAQG,MAAM,6BAA6BsnB,MACpC,EAeb,CAUE,QAAAiH,CAAShH,EAAQ,IAEf,OAAIA,EAAM9Y,WAAa,CAAC,SAAU,OAAQ,aAAc,SAASpG,SAASkf,EAAM9Y,WAC9E5O,QAAQG,MAAM,0BAA0BunB,EAAM9Y,aACvC,GAGL8Y,EAAM5R,OAAS,CAAC,gBAAiB,cAAe,WAAY,SAAStN,SAASkf,EAAM5R,OACtF9V,QAAQG,MAAM,sBAAsBunB,EAAM5R,SACnC,GAGL4R,EAAMkG,SAAW,CAAC,eAAgB,cAAcplB,SAASkf,EAAMkG,SACjE5tB,QAAQG,MAAM,wBAAwBunB,EAAMkG,WACrC,IAILlG,EAAM9Y,WAAU3P,KAAKgO,QAAQya,MAAQA,EAAM9Y,UAC3C8Y,EAAM5R,OAAM7W,KAAKgO,QAAQ0a,UAAYD,EAAM5R,MAC3C4R,EAAMkG,SAAQ3uB,KAAKgO,QAAQ2a,YAAcF,EAAMkG,QAG/C3uB,KAAKwnB,UAAYxnB,KAAKynB,YAAYgC,mBACpCzpB,KAAKurB,4BAIPvrB,KAAKa,KAAK,gBAAiB,CACzB8O,SAAU3P,KAAKgO,QAAQya,MACvB5R,KAAM7W,KAAKgO,QAAQ0a,UACnBiG,OAAQ3uB,KAAKgO,QAAQ2a,eAGhB,EACX,CAOE,WAAA+G,CAAYC,GAaV,OAZA3vB,KAAKgO,QAAQ4B,WAAa+f,EAGtB3vB,KAAKwnB,UAAYxnB,KAAKynB,YAAYgC,mBACpCzpB,KAAKurB,4BAIPvrB,KAAKa,KAAK,oBAAqB,CAC7B+O,SAAU5P,KAAKgO,QAAQ4B,WAGlB5P,KAAKgO,QAAQ4B,QACxB,CAME,mBAAAggB,GAIE,OAHA5vB,KAAK2rB,uBAGD3rB,KAAKynB,YAAYiC,aAAa1c,OAAS,EAClChN,KAAKynB,YAAYiC,aAAa1pB,KAAKynB,YAAYiC,aAAa1c,OAAS,GAGvE,IACX,CAME,eAAA6iB,GACE,OAAO7vB,KAAKynB,YAAYiC,YAC5B,CAKE,oBAAAoG,GAEE9vB,KAAKwqB,8BAGLxqB,KAAKkoB,SAGLloB,KAAKa,KAAK,uBACd,EChrCO,MAAMkvB,UAAmB1I,EAK9B,WAAAtnB,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAGNhO,KAAKgO,QAAU3H,OAAOwhB,OAAO,CAC3BW,KAAM,QACNC,MAAO,SACP7Y,UAAU,EACVogB,gBAAiB,EACjBC,eAAgB,EAChBC,aAAc,EACdC,YAAa,EACbC,aAAc,CACZlrB,KAAM,SACNsgB,KAAM,EACNsF,MAAO,WAETuF,aAAc,CACZnrB,KAAM,SACNsgB,KAAM,EACNsF,MAAO,WAET/B,WAAY,CACViC,MAAO,EACPF,MAAO,UACPwF,UAAW,OAEbC,cAAe,CACbrrB,KAAM,SACNsgB,KAAM,EACNsF,MAAO,yBACPC,aAAc,EACdF,aAAc,YAEf7c,GAGHhO,KAAKynB,YAAc,CACjB+I,cAAe,KACfC,cAAe,KACfC,eAAgB,KAChBC,WAAY,KACZC,eAAgB5wB,KAAKgO,QAAQgiB,gBAC7Ba,cAAe7wB,KAAKgO,QAAQiiB,eAC5BtG,cAAe,KACfmH,cAAe,KACfC,aAAa,GAIf/wB,KAAK+pB,gBAAkB/pB,KAAK+pB,gBAAgBC,KAAKhqB,MACjDA,KAAKiqB,oBAAsBjqB,KAAKiqB,oBAAoBD,KAAKhqB,MACzDA,KAAKkqB,sBAAwBlqB,KAAKkqB,sBAAsBF,KAAKhqB,MAC7DA,KAAKoqB,eAAiBpqB,KAAKoqB,eAAeJ,KAAKhqB,MAC/CA,KAAKgxB,uBAAyBhxB,KAAKgxB,uBAAuBhH,KAAKhqB,KACnE,CAOE,oBAAA0nB,GAEE1nB,KAAKsnB,QAAQnnB,GAAG,kBAAmBH,KAAKgxB,uBAC5C,CAOE,SAAAlJ,GAEE9nB,KAAK2mB,aAAalmB,iBAAiB,QAAST,KAAK+pB,iBACjD/pB,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAKiqB,qBACrDjqB,KAAK2mB,aAAalmB,iBAAiB,WAAYT,KAAKkqB,uBAGpDI,SAAS7pB,iBAAiB,UAAWT,KAAKoqB,gBAG1CpqB,KAAKixB,eAAejxB,KAAKgO,QAAQwa,MAGjCxoB,KAAKynB,YAAYmJ,eAAiB5wB,KAAKgO,QAAQgiB,gBAC/ChwB,KAAKynB,YAAYoJ,cAAgB7wB,KAAKgO,QAAQiiB,eAG9CjwB,KAAKa,KAAK,YAAa,CACrB2nB,KAAMxoB,KAAKgO,QAAQwa,KACnBoI,eAAgB5wB,KAAKynB,YAAYmJ,eACjCC,cAAe7wB,KAAKynB,YAAYoJ,eAEtC,CAOE,WAAA7I,GAEEhoB,KAAK2mB,aAAavlB,oBAAoB,QAASpB,KAAK+pB,iBACpD/pB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAKiqB,qBACxDjqB,KAAK2mB,aAAavlB,oBAAoB,WAAYpB,KAAKkqB,uBAGvDI,SAASlpB,oBAAoB,UAAWpB,KAAKoqB,gBAG7CpqB,KAAKkxB,wBAGLlxB,KAAKynB,YAAc,CACjB+I,cAAe,KACfC,cAAe,KACfC,eAAgB,KAChBC,WAAY,KACZC,eAAgB5wB,KAAKgO,QAAQgiB,gBAC7Ba,cAAe7wB,KAAKgO,QAAQiiB,eAC5BtG,cAAe,KACfmH,cAAe,KACfC,aAAa,EAEnB,CAOE,MAAA7I,GAEEloB,KAAKkxB,wBAGL,MAAMzd,EAAkBzT,KAAKynB,YAAYmJ,eACnCO,EAAiBnxB,KAAKynB,YAAYoJ,cAClCO,EAAcpxB,KAAKgO,QAAQwa,KAEjCxoB,KAAKynB,YAAc,CACjB+I,cAAe,KACfC,cAAe,KACfC,eAAgB,KAChBC,WAAY,KACZC,eAAgBnd,EAChBod,cAAeM,EACfxH,cAAe,KACfmH,cAAe,KACfC,aAAa,GAIf/wB,KAAKa,KAAK,QAAS,CACjB2nB,KAAM4I,EACNR,eAAgBnd,EAChBod,cAAeM,GAErB,CAOE,cAAAF,CAAezI,GAER,CAAC,QAAS,OAAQ,iBAAiBjf,SAASif,KAC/CznB,QAAQG,MAAM,wBAAwBsnB,KACtCA,EAAO,SAITxoB,KAAKgO,QAAQwa,KAAOA,EAGpBxoB,KAAKkoB,SAGLloB,KAAKa,KAAK,cAAe,CAAE2nB,QAC/B,CAME,qBAAA0I,GAEMlxB,KAAKynB,YAAYiJ,iBACnB1wB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAYiJ,gBAC5D1wB,KAAKynB,YAAYiJ,eAAiB,MAGhC1wB,KAAKynB,YAAYkJ,aACnB3wB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAYkJ,YAC5D3wB,KAAKynB,YAAYkJ,WAAa,KAEpC,CAOE,eAAA5G,CAAgB3pB,GAEd,OAAQJ,KAAKgO,QAAQwa,MACrB,IAAK,QACExoB,KAAKynB,YAAY+I,cAYpBxwB,KAAKqxB,qBAVDrxB,KAAKynB,YAAYqJ,eAEnB9wB,KAAKynB,YAAY+I,cAAgBxwB,KAAKynB,YAAYqJ,cAClD9wB,KAAKsxB,6BAGLtxB,KAAKuxB,mBAAmBnxB,EAAMwC,YAMlC,MAEF,IAAK,OACL,IAAK,gBACH,GAAK5C,KAAKynB,YAAY+I,cAaXxwB,KAAKynB,YAAY+I,eAAyD,SAAxCxwB,KAAKynB,YAAY+I,cAActrB,OACtElF,KAAKynB,YAAY+I,cAAcgB,YAEjCxxB,KAAKyxB,sBAAsBrxB,EAAMwC,YAGjC5C,KAAK0xB,6BAnB4B,CAEnC,MACMC,EADmB3xB,KAAKsnB,QAAQzB,sBACA+L,MAAKC,GAAgB,SAAXA,EAAE3sB,OAE9CysB,GAEF3xB,KAAKynB,YAAY+I,cAAgBmB,EACjC3xB,KAAK8xB,4BAGL9xB,KAAK+xB,yBAAyB3xB,EAAMwC,WAE9C,EAWA,CAOE,mBAAAqnB,CAAoB7pB,GAKlB,GAHAJ,KAAKynB,YAAYkC,cAAgBvpB,EAAMwC,WAGnC5C,KAAKynB,YAAY+I,cACnB,OAAQxwB,KAAKgO,QAAQwa,MACrB,IAAK,QACHxoB,KAAKsxB,4BACL,MAEF,IAAK,OACL,IAAK,gBACCtxB,KAAKynB,YAAY+I,cAAcgB,YAEjCxxB,KAAKgyB,6BAGLhyB,KAAK8xB,2BAKf,CAOE,qBAAA5H,CAAsB9pB,GAEhBA,EAAMqrB,eACRrrB,EAAMqrB,cAAcC,iBAIlB,CAAC,OAAQ,iBAAiBniB,SAASvJ,KAAKgO,QAAQwa,OAChDxoB,KAAKynB,YAAY+I,eACjBxwB,KAAKynB,YAAY+I,cAAcgB,aACjCxxB,KAAKiyB,qBAEX,CAOE,cAAA7H,CAAehqB,GAgCb,GA9BkB,WAAdA,EAAMwrB,MACJ,CAAC,OAAQ,iBAAiBriB,SAASvJ,KAAKgO,QAAQwa,OAChDxoB,KAAKynB,YAAY+I,eACjBxwB,KAAKynB,YAAY+I,cAAcgB,YAEjCxxB,KAAKkyB,oBAGLlyB,KAAKkoB,UAKS,UAAd9nB,EAAMwrB,MACJ,CAAC,OAAQ,iBAAiBriB,SAASvJ,KAAKgO,QAAQwa,OAChDxoB,KAAKynB,YAAY+I,eACjBxwB,KAAKynB,YAAY+I,cAAcgB,YAEjCxxB,KAAKiyB,sBACIjyB,KAAKynB,YAAY+I,gBAEA,UAAtBxwB,KAAKgO,QAAQwa,KACfxoB,KAAKqxB,qBAELrxB,KAAK0xB,0BAMPtxB,EAAMwrB,KAAO,KAAOxrB,EAAMwrB,KAAO,IAAK,CACxC,MAAMjc,EAAWwiB,SAAS/xB,EAAMwrB,MAAQxrB,EAAMgyB,SAAW,GAAK,GAC9DpyB,KAAKqyB,kBAAkB1iB,EAC7B,CAGsB,cAAdvP,EAAMwrB,KACR5rB,KAAKsyB,yBACLlyB,EAAMsrB,kBACiB,eAAdtrB,EAAMwrB,KACf5rB,KAAKsyB,oBAAoB,IACzBlyB,EAAMsrB,kBACiB,YAAdtrB,EAAMwrB,KACf5rB,KAAKuyB,qBAAqB,GAC1BnyB,EAAMsrB,kBACiB,cAAdtrB,EAAMwrB,MACf5rB,KAAKuyB,yBACLnyB,EAAMsrB,iBAEZ,CAOE,sBAAAsF,CAAuB5V,GAChBpb,KAAKwnB,WAKW,UAAjBpM,EAAQlW,MAA0C,UAAtBlF,KAAKgO,QAAQwa,OAC3CxoB,KAAKynB,YAAYqJ,cAAgB1V,EAG5Bpb,KAAKynB,YAAY+I,gBACpBxwB,KAAKynB,YAAY+I,cAAgBpV,EACjCpb,KAAKsxB,8BAKY,SAAjBlW,EAAQlW,MAAmB,CAAC,OAAQ,iBAAiBqE,SAASvJ,KAAKgO,QAAQwa,QAExExoB,KAAKynB,YAAY+I,gBACpBxwB,KAAKynB,YAAY+I,cAAgBpV,EACjCpb,KAAK8xB,6BAGb,CAOE,kBAAAP,CAAmB3uB,GAEjB,MAAM4vB,EAAc,IAAI/V,EAAa7Z,EAAW,CAC9C8W,GAAI,iBAAiBC,KAAKC,QAC1BM,WAAY,CACVhV,KAAM,gBACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQoiB,eAIlBpwB,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmBwG,GAIlCxyB,KAAKsnB,QAAQ5C,SAASC,WAAW6N,GAGjCxyB,KAAKynB,YAAY+I,cAAgBgC,EAGjCxyB,KAAKsxB,4BAGLtxB,KAAKa,KAAK,qBAAsB2xB,EACpC,CAME,yBAAAlB,GAIE,GAFAtxB,KAAKkxB,yBAEAlxB,KAAKynB,YAAY+I,eAAyD,UAAxCxwB,KAAKynB,YAAY+I,cAActrB,KACpE,OAIF,MAAMutB,EAAczyB,KAAKynB,YAAY+I,cAAc3T,gBAGnD,IAAInR,EAAU1L,KAAKynB,YAAYoJ,cAG/B,GAAI7wB,KAAKynB,YAAYkC,cAAe,CAClC,MAAM+I,EAAeD,EAAYhnB,UAAU,IAAIpI,EAAWrD,KAAKynB,YAAYkC,gBAIzEje,EAFE1L,KAAKynB,YAAYsJ,YAETvuB,KAAK+sB,MAAMmD,EAAe1yB,KAAKgO,QAAQmiB,aAAenwB,KAAKgO,QAAQmiB,YAEnEuC,EAIZ1yB,KAAKynB,YAAYoJ,cAAgBnlB,CACvC,CAGI,MAAMinB,EAAc7lB,EAAeqH,sBACjCse,EACAzyB,KAAKynB,YAAYmJ,eACjBllB,GAIF1L,KAAKynB,YAAYiJ,eAAiB,IAAIjU,EAAakW,EAAY,CAC7DjZ,GAAI,kBAAkBC,KAAKC,QAC3BM,WAAY,CACVhV,KAAM,iBACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQuiB,gBAItBvwB,KAAKynB,YAAYkJ,WAAa,IAAIxS,EAAY,CAACsU,EAAaE,GAAa,CACvEjZ,GAAI,eAAeC,KAAKC,QACxBM,WAAY,CACVhV,KAAM,cACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQ+a,aAItB/oB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAW3kB,KAAKynB,YAAYiJ,gBACzD1wB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAW3kB,KAAKynB,YAAYkJ,YAGzD3wB,KAAKa,KAAK,iBAAkB,CAC1B8O,SAAU3P,KAAKynB,YAAYmJ,eAC3BllB,QAAS1L,KAAKynB,YAAYoJ,cAC1B+B,iBAAkBH,EAClBI,iBAAkBF,GAExB,CAME,kBAAAtB,GACE,IAAKrxB,KAAKynB,YAAY+I,gBAAkBxwB,KAAKynB,YAAYiJ,eACvD,OAIF,MAAMiC,EAAc3yB,KAAKynB,YAAYiJ,eAAe7T,gBAG9C1M,EAAc,IAAIsM,EAAakW,EAAa,CAChDjZ,GAAI,iBAAiBC,KAAKC,QAC1BM,WAAY,CACVhV,KAAM,gBACN0rB,eAAgB5wB,KAAKynB,YAAYmJ,eACjCC,cAAe7wB,KAAKynB,YAAYoJ,cAChCiC,gBAAiB9yB,KAAKynB,YAAY+I,cAAc9W,GAChDiR,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQqiB,eAItBrwB,KAAKsnB,QAAQ5C,SAASC,WAAWxU,GAGjCnQ,KAAKynB,YAAYgJ,cAAgBtgB,EAGjCnQ,KAAKkxB,wBAGLlxB,KAAKynB,YAAY+I,cAAgB,KAGjCxwB,KAAKa,KAAK,qBAAsB,CAC9B2vB,cAAexwB,KAAKynB,YAAY+I,cAChCC,cAAetgB,EACfR,SAAU3P,KAAKynB,YAAYmJ,eAC3BllB,QAAS1L,KAAKynB,YAAYoJ,gBAI5B7wB,KAAKkoB,QACT,CAOE,wBAAA6J,CAAyBnvB,GAEvB,MAAMmwB,EAAa,IAAI5U,EAAY,CAACvb,GAAa,CAC/C8W,GAAI,sBAAsBC,KAAKC,QAC/BM,WAAY,CACVhV,KAAM,gBACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQoiB,eAIlBpwB,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmB+G,GAIlC/yB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAWoO,GAGxC/yB,KAAKynB,YAAY+I,cAAgBuC,EAGjC/yB,KAAKa,KAAK,oBAAqBkyB,EACnC,CAOE,qBAAAtB,CAAsB7uB,GACpB,IAAK5C,KAAKynB,YAAY+I,eAAyD,SAAxCxwB,KAAKynB,YAAY+I,cAActrB,KACpE,OAIF,MAAMgH,EAAclM,KAAKynB,YAAY+I,cAAc7R,iBAGnDzS,EAAY5L,KAAKsC,GAGjB5C,KAAKynB,YAAY+I,cAAc5R,eAAe1S,GAG1ClM,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmBhsB,KAAKynB,YAAY+I,eAIxB,IAAvBtkB,EAAYc,QACdhN,KAAK8xB,2BAIP9xB,KAAKa,KAAK,uBAAwB,CAChCmyB,KAAMhzB,KAAKynB,YAAY+I,cACvB5tB,WAAYA,EACZ6M,WAAYvD,EAAYc,OAAS,GAEvC,CAME,0BAAAglB,GACE,IAAKhyB,KAAKynB,YAAY+I,eACsB,SAAxCxwB,KAAKynB,YAAY+I,cAActrB,OAC9BlF,KAAKynB,YAAY+I,cAAcgB,cAC/BxxB,KAAKynB,YAAYkC,cACpB,OAIF,MAAMzd,EAAclM,KAAKynB,YAAY+I,cAAc7R,iBAGnD,GAA2B,IAAvBzS,EAAYc,OACd,OAIF,MAAMimB,EAAgB,IAAI/mB,EAAYmV,MAAM,GAAG,GAAKrhB,KAAKynB,YAAYkC,eAGrE3pB,KAAKynB,YAAY+I,cAAc5R,eAAeqU,GAG1CA,EAAcjmB,QAAU,GAC1BhN,KAAK8xB,0BAEX,CAME,mBAAAG,GACE,IAAKjyB,KAAKynB,YAAY+I,eACsB,SAAxCxwB,KAAKynB,YAAY+I,cAActrB,OAC9BlF,KAAKynB,YAAY+I,cAAcgB,YAClC,OAIF,MAAMtlB,EAAclM,KAAKynB,YAAY+I,cAAc7R,iBAGnD,GAAIzS,EAAYc,OAAS,EAEvB,YADAhN,KAAKkyB,oBAKP,MAAMa,EAAa,IAAI5U,EAAYjS,EAAa,CAC9CwN,GAAI,sBAAsBC,KAAKC,QAC/BM,WAAY,CACVhV,KAAM,gBACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQoiB,eAIlBpwB,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmB+G,GAIlC/yB,KAAKsnB,QAAQ5C,SAASC,WAAWoO,GAGjC/yB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAY+I,eAG5DxwB,KAAKynB,YAAY+I,cAAgBuC,EAGjC/yB,KAAK8xB,2BAGL9xB,KAAKa,KAAK,sBAAuBkyB,EACrC,CAME,iBAAAb,GACOlyB,KAAKynB,YAAY+I,eAAkBxwB,KAAKynB,YAAY+I,cAAcgB,cAKvExxB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAY+I,eAG5DxwB,KAAKynB,YAAY+I,cAAgB,KACjCxwB,KAAKkxB,wBAGLlxB,KAAKa,KAAK,uBACd,CAME,wBAAAixB,GAIE,GAFA9xB,KAAKkxB,yBAEAlxB,KAAKynB,YAAY+I,eAAyD,SAAxCxwB,KAAKynB,YAAY+I,cAActrB,KACpE,OAIF,MAAMguB,EAAelzB,KAAKynB,YAAY+I,cAAc7R,iBAGpD,GAAIuU,EAAalmB,OAAS,EACxB,OAGF,IAAI0T,EAEJ,GAA0B,SAAtB1gB,KAAKgO,QAAQwa,KAEf9H,EAAe1gB,KAAKunB,eAAe3T,iBACjCsf,EACAlzB,KAAKynB,YAAYmJ,eACjB,CAAEhhB,SAAU5P,KAAKgO,QAAQ4B,WAI3B5P,KAAKynB,YAAYiJ,eAAiB,IAAIvS,EAAYuC,EAAa,CAC7DhH,GAAI,kBAAkBC,KAAKC,QAC3BM,WAAY,CACVhV,KAAM,iBACNylB,WAAW,GAEb1Q,MAAO5T,OAAOwhB,OAAO,CAAE,EAAE7nB,KAAKgO,QAAQ+a,WAAY,CAChDuH,UAAW,eAIV,GAA0B,kBAAtBtwB,KAAKgO,QAAQwa,MAElBxoB,KAAKynB,YAAYkC,cAAe,CAElC,MAAMwJ,EAAcnzB,KAAKynB,YAAY+I,cAAcxV,QAAQhb,KAAKynB,YAAYkC,eAE5E,GAAIwJ,EAAa,CAEf,MAAMC,EAAgBpzB,KAAKunB,eAAe/X,6BACxC0jB,EACAC,EAAY1jB,WACZ0jB,EAAYzjB,gBACZ1P,KAAKynB,YAAYmJ,eACjB,CAAEhhB,SAAU5P,KAAKgO,QAAQ4B,WAI3B5P,KAAKynB,YAAYiJ,eAAiB,IAAIjU,EAAa2W,EAAcjjB,YAAY,CAC3EuJ,GAAI,kBAAkBC,KAAKC,QAC3BM,WAAY,CACVhV,KAAM,iBACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQuiB,gBAItBvwB,KAAKynB,YAAYkJ,WAAa,IAAIxS,EAAY,CAACgV,EAAYnjB,aAAcojB,EAAcjjB,aAAc,CACnGuJ,GAAI,eAAeC,KAAKC,QACxBM,WAAY,CACVhV,KAAM,cACNylB,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQ+a,aAItB/oB,KAAKynB,YAAY4L,kBAAoB,CACnC5jB,WAAY0jB,EAAY1jB,WACxBC,gBAAiByjB,EAAYzjB,gBAC7BM,aAAcmjB,EAAYnjB,aAC1BG,YAAaijB,EAAcjjB,YAEvC,CACA,CAIQnQ,KAAKynB,YAAYiJ,gBACnB1wB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAW3kB,KAAKynB,YAAYiJ,gBAGvD1wB,KAAKynB,YAAYkJ,YACnB3wB,KAAKsnB,QAAQ2D,gBAAgBtG,WAAW3kB,KAAKynB,YAAYkJ,YAI3D3wB,KAAKa,KAAK,iBAAkB,CAC1B8O,SAAU3P,KAAKynB,YAAYmJ,eAC3BJ,cAAexwB,KAAKynB,YAAY+I,cAChCE,eAAgB1wB,KAAKynB,YAAYiJ,gBAEvC,CAME,qBAAAgB,GACE,IAAK1xB,KAAKynB,YAAY+I,gBAAkBxwB,KAAKynB,YAAYiJ,eACvD,OAGF,IAAI4C,EAEJ,GAA0B,SAAtBtzB,KAAKgO,QAAQwa,KAAiB,CAEhC,MAAM9H,EAAe1gB,KAAKynB,YAAYiJ,eAAe/R,iBAGrD2U,EAAgB,IAAInV,EAAYuC,EAAc,CAC5ChH,GAAI,iBAAiBC,KAAKC,QAC1BM,WAAY,CACVhV,KAAM,gBACN0rB,eAAgB5wB,KAAKynB,YAAYmJ,eACjCkC,gBAAiB9yB,KAAKynB,YAAY+I,cAAc9W,GAChDiR,WAAW,GAEb1Q,MAAO5T,OAAOwhB,OAAO,CAAE,EAAE7nB,KAAKgO,QAAQ+a,WAAY,CAChDuH,UAAW,QAIhB,MAAM,GAA0B,kBAAtBtwB,KAAKgO,QAAQwa,KAA0B,CAEhD,MAAMmK,EAAc3yB,KAAKynB,YAAYiJ,eAAe7T,gBAGpDyW,EAAgB,IAAI7W,EAAakW,EAAa,CAC5CjZ,GAAI,iBAAiBC,KAAKC,QAC1BM,WAAY,CACVhV,KAAM,gBACN0rB,eAAgB5wB,KAAKynB,YAAYmJ,eACjCkC,gBAAiB9yB,KAAKynB,YAAY+I,cAAc9W,GAChDjK,WAAYzP,KAAKynB,YAAY4L,kBAAkB5jB,WAC/CC,gBAAiB1P,KAAKynB,YAAY4L,kBAAkB3jB,gBACpDib,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQqiB,cAE5B,CAEQiD,IAEFtzB,KAAKsnB,QAAQ5C,SAASC,WAAW2O,GAGjCtzB,KAAKynB,YAAYgJ,cAAgB6C,EAGjCtzB,KAAKa,KAAK,uBAAwB,CAChC2vB,cAAexwB,KAAKynB,YAAY+I,cAChCC,cAAe6C,EACf3jB,SAAU3P,KAAKynB,YAAYmJ,eAC3BpI,KAAMxoB,KAAKgO,QAAQwa,QAKvBxoB,KAAKkxB,wBAGLlxB,KAAKynB,YAAY+I,cAAgB,KAGjCxwB,KAAKkoB,QACT,CAOE,iBAAAmK,CAAkB1iB,GAEhB,OAAIrF,MAAMqF,IAAaA,GAAY,GACjC5O,QAAQG,MAAM,uDACPlB,KAAKynB,YAAYmJ,iBAI1B5wB,KAAKynB,YAAYmJ,eAAiBjhB,EAG9B3P,KAAKynB,YAAY+I,gBACO,UAAtBxwB,KAAKgO,QAAQwa,KACfxoB,KAAKsxB,4BAELtxB,KAAK8xB,4BAKT9xB,KAAKa,KAAK,wBAAyB,CACjC8O,SAAU3P,KAAKynB,YAAYmJ,iBAGtB5wB,KAAKynB,YAAYmJ,eAC5B,CAOE,gBAAA2C,CAAiB7nB,GAEf,OAAIpB,MAAMoB,IACR3K,QAAQG,MAAM,6CACPlB,KAAKynB,YAAYoJ,gBAI1BnlB,GAAWA,EAAU,IAAM,KAAO,IAGlC1L,KAAKynB,YAAYoJ,cAAgBnlB,EAG7B1L,KAAKynB,YAAY+I,eAAuC,UAAtBxwB,KAAKgO,QAAQwa,MACjDxoB,KAAKsxB,4BAIPtxB,KAAKa,KAAK,uBAAwB,CAChC6K,QAAS1L,KAAKynB,YAAYoJ,gBAGrB7wB,KAAKynB,YAAYoJ,cAC5B,CAOE,oBAAA0B,CAAqBiB,GAEnB,MAAMC,EAAcjxB,KAAK+H,IACvB,EACA/H,KAAK+sB,OAAOvvB,KAAKynB,YAAYmJ,eAAiB4C,GAAUxzB,KAAKgO,QAAQkiB,cAAgBlwB,KAAKgO,QAAQkiB,cAGpG,OAAOlwB,KAAKqyB,kBAAkBoB,EAClC,CAOE,mBAAAnB,CAAoBkB,GAElB,MAAME,EAAalxB,KAAK+sB,OAAOvvB,KAAKynB,YAAYoJ,cAAgB2C,GAAUxzB,KAAKgO,QAAQmiB,aAAenwB,KAAKgO,QAAQmiB,YAEnH,OAAOnwB,KAAKuzB,iBAAiBG,EACjC,CAOE,UAAAC,CAAWhE,GAYT,OAVE3vB,KAAKynB,YAAYsJ,YADG,kBAAXpB,EACsBA,GAEC3vB,KAAKynB,YAAYsJ,YAInD/wB,KAAKa,KAAK,cAAe,CACvBkwB,YAAa/wB,KAAKynB,YAAYsJ,cAGzB/wB,KAAKynB,YAAYsJ,WAC5B,CAOE,OAAAvB,CAAQhH,GACN,MAAK,CAAC,QAAS,OAAQ,iBAAiBjf,SAASif,IAMjDxoB,KAAKixB,eAAezI,IAEb,IAPLznB,QAAQG,MAAM,wBAAwBsnB,MAC/B,EAOb,CAME,WAAAoL,GACE,MAAO,CACLpL,KAAMxoB,KAAKgO,QAAQwa,KACnB7Y,SAAU3P,KAAKynB,YAAYmJ,eAC3BllB,QAAS1L,KAAKynB,YAAYoJ,cAC1BjhB,SAAU5P,KAAKgO,QAAQ4B,SACvBmhB,YAAa/wB,KAAKynB,YAAYsJ,YAEpC,ECngCO,MAAM8C,UAAoBxM,EAK/B,WAAAtnB,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAGNhO,KAAKgO,QAAU3H,OAAOwhB,OAAO,CAC3BW,KAAM,QACN5Y,UAAU,EACVkkB,mBAAmB,EACnBC,yBAA0B,EAC1B7K,YAAa7iB,OAAOwhB,OAAO,CACzBrC,KAAM,GACNsF,MAAO,UACPC,aAAc,EACdF,aAAc,QACdmJ,eAAe,GACdh0B,KAAKsnB,QAAQ0B,SAASG,oBAAsB,CAAA,GAC/CJ,WAAY/oB,KAAKsnB,QAAQ0B,SAASC,kBAElCgL,kBAAmB,CACjBnJ,MAAO,UACPE,MAAO,EACPkJ,QAAS,GACT5D,UAAW,CAAC,EAAG,IAEjB6D,cAAen0B,KAAKsnB,QAAQ0B,SAAS4B,qBAErCwJ,qBAAsB,CACpB9K,UAAW,0BACXuB,aAAc,UACdE,aAAc,EACduF,UAAW,CAAC,EAAG,IAEjB+D,aAAc,CACZnvB,KAAM,SACNsgB,KAAM,EACNsF,MAAO,UACPC,aAAc,EACdF,aAAc,QAEdmJ,eAAe,GAGjBM,mBAAoB,CAClBpvB,KAAM,SACNsgB,KAAM,GACNsF,MAAO,UACPC,aAAc,EACdF,aAAc,QAEdmJ,eAAe,IAEhBhmB,GAGHhO,KAAKynB,YAAc,CACjB8M,cAAe,KACfnH,SAAU,GACVzD,cAAe,KACf6K,YAAY,EACZC,kBAAmB,MAIrBz0B,KAAK+pB,gBAAkB/pB,KAAK+pB,gBAAgBC,KAAKhqB,MACjDA,KAAKiqB,oBAAsBjqB,KAAKiqB,oBAAoBD,KAAKhqB,MACzDA,KAAKkqB,sBAAwBlqB,KAAKkqB,sBAAsBF,KAAKhqB,MAC7DA,KAAKmqB,qBAAuBnqB,KAAKmqB,qBAAqBH,KAAKhqB,MAC3DA,KAAKoqB,eAAiBpqB,KAAKoqB,eAAeJ,KAAKhqB,MAC/CA,KAAK00B,oBAAsB10B,KAAK00B,oBAAoB1K,KAAKhqB,MACzDA,KAAK20B,kBAAoB30B,KAAK20B,kBAAkB3K,KAAKhqB,KACzD,CAOE,oBAAA0nB,GAEF,CAOE,SAAAI,GACE/mB,QAAQC,IAAI,6BAA6BhB,KAAKgO,QAAQwa,gCAAgCxoB,KAAKgO,QAAQ8lB,qBAG9F9zB,KAAKynB,aAA2C,iBAArBznB,KAAKynB,cACnCznB,KAAKynB,YAAc,CACjB8M,cAAe,KACfnH,SAAU,GACVzD,cAAe,KACf6K,YAAY,EACZC,kBAAmB,OAIvB,IAEEz0B,KAAK2mB,aAAalmB,iBAAiB,QAAST,KAAK+pB,iBACjD/pB,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAKiqB,qBACrDjqB,KAAK2mB,aAAalmB,iBAAiB,WAAYT,KAAKkqB,uBACpDlqB,KAAK2mB,aAAalmB,iBAAiB,cAAeT,KAAKmqB,sBACvDnqB,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAK00B,qBACrD10B,KAAK2mB,aAAalmB,iBAAiB,UAAWT,KAAK20B,mBAGnDrK,SAAS7pB,iBAAiB,UAAWT,KAAKoqB,gBAG1CpqB,KAAK40B,mBAGL50B,KAAKa,KAAK,YAAa,CACrB2nB,KAAMxoB,KAAKgO,QAAQwa,KACnBsL,kBAAmB9zB,KAAKgO,QAAQ8lB,mBAEnC,CAAC,MAAO5yB,GACPH,QAAQG,MAAM,gCAAiCA,EACrD,CACA,CAOE,WAAA8mB,GAEEhoB,KAAK2mB,aAAavlB,oBAAoB,QAASpB,KAAK+pB,iBACpD/pB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAKiqB,qBACxDjqB,KAAK2mB,aAAavlB,oBAAoB,WAAYpB,KAAKkqB,uBACvDlqB,KAAK2mB,aAAavlB,oBAAoB,cAAepB,KAAKmqB,sBAC1DnqB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAK00B,qBACxD10B,KAAK2mB,aAAavlB,oBAAoB,UAAWpB,KAAK20B,mBAGtDrK,SAASlpB,oBAAoB,UAAWpB,KAAKoqB,gBAG7CpqB,KAAK60B,sBAGL70B,KAAKynB,YAAc,CACjB8M,cAAe,KACfnH,SAAU,GACVzD,cAAe,KACf6K,YAAY,EACZC,kBAAmB,KAEzB,CAOE,MAAAvM,GAEOloB,KAAKynB,YAUJznB,KAAKynB,YAAY8M,eACnBv0B,KAAK80B,mBAVP90B,KAAKynB,YAAc,CACjB8M,cAAe,KACfnH,SAAU,GACVzD,cAAe,KACf6K,YAAY,EACZC,kBAAmB,MAUvBz0B,KAAK40B,kBACT,CAME,gBAAAA,GAKE,OAHA50B,KAAK60B,sBAGG70B,KAAKgO,QAAQwa,MACrB,IAAK,QAEH,MAEF,IAAK,OAEHxoB,KAAKynB,YAAY8M,cAAgB,IAAIpW,EAAY,GAAI,CACnDzE,GAAI,WAAWC,KAAKC,QACpBM,WAAY,CACVhV,KAAM,UACN6vB,YAAa,OACbpK,WAAW,EACXqK,WAAW,GAEb/a,MAAOja,KAAKgO,QAAQimB,mBAAqBj0B,KAAKgO,QAAQ+a,aAExD,MAEF,IAAK,UACH,IAGE,MAAMkM,EAAgB,CACpB,IAAI5xB,EAAW,EAAG,EAAG,GACrB,IAAIA,EAAW,EAAG,KAAU,GAC5B,IAAIA,EAAW,KAAU,EAAG,GAC5B,IAAIA,EAAW,EAAG,EAAG,IAGvBrD,KAAKynB,YAAY8M,cAAgB,IAAIhT,EAAe0T,EAAe,CACjEvb,GAAI,WAAWC,KAAKC,QACpBM,WAAY,CACVhV,KAAM,UACN6vB,YAAa,UACbpK,WAAW,EACXqK,WAAW,GAEb/a,MAAOja,KAAKgO,QAAQomB,sBAAwBp0B,KAAKgO,QAAQmmB,eAE5D,CAAC,MAAOjzB,GACPH,QAAQG,MAAM,kCAAmCA,GAEjDlB,KAAKynB,YAAY8M,cAAgB,IAAIpW,EAAY,GAAI,CACnDzE,GAAI,WAAWC,KAAKC,QACpBM,WAAY,CACVhV,KAAM,UACN6vB,YAAa,OACbpK,WAAW,EACXqK,WAAW,GAEb/a,MAAOja,KAAKgO,QAAQimB,mBAAqBj0B,KAAKgO,QAAQ+a,aAExDhoB,QAAQ2D,KAAK,sCACrB,CACM,MAEF,IAAK,WAEH1E,KAAKynB,YAAY8M,cAAgB,IAAIpW,EAAY,GAAI,CACnDzE,GAAI,WAAWC,KAAKC,QACpBM,WAAY,CACVhV,KAAM,UACN6vB,YAAa,WACbpK,WAAW,EACXqK,WAAW,GAEb/a,MAAOja,KAAKgO,QAAQimB,mBAAqBj0B,KAAKgO,QAAQ+a,aAMtD/oB,KAAKynB,YAAY8M,eACnBv0B,KAAKsnB,QAAQ2D,gBAAgBtG,WAAW3kB,KAAKynB,YAAY8M,eAI3Dv0B,KAAKynB,YAAY2F,SAAW,GAC5BptB,KAAKynB,YAAYgN,kBAAoB,IACzC,CAME,mBAAAI,GAEO70B,KAAKynB,aAYNznB,KAAKynB,YAAY8M,gBACnBv0B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAY8M,eAC5Dv0B,KAAKynB,YAAY8M,cAAgB,MAI/B5X,MAAMC,QAAQ5c,KAAKynB,YAAY2F,WACjCptB,KAAKynB,YAAY2F,SAASnsB,SAAQi0B,IAChCl1B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcqQ,EAAO,IAIpDl1B,KAAKynB,YAAY2F,SAAW,IAG5BptB,KAAKynB,YAAY2F,SAAW,IA1B5BptB,KAAKynB,YAAc,CACjB8M,cAAe,KACfnH,SAAU,GACVzD,cAAe,KACf6K,YAAY,EACZC,kBAAmB,KAuB3B,CAOE,eAAA1K,CAAgB3pB,GAcd,GAZAW,QAAQC,IAAI,qCACZD,QAAQC,IAAI,yCAAyChB,KAAKgO,QAAQwa,aAClEznB,QAAQC,IAAI,sBAAuB,CACjCkE,KAAM9E,EAAM8E,KACZiwB,gBAAiB/0B,EAAMwC,WACvBwyB,YAAah1B,EAAMi1B,OACnBC,mBAAoBl1B,EAAMqrB,cAC1B8J,WAAYn1B,EAAMo1B,MAClBA,MAAOp1B,EAAMo1B,MAAQ,IAAIp1B,EAAMo1B,MAAM,OAAOp1B,EAAMo1B,MAAM,MAAQ,QAIxC,aAAtBx1B,KAAKgO,QAAQwa,KAEf,YADAznB,QAAQC,IAAI,mCAKd,IAAI4B,EAGJ,GAAI5C,KAAKsnB,QAAQmO,iBAAmBz1B,KAAKsnB,QAAQmO,gBAAgBC,eAAgB,CAG/E9yB,EADa5C,KAAKsnB,QAAQmO,gBAAgBC,eACxB9yB,UACxB,MAAW,GAAIxC,EAAMwC,WACfA,EAAaxC,EAAMwC,eACd,KAAIxC,EAAMqrB,gBAAiBrrB,EAAMi1B,OAStC,YADAt0B,QAAQG,MAAM,oDAAqDd,GANnEwC,EAAa,CACXG,IAAK3C,EAAMi1B,OAAOtyB,MAClBL,IAAKtC,EAAMi1B,OAAO3yB,MAClBO,UAAW,EAKnB,CAEI,IAEE,OAAQjD,KAAKgO,QAAQwa,MACrB,IAAK,QAEHxoB,KAAK21B,aAAa/yB,GAClB,MAEF,IAAK,OACL,IAAK,UAEH5C,KAAK41B,WAAWhzB,GAInB,CAAC,MAAO1B,GACPH,QAAQG,MAAM,iCAAiClB,KAAKgO,QAAQwa,aAActnB,GAI1E20B,YAAW,KACT71B,KAAK40B,kBAAkB,GACtB,GACT,CAEA,CAOE,mBAAA3K,CAAoB7pB,GAClB,IACE,IAAIwC,EAGJ,GAAI5C,KAAKsnB,QAAQmO,iBAAmBz1B,KAAKsnB,QAAQmO,gBAAgBC,eAAgB,CAG/E9yB,EADa5C,KAAKsnB,QAAQmO,gBAAgBC,eACxB9yB,UAC1B,MAAa,GAAIxC,EAAMwC,sBAAsBS,EAErCT,EAAaxC,EAAMwC,gBAEd,GAAIxC,EAAMwC,YAA8C,iBAAzBxC,EAAMwC,WAAWG,KAAoD,iBAAzB3C,EAAMwC,WAAWF,IAEjGE,EAAa,IAAIS,EACfjD,EAAMwC,WAAWG,IACjB3C,EAAMwC,WAAWF,SACc+E,IAA/BrH,EAAMwC,WAAWK,UAA0B7C,EAAMwC,WAAWK,UAAY,QAGrE,GAAI7C,EAAMi1B,QAAsC,mBAArBj1B,EAAMi1B,OAAOtyB,KAAkD,mBAArB3C,EAAMi1B,OAAO3yB,IAEvFE,EAAa,IAAIS,EACfjD,EAAMi1B,OAAOtyB,MACb3C,EAAMi1B,OAAO3yB,MACb,OAGG,CAEL,MAAMikB,EAAe3mB,KAAK2mB,aAC1B,GAAIvmB,EAAMqrB,eAAiB9E,GAA+D,mBAAxCA,EAAamP,uBAAuC,CAEpG,MAAMN,EAAQ,CACZrtB,EAAG/H,EAAMqrB,cAAcsK,QACvB3tB,EAAGhI,EAAMqrB,cAAcuK,SAEzBpzB,EAAa+jB,EAAamP,uBAAuBN,EAC3D,CACA,CAGM,IAAK5yB,GAAwC,iBAAnBA,EAAWG,KAA8C,iBAAnBH,EAAWF,IAEzE,YADA3B,QAAQG,MAAM,4DAKhBlB,KAAKynB,YAAYkC,cAAgB/mB,EAGP,SAAtB5C,KAAKgO,QAAQwa,MAAyC,YAAtBxoB,KAAKgO,QAAQwa,MAC/CznB,QAAQk1B,MAAM,mBAAmBrzB,EAAWG,IAAIC,QAAQ,OAAOJ,EAAWF,IAAIM,QAAQ,MAI9D,aAAtBhD,KAAKgO,QAAQwa,MAAuBxoB,KAAKynB,YAAY+M,YACvDx0B,KAAKk2B,uBAAuBtzB,IAIH,SAAtB5C,KAAKgO,QAAQwa,MAAyC,YAAtBxoB,KAAKgO,QAAQwa,OAC9CxoB,KAAKynB,YAAY8M,eACjBv0B,KAAKynB,YAAY2F,SAASpgB,OAAS,GAErChN,KAAKm2B,gBAER,CAAC,MAAOj1B,GACPH,QAAQG,MAAM,mCAAoCA,EACxD,CACA,CAOE,qBAAAgpB,CAAsB9pB,GASpB,IAAIwC,EACJ,GARIxC,EAAMqrB,eAA+D,mBAAvCrrB,EAAMqrB,cAAcC,gBACpDtrB,EAAMqrB,cAAcC,iBAGtB3qB,QAAQC,IAAI,4BAA4BhB,KAAKgO,QAAQwa,gCAAgCxoB,KAAKgO,QAAQ8lB,qBAI9F9zB,KAAKsnB,QAAQmO,iBAAmBz1B,KAAKsnB,QAAQmO,gBAAgBC,eAAgB,CAG/E9yB,EADa5C,KAAKsnB,QAAQmO,gBAAgBC,eACxB9yB,WAClB7B,QAAQC,IAAI,6CAA8C4B,EAChE,MAAexC,EAAMwC,aACfA,EAAaxC,EAAMwC,aAIjBA,GAAqC,SAAtB5C,KAAKgO,QAAQwa,MAAyC,YAAtBxoB,KAAKgO,QAAQwa,OAC9DznB,QAAQC,IAAI,gDACZhB,KAAK41B,WAAWhzB,IAIS,SAAtB5C,KAAKgO,QAAQwa,MAAmBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC9C,YAAtBhN,KAAKgO,QAAQwa,MAAsBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAE1EjM,QAAQC,IAAI,cAAchB,KAAKgO,QAAQwa,aAAaxoB,KAAKynB,YAAY2F,SAASpgB,mBAG9EhN,KAAK80B,oBAEL/zB,QAAQC,IAAI,mCAAmChB,KAAKgO,QAAQwa,eAElE,CAOE,oBAAA2B,CAAqB/pB,GAEfA,EAAMqrB,eAA+D,mBAAvCrrB,EAAMqrB,cAAcC,gBACpDtrB,EAAMqrB,cAAcC,iBAGtB3qB,QAAQC,IAAI,2BAA2BhB,KAAKgO,QAAQwa,gCAAgCxoB,KAAKgO,QAAQ8lB,qBAGtE,SAAtB9zB,KAAKgO,QAAQwa,MAAmBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC9C,YAAtBhN,KAAKgO,QAAQwa,MAAsBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAG1EjM,QAAQC,IAAI,cAAchB,KAAKgO,QAAQwa,aAAaxoB,KAAKynB,YAAY2F,SAASpgB,mCAGnD,SAAtBhN,KAAKgO,QAAQwa,MAAmBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC9C,YAAtBhN,KAAKgO,QAAQwa,MAAsBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,EAC1EhN,KAAK80B,oBAGL/zB,QAAQC,IAAI,mCAAmChB,KAAKgO,QAAQwa,2BAC5DxoB,KAAK40B,sBAIP7zB,QAAQC,IAAI,sCAAsChB,KAAKgO,QAAQwa,gBAC/DxoB,KAAK40B,mBAEX,CAOE,mBAAAF,CAAoBt0B,GAElB,GAA0B,aAAtBJ,KAAKgO,QAAQwa,MACbpoB,EAAMqrB,eACgC,iBAA/BrrB,EAAMqrB,cAAc2K,QACI,IAA/Bh2B,EAAMqrB,cAAc2K,OAAc,CAIpC,IAAIxzB,EACJ,GAJA5C,KAAKynB,YAAY+M,YAAa,EAI1Bx0B,KAAKsnB,QAAQmO,iBAAmBz1B,KAAKsnB,QAAQmO,gBAAgBC,eAAgB,CAG/E9yB,EADa5C,KAAKsnB,QAAQmO,gBAAgBC,eACxB9yB,WAClB7B,QAAQC,IAAI,+CAAgD4B,EACpE,MAAiBxC,EAAMwC,aACfA,EAAaxC,EAAMwC,YAIjBA,GACF5C,KAAKq2B,kBAAkBzzB,EAE/B,CACA,CAOE,iBAAA+xB,CAAkB2B,GAEhB,GAA0B,aAAtBt2B,KAAKgO,QAAQwa,MAAuBxoB,KAAKynB,YAAY+M,aACvDx0B,KAAKynB,YAAY+M,YAAa,EAG1Bx0B,KAAKynB,YAAY8M,eAAe,CACdv0B,KAAKynB,YAAY8M,cAAc5V,iBACnC3R,QAAU,EACxBhN,KAAK80B,mBAGL90B,KAAK40B,kBAEf,CAEA,CAOE,cAAAxK,CAAehqB,GASb,GAPkB,WAAdA,EAAMwrB,MACR7qB,QAAQC,IAAI,iDAEZhB,KAAK40B,oBAIW,UAAdx0B,EAAMwrB,IAAiB,CAIzB,GAHA7qB,QAAQC,IAAI,wBAAwBhB,KAAKgO,QAAQwa,gCAAgCxoB,KAAKgO,QAAQ8lB,sBAGnE,SAAtB9zB,KAAKgO,QAAQwa,MAAyC,YAAtBxoB,KAAKgO,QAAQwa,OAC9CxoB,KAAKynB,YAAY2F,SAASpgB,OAAS,EAAG,CAGxC,IAAIupB,EAAkBv2B,KAAKynB,YAAYkC,cACvC,GAAI3pB,KAAKsnB,QAAQmO,iBAAmBz1B,KAAKsnB,QAAQmO,gBAAgBC,eAAgB,CAG/Ea,EADav2B,KAAKsnB,QAAQmO,gBAAgBC,eACnB9yB,WACvB7B,QAAQC,IAAI,yDAA0Du1B,EAChF,CAEYA,IACFx1B,QAAQC,IAAI,2CACZhB,KAAK41B,WAAWW,GAE1B,CAGiC,SAAtBv2B,KAAKgO,QAAQwa,MAAmBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC9C,YAAtBhN,KAAKgO,QAAQwa,MAAsBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC1EjM,QAAQC,IAAI,cAAchB,KAAKgO,QAAQwa,aAAaxoB,KAAKynB,YAAY2F,SAASpgB,iCAC9EhN,KAAK80B,oBAEL/zB,QAAQC,IAAI,mCAAmChB,KAAKgO,QAAQwa,eAEpE,CAGsB,cAAdpoB,EAAMwrB,KAAqC,WAAdxrB,EAAMwrB,MACrC7qB,QAAQC,IAAI,sDAEZhB,KAAKw2B,oBAEX,CAOE,YAAAb,CAAa/yB,GACX,IAGE,IAAI6zB,EAGJ,GAAI7zB,aAAsBS,EACxBozB,EAAa7zB,MACR,KAAIA,GAAwC,iBAAnBA,EAAWG,KAA8C,iBAAnBH,EAAWF,IAS/E,MADA3B,QAAQG,MAAM,+BAAgC0B,GACxC,IAAInB,MAAM,sBAPhBg1B,EAAa,IAAIpzB,EACfT,EAAWG,IACXH,EAAWF,SACc+E,IAAzB7E,EAAWK,UAA0BL,EAAWK,UAAY,EAKtE,CAGM,MAAMyzB,EAAa,IACd12B,KAAKgO,QAAQkb,YAGhB8K,eAAe,GAIX2C,EAAU,SAAShd,KAAKC,QAExBkS,EAAe,IAAIrP,EAAaga,EAAY,CAChD/c,GAAIid,EACJzc,WAAY,CACVhV,KAAM,UACN6vB,YAAa,QACbpK,WAAW,GAEb1Q,MAAOyc,IAmCT,OA/BA31B,QAAQC,IAAI,wCACZD,QAAQC,IAAI,0BAA0B21B,KACtC51B,QAAQC,IAAI,wBAAwBy1B,EAAW1zB,IAAIC,QAAQ,OAAOyzB,EAAW/zB,IAAIM,QAAQ,MACzFjC,QAAQC,IAAI,gBAAgB41B,KAAKC,UAAUH,MAC3C31B,QAAQC,IAAI,wCAGRhB,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmBF,GAIlC9rB,KAAKsnB,QAAQ5C,SAASC,WAAWmH,GAGjC9rB,KAAKa,KAAK,eAAgBirB,GAGtB9rB,KAAKgO,QAAQ8lB,kBACf/yB,QAAQC,IAAI,iFAGZD,QAAQC,IAAI,yDAGZ60B,YAAW,KACT90B,QAAQC,IAAI,mDACZhB,KAAKsnB,QAAQwP,sBAAsB,GAClC,KAGEhL,CACR,CAAC,MAAO5qB,GAIP,OAHAH,QAAQG,MAAM,gCAAiCA,GAGxC,IACb,CACA,CAOE,UAAA00B,CAAWhzB,GACT,IACE,IAAK5C,KAAKynB,YAAY8M,gBACpBxzB,QAAQC,IAAI,qDAEZhB,KAAK40B,oBACA50B,KAAKynB,YAAY8M,eAEpB,YADAxzB,QAAQG,MAAM,4CAMlB,IAAIu1B,EAGJ,GAAI7zB,aAAsBS,EACxBozB,EAAa7zB,MACR,KAAIA,GAAwC,iBAAnBA,EAAWG,KAA8C,iBAAnBH,EAAWF,IAS/E,MADA3B,QAAQG,MAAM,+BAAgC0B,GACxC,IAAInB,MAAM,sBAPhBg1B,EAAa,IAAIpzB,EACfT,EAAWG,IACXH,EAAWF,SACc+E,IAAzB7E,EAAWK,UAA0BL,EAAWK,UAAY,EAKtE,CAEMlC,QAAQC,IAAI,oBAAoBy1B,EAAW1zB,QAAQ0zB,EAAW/zB,UAAU1C,KAAKgO,QAAQwa,gBAGrF,MAAMuO,EAAsB,IACvB/2B,KAAKgO,QAAQqmB,aAChB7O,KAAMxlB,KAAKgO,QAAQqmB,aAAa7O,MAAQ,EACxCsF,MAAO9qB,KAAKgO,QAAQqmB,aAAavJ,OAAS,UAC1CC,aAAc/qB,KAAKgO,QAAQqmB,aAAatJ,cAAgB,EACxDF,aAAc7qB,KAAKgO,QAAQqmB,aAAaxJ,cAAgB,SAIpDmM,EAAgB,IAAIva,EAAaga,EAAY,CACjD/c,GAAI,UAAUC,KAAKC,SAAS5Z,KAAKynB,YAAY2F,SAASpgB,SACtDkN,WAAY,CACVhV,KAAM,SACN+xB,UAAWj3B,KAAKynB,YAAY8M,cAAc7a,GAC1Cwd,YAAal3B,KAAKynB,YAAY2F,SAASpgB,OACvC2d,WAAW,GAEb1Q,MAAO8c,IAaT,GATI/2B,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmBgL,GAIlCh3B,KAAKsnB,QAAQ2D,gBAAgBtG,WAAWqS,GACxCh3B,KAAKynB,YAAY2F,SAAS9sB,KAAK02B,GAGL,SAAtBh3B,KAAKgO,QAAQwa,KAAiB,CAChC,MAAMtc,EAAclM,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBACzD9b,QAAQC,IAAI,iCAAiCkL,EAAYc,mBACzDhN,KAAKynB,YAAY8M,cAAc3V,eAAe1S,GAG9ClM,KAAKynB,YAAY8M,cAAcra,WAAWid,WAAaxd,KAAKC,MAG5D5Z,KAAKsnB,QAAQ2D,gBAAgB7D,cAAcpnB,KAAKynB,YAAY8M,cAE7D,MAAM,GAA0B,YAAtBv0B,KAAKgO,QAAQwa,KAAoB,CAC1C,MAAMtc,EAAclM,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBACzD9b,QAAQC,IAAI,oCAAoCkL,EAAYc,mBAE5D,IAEyD,mBAA5ChN,KAAKynB,YAAY8M,cAAcnS,SACxCpiB,KAAKynB,YAAY8M,cAAcnS,SAAS,CAAClW,IAGuB,mBAAlDlM,KAAKynB,YAAY8M,cAAc3V,gBAC7C7d,QAAQC,IAAI,8CACZhB,KAAKynB,YAAY8M,cAAc3V,eAAe1S,IAG9CnL,QAAQG,MAAM,kEAEjB,CAAC,MAAOA,GACPH,QAAQG,MAAM,sCAAuCA,EAC/D,CAGQlB,KAAKynB,YAAY8M,cAAcra,WAAWid,WAAaxd,KAAKC,MAG5D5Z,KAAKsnB,QAAQ2D,gBAAgB7D,cAAcpnB,KAAKynB,YAAY8M,cACpE,CAGMv0B,KAAKm2B,iBAGLn2B,KAAKa,KAAK,cAAe,CACvBua,QAASpb,KAAKynB,YAAY8M,cAC1B3xB,WAAY6zB,EACZS,YAAal3B,KAAKynB,YAAY2F,SAASpgB,OAAS,IAIlD6oB,YAAW,KACT,MAAMuB,EAAsBp3B,KAAKsnB,QAAQ2D,gBAAgB1F,kBACzDxkB,QAAQC,IAAI,+CAA+Co2B,KAE3D,MAAMC,EAAer3B,KAAKsnB,QAAQ2D,gBAAgB7F,kBAAkB,QAC9DkS,EAAgBt3B,KAAKsnB,QAAQ2D,gBAAgB7F,kBAAkB,SACrErkB,QAAQC,IAAI,qCAAqCq2B,EAAarqB,mBAAmBsqB,EAActqB,SAAS,GACvG,GAEJ,CAAC,MAAO9L,GACPH,QAAQG,MAAM,uBAAwBA,GAGtCH,QAAQC,IAAI,mDACZ60B,YAAW,KACT71B,KAAK40B,kBAAkB,GACtB,GACT,CACA,CAOE,iBAAAyB,CAAkBzzB,GAChB,IAAK5C,KAAKynB,YAAY8M,cACpB,OAIF,GAAIv0B,KAAKynB,YAAYgN,kBAAmB,CAOtC,GANiBz0B,KAAKunB,eAAe1Z,kBACnC7N,KAAKynB,YAAYgN,kBACjB7xB,GAIa5C,KAAKgO,QAAQ+lB,yBAC1B,MAER,CAGI,IAAI0C,EACJ,GAAI7zB,aAAsBS,EACxBozB,EAAa7zB,MACR,KAAIA,GAAwC,iBAAnBA,EAAWG,KAA8C,iBAAnBH,EAAWF,IAQ/E,YADA3B,QAAQG,MAAM,2CAA4C0B,GAN1D6zB,EAAa,IAAIpzB,EACfT,EAAWG,IACXH,EAAWF,SACc+E,IAAzB7E,EAAWK,UAA0BL,EAAWK,UAAY,EAKpE,CAGI,MAAMiJ,EAAclM,KAAKynB,YAAY8M,cAAc5V,iBACnDzS,EAAY5L,KAAKm2B,GACjBz2B,KAAKynB,YAAY8M,cAAc3V,eAAe1S,GAG9ClM,KAAKynB,YAAYgN,kBAAoBgC,EAGjCz2B,KAAKgO,QAAQ4B,UAAY1D,EAAYc,OAAS,GAAM,GACtDhN,KAAKsnB,QAAQ0E,mBAAmBhsB,KAAKynB,YAAY8M,cAEvD,CAOE,sBAAA2B,CAAuBtzB,GAErB,IAAI20B,EAAkB30B,EACtB,GAAI5C,KAAKsnB,QAAQmO,iBAAmBz1B,KAAKsnB,QAAQmO,gBAAgBC,eAAgB,CAG/E6B,EADav3B,KAAKsnB,QAAQmO,gBAAgBC,eACnB9yB,UAC7B,CAGI5C,KAAKq2B,kBAAkBkB,EAC3B,CAQE,cAAApB,GACE,IAAKn2B,KAAKynB,YAAY8M,gBAAkBv0B,KAAKynB,YAAYkC,cACvD,OAIF,MAAMyD,EAAWptB,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBAGhD2a,EAAkBx3B,KAAKynB,YAAYkC,cAGzC,GAA0B,SAAtB3pB,KAAKgO,QAAQwa,MAAmB4E,EAASpgB,OAAS,EAAG,CAEvD,MAAMimB,EAAgB,IAAI7F,EAAUoK,GAEpCz2B,QAAQC,IAAI,8BAA8BiyB,EAAcjmB,8BAA8BwqB,EAAgBz0B,QAAQy0B,EAAgB90B,OAG9H1C,KAAKynB,YAAY8M,cAAc3V,eAAeqU,GAI9CjzB,KAAKynB,YAAY8M,cAAcra,WAAWud,kBAAoB9d,KAAKC,MAGnE5Z,KAAKsnB,QAAQ2D,gBAAgB7D,cAAcpnB,KAAKynB,YAAY8M,cAC7D,MAEI,GAA0B,YAAtBv0B,KAAKgO,QAAQwa,MAAsB4E,EAASpgB,OAAS,EAAG,CAE/D,IAAIimB,EAAgB,IAAI7F,EAAUoK,GAI9BpK,EAASpgB,OAAS,IACpBimB,EAAgB,IAAIA,EAAe7F,EAAS,KAG9CrsB,QAAQC,IAAI,iCAAiCiyB,EAAcjmB,iDAAiDwqB,EAAgBz0B,QAAQy0B,EAAgB90B,OAGpJ1C,KAAKynB,YAAY8M,cAAcnS,SAAS,CAAC6Q,IAGzCjzB,KAAKynB,YAAY8M,cAAcra,WAAWud,kBAAoB9d,KAAKC,MAGnE5Z,KAAKsnB,QAAQ2D,gBAAgB7D,cAAcpnB,KAAKynB,YAAY8M,cAClE,CACA,CAME,iBAAAiC,GACE,GAAyC,IAArCx2B,KAAKynB,YAAY2F,SAASpgB,OAC5B,OAIF,MAAM0qB,EAAa13B,KAAKynB,YAAY2F,SAASjN,MAI7C,GAHAngB,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc6S,GAGjB,SAAtB13B,KAAKgO,QAAQwa,KAAiB,CAChC,MAAMtc,EAAclM,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBACzD7c,KAAKynB,YAAY8M,cAAc3V,eAAe1S,EAC/C,MAAM,GAA0B,YAAtBlM,KAAKgO,QAAQwa,KAAoB,CAC1C,IAAItc,EAAclM,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBAInD3Q,EAAYc,OAAS,IACvBd,EAAc,IAAIA,EAAaA,EAAY,KAG7ClM,KAAKynB,YAAY8M,cAAcnS,SAAS,CAAClW,GAC/C,CAGIlM,KAAKm2B,iBAGLn2B,KAAKa,KAAK,gBAAiB,CACzBua,QAASpb,KAAKynB,YAAY8M,cAC1BoD,YAAa33B,KAAKynB,YAAY2F,SAASpgB,QAE7C,CAME,gBAAA8nB,GACE,IAAK90B,KAAKynB,YAAY8M,cAEpB,YADAxzB,QAAQC,IAAI,iCAId,IAAI42B,EAEJ,OAAQ53B,KAAKgO,QAAQwa,MACrB,IAAK,OAEH,GAAIxoB,KAAKynB,YAAY2F,SAASpgB,OAAS,EAGrC,OAFAjM,QAAQC,IAAI,yDACZhB,KAAK40B,mBAKP,MAAMnI,EAAkBzsB,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBAC7D9b,QAAQC,IAAI,oCAAoCyrB,EAAgBzf,mBAEhE,IAEEhN,KAAKynB,YAAY8M,cAAcra,WAAWyQ,WAAY,EACtD3qB,KAAKynB,YAAY8M,cAAcra,WAAW8a,WAAY,EACtDh1B,KAAKynB,YAAY8M,cAAc3V,eAAe6N,GAG9CzsB,KAAKynB,YAAY8M,cAActa,MAAQja,KAAKgO,QAAQ+a,WAGpD,MAAMja,EAAa2d,EAAgB,GAC7B1d,EAAY0d,EAAgBA,EAAgBzf,OAAS,GAGrD6qB,EAAW/oB,EAAW/L,IAAIC,QAAQ,GAClC80B,EAAWhpB,EAAWpM,IAAIM,QAAQ,GAClC+0B,EAAShpB,EAAUhM,IAAIC,QAAQ,GAC/Bg1B,EAASjpB,EAAUrM,IAAIM,QAAQ,GAErChD,KAAKynB,YAAY8M,cAAc5Y,QAAQ,cAAckc,MAAaC,UAAiBC,MAAWC,MAE9FJ,EAAe53B,KAAKynB,YAAY8M,cAGhCv0B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc+S,EAC5C,CAAC,MAAO12B,GAGP,OAFAH,QAAQG,MAAM,iCAAkCA,QAChDlB,KAAK40B,kBAEb,CACM,MAEF,IAAK,UAEH,GAAI50B,KAAKynB,YAAY2F,SAASpgB,OAAS,EAGrC,OAFAjM,QAAQC,IAAI,4DACZhB,KAAK40B,mBAKP,IAAIzI,EAAqBnsB,KAAKynB,YAAY2F,SAASrb,KAAI+G,GAAKA,EAAE+D,kBAG1DsP,EAAmBnf,OAAS,IAE9Bmf,EAAqB,IAAIA,EAAoBA,EAAmB,KAGlEprB,QAAQC,IAAI,uCAAuCmrB,EAAmBnf,8CAEtE,IAEE4qB,EAAe,IAAIrW,EAAe4K,EAAoB,CACpDzS,GAAI,WAAWC,KAAKC,QACpBM,WAAY,CACVhV,KAAM,UACN6vB,YAAa,UACbpK,WAAW,EACXqK,WAAW,GAEb/a,MAAOja,KAAKgO,QAAQmmB,gBAItB,IACE,MAAM1jB,EAASmnB,EAAa/c,YAC5B,GAAIpK,EAAQ,CACV,MAAMwnB,EAAYxnB,EAAO1N,IAAIC,QAAQ,GAC/Bk1B,EAAYznB,EAAO/N,IAAIM,QAAQ,GACrC40B,EAAajc,QAAQ,eAAesc,MAAcC,KAC9D,MACYN,EAAajc,QAAQ,gBAAgBwQ,EAAmBnf,kBAE3D,CAAC,MAAgD9L,GAEhD02B,EAAajc,QAAQ,gBAAgBwQ,EAAmBnf,kBAClE,CAGQhN,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKynB,YAAY8M,eAG5Dv0B,KAAKynB,YAAY2F,SAASnsB,SAAQi0B,IAChCl1B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcqQ,EAAO,GAErD,CAAC,MAAOh0B,GAGP,OAFAH,QAAQG,MAAM,oCAAqCA,QACnDlB,KAAK40B,kBAEb,CACM,MAEF,IAAK,WAEH,MAAMuD,EAAiBn4B,KAAKynB,YAAY8M,cAAc5V,iBACtD,GAAIwZ,EAAenrB,OAAS,EAG1B,OAFAjM,QAAQC,IAAI,gEACZhB,KAAK40B,mBAKP7zB,QAAQC,IAAI,wCAAwCm3B,EAAenrB,mBAEnE,IAEEhN,KAAKynB,YAAY8M,cAAcra,WAAWyQ,WAAY,EACtD3qB,KAAKynB,YAAY8M,cAAcra,WAAW8a,WAAY,EAGtDh1B,KAAKynB,YAAY8M,cAActa,MAAQja,KAAKgO,QAAQ+a,WAGpD,MAAMja,EAAaqpB,EAAe,GAC5BppB,EAAYopB,EAAeA,EAAenrB,OAAS,GAEnD6qB,EAAW/oB,EAAW/L,IAAIC,QAAQ,GAClC80B,EAAWhpB,EAAWpM,IAAIM,QAAQ,GAClC+0B,EAAShpB,EAAUhM,IAAIC,QAAQ,GAC/Bg1B,EAASjpB,EAAUrM,IAAIM,QAAQ,GAErChD,KAAKynB,YAAY8M,cAAc5Y,QAAQ,uBAAuBkc,MAAaC,UAAiBC,MAAWC,MAEvGJ,EAAe53B,KAAKynB,YAAY8M,cAGhCv0B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc+S,EAC5C,CAAC,MAAO12B,GAGP,OAFAH,QAAQG,MAAM,qCAAsCA,QACpDlB,KAAK40B,kBAEb,EAII,GAAIgD,EAAc,CAEZ53B,KAAKgO,QAAQ4B,UACf5P,KAAKsnB,QAAQ0E,mBAAmB4L,GAIlCA,EAAa1d,WAAWyQ,WAAY,EAGpC,MAAM1D,EAAoC,aAAtBjnB,KAAKgO,QAAQwa,KAAsB,OAASxoB,KAAKgO,QAAQwa,KAC7EoP,EAAale,GAAK,GAAGuN,KAAetN,KAAKC,QAGzC7Y,QAAQC,IAAI,oBAAoBhB,KAAKgO,QAAQwa,sCAAsCoP,EAAale,MAChG3Y,QAAQC,IAAI,mBAAoB,CAC9BkE,KAAM0yB,EAAa1yB,KACnBwU,GAAIke,EAAale,GACjBxN,YAAa0rB,EAAajZ,eAAiBiZ,EAAajZ,iBAAmB,KAC3E5E,KAAM6d,EAAa7d,KACnBG,WAAY0d,EAAa1d,aAG3Bla,KAAKsnB,QAAQ5C,SAASC,WAAWiT,GAGjC/B,YAAW,KACT,MAAMuC,EAAep4B,KAAKsnB,QAAQ5C,SAASa,kBACrC8R,EAAer3B,KAAKsnB,QAAQ5C,SAASU,kBAAkB,QAC7DrkB,QAAQC,IAAI,gCAAgCo3B,qBAAgCf,EAAarqB,SAAS,GACjG,KAGHhN,KAAKa,KAAK,mBAAoB+2B,GAGzB53B,KAAKgO,QAAQ8lB,mBAShB/yB,QAAQC,IAAI,oDAEZ60B,YAAW,KACT71B,KAAK40B,mBACL7zB,QAAQC,IAAI,yCAAyC,GACpD,MAbHD,QAAQC,IAAI,6DAEZ60B,YAAW,KACT90B,QAAQC,IAAI,4EACZhB,KAAKsnB,QAAQwP,sBAAsB,GAClC,IAUX,MACM/1B,QAAQG,MAAM,kCAEdlB,KAAK40B,kBAEX,CAOE,OAAApF,CAAQhH,GACN,MAAK,CAAC,QAAS,OAAQ,UAAW,YAAYjf,SAASif,GAMnDxoB,KAAKgO,QAAQwa,OAASA,EACjBxoB,KAAKq4B,6BAIVr4B,KAAKynB,YAAY8M,gBACQ,SAAtBv0B,KAAKgO,QAAQwa,MAAmBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC9C,YAAtBhN,KAAKgO,QAAQwa,MAAsBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GACjD,aAAtBhN,KAAKgO,QAAQwa,MAAuBxoB,KAAKynB,YAAY8M,cAAc5V,iBAAiB3R,QAAU,EACjGhN,KAAK80B,mBAEL90B,KAAK60B,uBAKT70B,KAAKgO,QAAQwa,KAAOA,EAGpBxoB,KAAK40B,mBAGL50B,KAAKa,KAAK,cAAe,CAAE2nB,UAEpB,IA7BLznB,QAAQG,MAAM,yBAAyBsnB,MAChC,EA6Bb,CAOE,yBAAA6P,GAEE,GAAIr4B,KAAKynB,YAAY8M,cAAe,CAClC,GAA2B,SAAtBv0B,KAAKgO,QAAQwa,MAAmBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GAC9C,YAAtBhN,KAAKgO,QAAQwa,MAAsBxoB,KAAKynB,YAAY2F,SAASpgB,QAAU,GACjD,aAAtBhN,KAAKgO,QAAQwa,MAAuBxoB,KAAKynB,YAAY8M,cAAc5V,iBAAiB3R,QAAU,EAGjG,OAFAjM,QAAQC,IAAI,cAAchB,KAAKgO,QAAQwa,qBAAqBxoB,KAAKynB,YAAY2F,SAASpgB,yCACtFhN,KAAK80B,oBACE,EAEP/zB,QAAQC,IAAI,mCAAmChB,KAAKgO,QAAQwa,gBAE5DxoB,KAAK40B,kBAEb,MAEM50B,KAAK40B,mBAGP,OAAO,CACX,CAOE,oBAAA0D,CAAqB3I,GAQnB,OAPA3vB,KAAKgO,QAAQ8lB,oBAAsBnE,EAGnC3vB,KAAKa,KAAK,2BAA4B,CACpCizB,kBAAmB9zB,KAAKgO,QAAQ8lB,oBAG3B9zB,KAAKgO,QAAQ8lB,iBACxB,CAOE,WAAApE,CAAYC,GAQV,OAPA3vB,KAAKgO,QAAQ4B,WAAa+f,EAG1B3vB,KAAKa,KAAK,kBAAmB,CAC3B+O,SAAU5P,KAAKgO,QAAQ4B,WAGlB5P,KAAKgO,QAAQ4B,QACxB,CAOE,2BAAA2oB,CAA4BxX,GAC1B,OAAIzW,MAAMyW,IAAaA,GAAY,GACjChgB,QAAQG,MAAM,yDACPlB,KAAKgO,QAAQ+lB,2BAGtB/zB,KAAKgO,QAAQ+lB,yBAA2BhT,EAGxC/gB,KAAKa,KAAK,kCAAmC,CAC3CkgB,SAAU/gB,KAAKgO,QAAQ+lB,2BAGlB/zB,KAAKgO,QAAQ+lB,yBACxB,CAME,WAAAH,GACE,MAAO,CACLpL,KAAMxoB,KAAKgO,QAAQwa,KACnB5Y,SAAU5P,KAAKgO,QAAQ4B,SACvBkkB,kBAAmB9zB,KAAKgO,QAAQ8lB,kBAChCC,yBAA0B/zB,KAAKgO,QAAQ+lB,yBAE7C,ECl4CO,MAAMyE,UAAoBnR,EAK/B,WAAAtnB,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAGNhO,KAAKgO,QAAU3H,OAAOwhB,OAAO,CAC3BjY,UAAU,EACV6oB,wBAAyB,GACzBC,qBAAqB,EACrBC,qBAAqB,EACrBC,eAAe,EACfC,sBAAuB,EACvBxE,aAAc,CACZnvB,KAAM,SACNsgB,KAAM,EACNsF,MAAO,UACPC,aAAc,EACdF,aAAc,SAEhBiO,qBAAsB,CACpB5zB,KAAM,SACNsgB,KAAM,GACNsF,MAAO,UACPC,aAAc,EACdF,aAAc,SAEhBkO,sBAAuB,CACrB7zB,KAAM,SACNsgB,KAAM,EACNsF,MAAO,0BACPC,aAAc,EACdF,aAAc,WAEhB9B,WAAY1iB,OAAOwhB,OAAO,CAAA,EAAI7nB,KAAKsnB,QAAQ0B,SAASC,kBAAmB,CACrE+B,MAAO,EACPF,MAAO,YAETqJ,cAAe9tB,OAAOwhB,OAAO,CAAA,EAAI7nB,KAAKsnB,QAAQ0B,SAAS4B,qBAAsB,CAC3EG,aAAc,EACdF,aAAc,aAEf7c,GAGHhO,KAAKynB,YAAc,CACjBgJ,cAAe,KACfuI,gBAAiB,KACjB5L,SAAU,GACV6L,kBAAmB,GACnBC,eAAgB,KAChB1E,YAAY,EACZ2E,kBAAmB,KACnBxP,cAAe,KACfyP,cAAe,OACfC,mBAAmB,EACnBC,gBAAiB,EACjBC,YAAa,IAIfv5B,KAAK+pB,gBAAkB/pB,KAAK+pB,gBAAgBC,KAAKhqB,MACjDA,KAAKiqB,oBAAsBjqB,KAAKiqB,oBAAoBD,KAAKhqB,MACzDA,KAAKkqB,sBAAwBlqB,KAAKkqB,sBAAsBF,KAAKhqB,MAC7DA,KAAKmqB,qBAAuBnqB,KAAKmqB,qBAAqBH,KAAKhqB,MAC3DA,KAAKoqB,eAAiBpqB,KAAKoqB,eAAeJ,KAAKhqB,MAC/CA,KAAK00B,oBAAsB10B,KAAK00B,oBAAoB1K,KAAKhqB,MACzDA,KAAK20B,kBAAoB30B,KAAK20B,kBAAkB3K,KAAKhqB,MACrDA,KAAKgxB,uBAAyBhxB,KAAKgxB,uBAAuBhH,KAAKhqB,KACnE,CAOE,oBAAA0nB,GAEE1nB,KAAKsnB,QAAQnnB,GAAG,kBAAmBH,KAAKgxB,wBAGxChxB,KAAKsnB,QAAQ5C,SAASvkB,GAAG,kBAAkBib,IAErCpb,KAAKynB,YAAYgJ,eACjBzwB,KAAKynB,YAAYgJ,cAAc/W,KAAO0B,EAAQ1B,IAChD1Z,KAAKw5B,uBACb,GAEA,CAOE,SAAA1R,GAEE9nB,KAAK2mB,aAAalmB,iBAAiB,QAAST,KAAK+pB,iBACjD/pB,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAKiqB,qBACrDjqB,KAAK2mB,aAAalmB,iBAAiB,WAAYT,KAAKkqB,uBACpDlqB,KAAK2mB,aAAalmB,iBAAiB,cAAeT,KAAKmqB,sBACvDnqB,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAK00B,qBACrD10B,KAAK2mB,aAAalmB,iBAAiB,UAAWT,KAAK20B,mBAGnDrK,SAAS7pB,iBAAiB,UAAWT,KAAKoqB,gBAG1CpqB,KAAKynB,YAAY2R,cAAgB,OAGjC,MAAMK,EAAmBz5B,KAAKsnB,QAAQzB,sBACN,IAA5B4T,EAAiBzsB,QACnBhN,KAAK05B,qBAAqBD,EAAiB,IAI7Cz5B,KAAKa,KAAK,YAAa,CACrB+O,SAAU5P,KAAKgO,QAAQ4B,SACvB6gB,cAAezwB,KAAKynB,YAAYgJ,eAEtC,CAOE,WAAAzI,GAEEhoB,KAAK2mB,aAAavlB,oBAAoB,QAASpB,KAAK+pB,iBACpD/pB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAKiqB,qBACxDjqB,KAAK2mB,aAAavlB,oBAAoB,WAAYpB,KAAKkqB,uBACvDlqB,KAAK2mB,aAAavlB,oBAAoB,cAAepB,KAAKmqB,sBAC1DnqB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAK00B,qBACxD10B,KAAK2mB,aAAavlB,oBAAoB,UAAWpB,KAAK20B,mBAGtDrK,SAASlpB,oBAAoB,UAAWpB,KAAKoqB,gBAG7CpqB,KAAK25B,mBAGL35B,KAAK45B,uBAGL55B,KAAKynB,YAAYgJ,cAAgB,KACjCzwB,KAAKynB,YAAYuR,gBAAkB,KACnCh5B,KAAKynB,YAAY2R,cAAgB,MACrC,CAOE,MAAAlR,GAEEloB,KAAK25B,mBAGL35B,KAAKynB,YAAY2R,cAAgB,OACjCp5B,KAAKynB,YAAYyR,eAAiB,KAClCl5B,KAAKynB,YAAY+M,YAAa,EAC9Bx0B,KAAKynB,YAAY4R,mBAAoB,EAGjCr5B,KAAKynB,YAAYgJ,eACnBzwB,KAAKw5B,uBAEX,CAOE,eAAAzP,CAAgB3pB,GAEd,GAAIJ,KAAKynB,YAAY+M,WACnB,OAGF,MAAM5xB,EAAaxC,EAAMwC,WACnB8jB,EAAiBtmB,EAAMo1B,MAG7B,GAAKx1B,KAAKynB,YAAYgJ,eAMtB,GAAuC,SAAnCzwB,KAAKynB,YAAY2R,cAA0B,CAE7C,MAAMlE,EAASl1B,KAAK65B,sBAAsBnT,GAC1C,GAAIwO,EAEF,YADAl1B,KAAK85B,cAAc5E,GAKrB,GAAIl1B,KAAKgO,QAAQ0qB,oBAAqB,CACpC,MAAMqB,EAAkB/5B,KAAKg6B,+BAA+BtT,GAC5D,GAAIqT,EAEF,YADA/5B,KAAKi6B,sBAAsBF,EAGrC,CAGM,GAAI/5B,KAAKk6B,qBAAqBt3B,EAAY8jB,GAWxC,OATA1mB,KAAKynB,YAAY2R,cAAgB,OACjCp5B,KAAKynB,YAAY0R,kBAAoBv2B,OAGrC5C,KAAKa,KAAK,qBAAsB,CAC9Bua,QAASpb,KAAKynB,YAAYgJ,cAC1B7tB,WAAYA,IAOhB5C,KAAKm6B,qBACX,OAvCMn6B,KAAKo6B,yBAAyBx3B,EAAY8jB,EAwChD,CAOE,mBAAAuD,CAAoB7pB,GAElBJ,KAAKynB,YAAYkC,cAAgBvpB,EAAMwC,WACvC,MAAM8jB,EAAiBtmB,EAAMo1B,MAG7B,GAAIx1B,KAAKynB,YAAY+M,WACnBx0B,KAAKq6B,YAAYj6B,EAAMwC,WAAY8jB,OADrC,CAMA,GAAI1mB,KAAKynB,YAAYgJ,cAAe,CAElC,MAAMyE,EAASl1B,KAAK65B,sBAAsBnT,GAC1C,GAAIwO,EAIF,OAFAl1B,KAAKs6B,iBAAiBpF,QACtBl1B,KAAK2mB,aAAa4T,UAAU,WAK9B,GAAIv6B,KAAKgO,QAAQ0qB,oBAAqB,CACpC,MAAMqB,EAAkB/5B,KAAKg6B,+BAA+BtT,GAC5D,GAAIqT,EAIF,OAFA/5B,KAAKw6B,0BAA0BT,QAC/B/5B,KAAK2mB,aAAa4T,UAAU,UAGtC,CAGM,GAAIv6B,KAAKk6B,qBAAqB95B,EAAMwC,WAAY8jB,GAE9C,YADA1mB,KAAK2mB,aAAa4T,UAAU,OAGpC,CAGIv6B,KAAK2mB,aAAa4T,UAAU,UAhChC,CAiCA,CAOE,qBAAArQ,CAAsB9pB,GAEhBA,EAAMqrB,eACRrrB,EAAMqrB,cAAcC,gBAI1B,CAOE,oBAAAvB,CAAqB/pB,GAEfA,EAAMqrB,eACRrrB,EAAMqrB,cAAcC,iBAIlB1rB,KAAKynB,YAAYyR,gBAAkBl5B,KAAKgO,QAAQ2qB,oBAClD34B,KAAKy6B,wBAKHz6B,KAAKynB,YAAYgJ,eACjBzwB,KAAKk6B,qBAAqB95B,EAAMwC,WAAYxC,EAAMo1B,OACpDx1B,KAAK25B,mBAKP35B,KAAKm6B,qBACT,CAOE,mBAAAzF,CAAoBt0B,GAElB,GAAmC,IAA/BA,EAAMqrB,cAAc2K,QAKpBp2B,KAAKynB,YAAYgJ,cAAe,CAClC,MAAM/J,EAAiBtmB,EAAMo1B,MACvB5yB,EAAaxC,EAAMwC,WAGnBsyB,EAASl1B,KAAK65B,sBAAsBnT,GAC1C,GAAIwO,EAcF,OAbAl1B,KAAK85B,cAAc5E,GACnBl1B,KAAKynB,YAAY+M,YAAa,EAC9Bx0B,KAAKynB,YAAY0R,kBAAoBv2B,EACrC5C,KAAKynB,YAAY2R,cAAgB,aACjCp5B,KAAKynB,YAAY6R,gBAAkB,OAGnCt5B,KAAKa,KAAK,oBAAqB,CAC7Bua,QAASpb,KAAKynB,YAAYgJ,cAC1ByG,YAAahC,EAAOgC,YACpBt0B,WAAYA,IAOhB,GAAI5C,KAAKgO,QAAQ0qB,oBAAqB,CAEpC,GADwB14B,KAAKg6B,+BAA+BtT,GAG1D,MAEV,CAGU1mB,KAAKk6B,qBAAqBt3B,EAAY8jB,KACxC1mB,KAAKynB,YAAY+M,YAAa,EAC9Bx0B,KAAKynB,YAAY0R,kBAAoBv2B,EACrC5C,KAAKynB,YAAY2R,cAAgB,OACjCp5B,KAAKynB,YAAY6R,gBAAkB,EAGnCt5B,KAAKa,KAAK,qBAAsB,CAC9Bua,QAASpb,KAAKynB,YAAYgJ,cAC1B7tB,WAAYA,IAGtB,CACA,CAOE,iBAAA+xB,CAAkBv0B,GAEZJ,KAAKynB,YAAY+M,aACnBx0B,KAAKynB,YAAY+M,YAAa,EAG1Bx0B,KAAKynB,YAAY6R,gBAAkBt5B,KAAKgO,QAAQ6qB,uBAEX,eAAnC74B,KAAKynB,YAAY2R,eAGyB,SAAnCp5B,KAAKynB,YAAY2R,iBAD1Bp5B,KAAKynB,YAAY0R,kBAAoB,OAOA,eAAnCn5B,KAAKynB,YAAY2R,cAEnBp5B,KAAKa,KAAK,sBAAuB,CAC/Bua,QAASpb,KAAKynB,YAAYgJ,cAC1ByG,YAAal3B,KAAKynB,YAAYyR,eAAehC,YAC7Ct0B,WAAYxC,EAAMwC,aAEwB,SAAnC5C,KAAKynB,YAAY2R,eAE1Bp5B,KAAKa,KAAK,uBAAwB,CAChCua,QAASpb,KAAKynB,YAAYgJ,cAC1B7tB,WAAYxC,EAAMwC,aAKtB5C,KAAKynB,YAAY2R,cAAgB,OACjCp5B,KAAKynB,YAAY0R,kBAAoB,MAG7C,CAOE,cAAA/O,CAAehqB,GAEK,WAAdA,EAAMwrB,MACJ5rB,KAAKynB,YAAY+M,WAEnBx0B,KAAK06B,cACI16B,KAAKynB,YAAYyR,eAE1Bl5B,KAAK26B,kBACI36B,KAAKynB,YAAYgJ,eAE1BzwB,KAAK46B,mBAKU,WAAdx6B,EAAMwrB,KAAkC,cAAdxrB,EAAMwrB,MACjC5rB,KAAKynB,YAAYyR,gBACjBl5B,KAAKgO,QAAQ2qB,qBACf34B,KAAKy6B,wBAIW,UAAdr6B,EAAMwrB,KACJ5rB,KAAKynB,YAAYgJ,eACnBzwB,KAAK25B,kBAGb,CAOE,sBAAA3I,CAAuB5V,GAChBpb,KAAKwnB,WAKNxnB,KAAKynB,YAAYgJ,eACjBzwB,KAAKynB,YAAYgJ,cAAc/W,KAAO0B,EAAQ1B,IAChD1Z,KAAK25B,mBAIP35B,KAAK05B,qBAAqBte,GAC9B,CAOE,oBAAAse,CAAqBte,GAEd,CAAC,QAAS,OAAQ,WAAW7R,SAAS6R,EAAQlW,OAMnDlF,KAAKynB,YAAYuR,gBAAkB,CACjCtf,GAAI0B,EAAQ1B,GACZxU,KAAMkW,EAAQlW,KACdpE,KAAMsa,EAAQpP,aAIhBhM,KAAKynB,YAAYgJ,cAAgBrV,EAGjCpb,KAAK66B,wBAGL76B,KAAKynB,YAAY2R,cAAgB,OACjCp5B,KAAKynB,YAAYyR,eAAiB,KAClCl5B,KAAKynB,YAAY+M,YAAa,EAG9Bx0B,KAAK86B,qBAGL96B,KAAKa,KAAK,iBAAkB,CAC1Bua,QAASA,EACT6L,YAAa7L,EAAQlW,QA5BrBnE,QAAQ2D,KAAK,+BAAgC0W,EAAQlW,KA8B3D,CAME,mBAAAi1B,GACE,IAAKn6B,KAAKynB,YAAYgJ,cACpB,OAIFzwB,KAAK45B,uBAGL55B,KAAK+6B,wBAGL,MAAM3f,EAAUpb,KAAKynB,YAAYgJ,cAGjCzwB,KAAKynB,YAAYgJ,cAAgB,KACjCzwB,KAAKynB,YAAYuR,gBAAkB,KACnCh5B,KAAKynB,YAAYyR,eAAiB,KAClCl5B,KAAKynB,YAAY2R,cAAgB,OAGjCp5B,KAAKa,KAAK,iBAAkB,CAC1Bua,QAASA,GAEf,CAME,kBAAA0f,GACE,GAAK96B,KAAKynB,YAAYgJ,cAQtB,OAHAzwB,KAAKynB,YAAYuT,cAAgBh7B,KAAKynB,YAAYgJ,cAAcpV,WAGxDrb,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,QAEH,MAEF,IAAK,OACHlF,KAAKynB,YAAYgJ,cAActV,SAASnb,KAAKgO,QAAQ+a,YACrD,MAEF,IAAK,UACH/oB,KAAKynB,YAAYgJ,cAActV,SAASnb,KAAKgO,QAAQmmB,eAG3D,CAME,qBAAA4G,GACO/6B,KAAKynB,YAAYgJ,eAAkBzwB,KAAKynB,YAAYuT,gBAKzDh7B,KAAKynB,YAAYgJ,cAActV,SAASnb,KAAKynB,YAAYuT,eACzDh7B,KAAKynB,YAAYuT,cAAgB,KACrC,CAME,qBAAAH,GACE,IAAK76B,KAAKynB,YAAYgJ,cACpB,OAIFzwB,KAAK45B,uBAEL,IAAIxM,EAAW,GAGf,OAAQptB,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,QAEH,MAAMtC,EAAa5C,KAAKynB,YAAYgJ,cAAc5T,gBAClDuQ,EAAS9sB,KAAKN,KAAKi7B,qBAAqBr4B,EAAY,IACpD,MAEF,IAAK,OAEH,MAAM6pB,EAAkBzsB,KAAKynB,YAAYgJ,cAAc9R,iBACvDyO,EAAWX,EAAgB1a,KAAI,CAAC5D,EAAO2Q,IACrC9e,KAAKi7B,qBAAqB9sB,EAAO2Q,KAI/B9e,KAAKgO,QAAQ0qB,qBACf14B,KAAKk7B,yBAAyBzO,GAEhC,MAEF,IAAK,UAEH,MAAMpK,EAAQriB,KAAKynB,YAAYgJ,cAAcvO,WAC7C,IAAIgV,EAAc,EAElB7U,EAAMphB,SAAQ,CAAC6e,EAAM6B,KAEnB,MAAMwZ,EAAerb,EAAKuB,MAAM,GAAK,GAAEtP,KAAI,CAAC5D,EAAOsB,KACjD,MAAMylB,EAASl1B,KAAKi7B,qBAAqB9sB,EAAO+oB,EAAa,CAC3DvV,UAAWA,EACXlS,WAAYA,IAGd,OADAynB,IACOhC,CAAM,IAGf9H,EAAWA,EAASjL,OAAOgZ,GAGvBn7B,KAAKgO,QAAQ0qB,qBACf14B,KAAKk7B,yBAAyBpb,EAAM6B,EAC9C,IAMI3hB,KAAKynB,YAAY2F,SAAWA,EAG5BA,EAASnsB,SAAQi0B,IACfl1B,KAAKsnB,QAAQ2D,gBAAgBtG,WAAWuQ,EAAO,IAIjDl1B,KAAKynB,YAAYwR,kBAAkBh4B,SAAQi0B,IACzCl1B,KAAKsnB,QAAQ2D,gBAAgBtG,WAAWuQ,EAAO,GAErD,CAME,qBAAAsE,GAEEx5B,KAAK66B,uBACT,CAME,oBAAAjB,GAEE55B,KAAKynB,YAAY2F,SAASnsB,SAAQi0B,IAChCl1B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcqQ,EAAO,IAIpDl1B,KAAKynB,YAAYwR,kBAAkBh4B,SAAQi0B,IACzCl1B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAcqQ,EAAO,IAIpDl1B,KAAKynB,YAAY2F,SAAW,GAC5BptB,KAAKynB,YAAYwR,kBAAoB,GACrCj5B,KAAKynB,YAAYyR,eAAiB,IACtC,CAUE,oBAAA+B,CAAqBr4B,EAAYkc,EAAO3E,EAAW,CAAA,GAajD,OAZsB,IAAIsC,EAAa7Z,EAAY,CACjD8W,GAAI,UAAU1Z,KAAKynB,YAAYgJ,cAAc/W,MAAMoF,IACnD5E,WAAY7T,OAAOwhB,OAAO,CACxB3iB,KAAM,SACN6f,UAAW/kB,KAAKynB,YAAYgJ,cAAc/W,GAC1Cwd,YAAapY,EACbsc,YAAY,EACZzQ,WAAW,GACVxQ,GACHF,MAAOja,KAAKgO,QAAQqmB,cAI1B,CAQE,wBAAA6G,CAAyBhvB,EAAayV,EAAY,GAChD,GAAIzV,EAAYc,OAAS,EACvB,OAGF,MAAMisB,EAAoB,GAIpBoC,EADmD,YAAxCr7B,KAAKynB,YAAYgJ,cAAcvrB,KAChBgH,EAAYc,OAASd,EAAYc,OAAS,EAE1E,IAAK,IAAIE,EAAI,EAAGA,EAAImuB,EAAcnuB,IAAK,CACrC,MAAMQ,EAAQxB,EAAYgB,GACpBS,EAAMzB,GAAagB,EAAI,GAAKhB,EAAYc,QAGxC+gB,EAAW/tB,KAAKunB,eAAe+T,YAAY5tB,EAAOC,EAAK,IAGvDosB,EAAkB,IAAItd,EAAasR,EAAU,CACjDrU,GAAI,aAAa1Z,KAAKynB,YAAYgJ,cAAc/W,MAAMiI,KAAazU,IACnEgN,WAAY,CACVhV,KAAM,kBACN6f,UAAW/kB,KAAKynB,YAAYgJ,cAAc/W,GAC1CkG,aAAc1S,EACdyU,UAAWA,EACX4Z,YAAaruB,EACbsuB,WAAYtuB,EAAI,GAAKhB,EAAYc,OACjC2d,WAAW,GAEb1Q,MAAOja,KAAKgO,QAAQ+qB,wBAGtBE,EAAkB34B,KAAKy5B,EAC7B,CAGI/5B,KAAKynB,YAAYwR,kBAAoBj5B,KAAKynB,YAAYwR,kBAAkB9W,OAAO8W,EACnF,CAQE,qBAAAY,CAAsBnT,GACpB,IAAK1mB,KAAKynB,YAAYgJ,eAAsD,IAArCzwB,KAAKynB,YAAY2F,SAASpgB,OAC/D,OAAO,KAIT,IAAIyuB,EAAgB,KAChBC,EAAkBhe,IAEtB,IAAK,MAAMwX,KAAUl1B,KAAKynB,YAAY2F,SACpC,IACE,MAAMuO,EAAkB37B,KAAK2mB,aAAaG,kBAAkBoO,EAAOrY,iBAGnE,IAAK8e,GAAmBA,EAAgB3uB,OAAS,EAAG,CAClDjM,QAAQ2D,KAAK,sCAAuCwwB,EAAOxb,IAC3D,QACV,CAEQ,MAAM/J,EAAWnN,KAAKqG,KACpBrG,KAAKukB,IAAI4U,EAAgB,GAAKjV,EAAe,GAAI,GACjDlkB,KAAKukB,IAAI4U,EAAgB,GAAKjV,EAAe,GAAI,IAG/C/W,GAAY3P,KAAKgO,QAAQyqB,yBAA2B9oB,EAAW+rB,IACjED,EAAgBvG,EAChBwG,EAAkB/rB,EAErB,CAAC,MAAOzO,GACPH,QAAQ2D,KAAK,4CAA6CxD,EAClE,CAGI,OAAOu6B,CACX,CAQE,8BAAAzB,CAA+BtT,GAC7B,IAAK1mB,KAAKynB,YAAYgJ,eAA+D,IAA9CzwB,KAAKynB,YAAYwR,kBAAkBjsB,OACxE,OAAO,KAIT,IAAIyuB,EAAgB,KAChBC,EAAkBhe,IAEtB,IAAK,MAAMwX,KAAUl1B,KAAKynB,YAAYwR,kBACpC,IACE,MAAM0C,EAAkB37B,KAAK2mB,aAAaG,kBAAkBoO,EAAOrY,iBAGnE,IAAK8e,GAAmBA,EAAgB3uB,OAAS,EAAG,CAClDjM,QAAQ2D,KAAK,gDAAiDwwB,EAAOxb,IACrE,QACV,CAEQ,MAAM/J,EAAWnN,KAAKqG,KACpBrG,KAAKukB,IAAI4U,EAAgB,GAAKjV,EAAe,GAAI,GACjDlkB,KAAKukB,IAAI4U,EAAgB,GAAKjV,EAAe,GAAI,IAG/C/W,GAAY3P,KAAKgO,QAAQyqB,yBAA2B9oB,EAAW+rB,IACjED,EAAgBvG,EAChBwG,EAAkB/rB,EAErB,CAAC,MAAOzO,GACPH,QAAQ2D,KAAK,sDAAuDxD,EAC5E,CAGI,OAAOu6B,CACX,CASE,oBAAAvB,CAAqBt3B,EAAY8jB,GAC/B,IAAK1mB,KAAKynB,YAAYgJ,cACpB,OAAO,EAIT,OAAQzwB,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,QAEH,QAASlF,KAAK65B,sBAAsBnT,GAEtC,IAAK,OAEH,MAAMkV,EAAa57B,KAAKynB,YAAYgJ,cAAc9R,iBAGlD,GAAIid,EAAW5uB,OAAS,EACtB,OAAO,EAIT,IAAK,IAAIE,EAAI,EAAGA,EAAI0uB,EAAW5uB,OAAS,EAAGE,IAAK,CAC9C,MAAMimB,EAAcnzB,KAAKunB,eAAe9Z,sBACtCmuB,EAAW1uB,GACX0uB,EAAW1uB,EAAI,GACftK,GAGF,GAAIuwB,EACF,IAEE,MAAM0I,EAAmB77B,KAAK2mB,aAAaG,kBAAkBqM,EAAYvlB,OAGzE,IAAKiuB,GAAoBA,EAAiB7uB,OAAS,EAAG,CACpDjM,QAAQ2D,KAAK,wDACb,QACd,CAQY,GALiBlC,KAAKqG,KACpBrG,KAAKukB,IAAI8U,EAAiB,GAAKnV,EAAe,GAAI,GAClDlkB,KAAKukB,IAAI8U,EAAiB,GAAKnV,EAAe,GAAI,KAGpC1mB,KAAKgO,QAAQyqB,wBAC3B,OAAO,CAEV,CAAC,MAAOv3B,GACPH,QAAQ2D,KAAK,sDAAuDxD,EAChF,CAEA,CACM,OAAO,EAET,IAAK,UAEH,OAAOlB,KAAKynB,YAAYgJ,cAAcqL,cAAcl5B,GAGtD,OAAO,CACX,CAQE,wBAAAw3B,CAAyBx3B,EAAY8jB,GAEnC,MAOMqV,EAPW/7B,KAAKsnB,QAAQ5C,SAAS+B,sBAAsB7jB,EAAY,CACvEya,UAAWrd,KAAKgO,QAAQyqB,wBACxB/R,eAAgBA,EAChBC,aAAc3mB,KAAK2mB,eAIapmB,QAAOsxB,GACvC,CAAC,QAAS,OAAQ,WAAWtoB,SAASsoB,EAAE3sB,QAGtC62B,EAAiB/uB,OAAS,IAE5BhN,KAAKsnB,QAAQ0U,cAAcD,EAAiB,IAC5C/7B,KAAK05B,qBAAqBqC,EAAiB,IAEjD,CAOE,aAAAjC,CAAc5E,GAEZl1B,KAAK26B,kBAGL36B,KAAKynB,YAAYyR,eAAiBhE,EAGlCA,EAAO/Z,SAASnb,KAAKgO,QAAQ8qB,sBAG7B5D,EAAOzZ,YAAY,cAAc,GAGjCzb,KAAKa,KAAK,iBAAkB,CAC1Bua,QAASpb,KAAKynB,YAAYgJ,cAC1ByG,YAAahC,EAAO1Z,YAAY,gBAEtC,CAME,eAAAmf,GACO36B,KAAKynB,YAAYyR,iBAKtBl5B,KAAKynB,YAAYyR,eAAe/d,SAASnb,KAAKgO,QAAQqmB,cAGtDr0B,KAAKynB,YAAYyR,eAAezd,YAAY,cAAc,GAG1Dzb,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASpb,KAAKynB,YAAYgJ,cAC1ByG,YAAal3B,KAAKynB,YAAYyR,eAAe1d,YAAY,iBAI3Dxb,KAAKynB,YAAYyR,eAAiB,KACtC,CAOE,gBAAAoB,CAAiBpF,GAEf,GAAIl1B,KAAKynB,YAAYyR,gBACjBl5B,KAAKynB,YAAYyR,eAAexf,KAAOwb,EAAOxb,GAChD,OAIF,MAAMuiB,EAAe/G,EAAO7Z,WAC5B6Z,EAAO/Z,SAAS9U,OAAOwhB,OAAO,CAAA,EAAIoU,EAAc,CAC9CzW,KAA0B,IAApByW,EAAazW,QAIrBxlB,KAAKynB,YAAY2F,SAASnsB,SAAQ6X,IAC5BA,EAAEY,KAAOwb,EAAOxb,IAAOZ,EAAE0C,YAAY,eACvC1C,EAAEqC,SAASnb,KAAKgO,QAAQqmB,aAChC,GAEA,CAOE,yBAAAmG,CAA0BtF,GAExB,MAAM+G,EAAe/G,EAAO7Z,WAC5B6Z,EAAO/Z,SAAS9U,OAAOwhB,OAAO,CAAA,EAAIoU,EAAc,CAC9CzW,KAA0B,IAApByW,EAAazW,KACnBsF,MAAO,4BAIT9qB,KAAKynB,YAAYwR,kBAAkBh4B,SAAQ6X,IACrCA,EAAEY,KAAOwb,EAAOxb,IAClBZ,EAAEqC,SAASnb,KAAKgO,QAAQ+qB,sBAChC,GAEA,CAOE,qBAAAkB,CAAsBF,GACpB,IAAK/5B,KAAKynB,YAAYgJ,gBAAkBsJ,EACtC,OAGF,MAAMmC,EAAanC,EAAgBve,YAAY,eACzC2gB,EAAWpC,EAAgBve,YAAY,aACvCmG,EAAYoY,EAAgBve,YAAY,cAAgB,EACxD5Y,EAAam3B,EAAgBld,gBAGnC,OAAQ7c,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,OAEH,MAAM02B,EAAa57B,KAAKynB,YAAYgJ,cAAc9R,iBAGlDid,EAAW7c,OAAOod,EAAU,EAAGv5B,GAG/B5C,KAAKynB,YAAYgJ,cAAc7R,eAAegd,GAC9C,MAEF,IAAK,UAEH,MAAMvZ,EAAQriB,KAAKynB,YAAYgJ,cAAcvO,WAG7C,GAAIP,GAAa,GAAKA,EAAYU,EAAMrV,OAAQ,CAC9C,MAAM8S,EAAOuC,EAAMV,GAIF,IAAbwa,GAEFrc,EAAKf,OAAOe,EAAK9S,OAAS,EAAG,EAAGpK,GAEhCkd,EAAKA,EAAK9S,OAAS,GAAK8S,EAAK,IAG7BA,EAAKf,OAAOod,EAAU,EAAGv5B,GAI3B5C,KAAKynB,YAAYgJ,cAAcrO,SAASC,EAChD,EAKIriB,KAAKw5B,wBAGLx5B,KAAKa,KAAK,cAAe,CACvBua,QAASpb,KAAKynB,YAAYgJ,cAC1B7tB,WAAYA,EACZw5B,YAAaF,EACbG,WAAYF,GAElB,CAME,qBAAA1B,GACE,IAAKz6B,KAAKynB,YAAYgJ,gBAAkBzwB,KAAKynB,YAAYyR,eACvD,OAGF,MAAMhC,EAAcl3B,KAAKynB,YAAYyR,eAAe1d,YAAY,eAC1DmG,EAAY3hB,KAAKynB,YAAYyR,eAAe1d,YAAY,cAAgB,EAG9E,OAAQxb,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,QAGH,YADAnE,QAAQ2D,KAAK,+CAGf,IAAK,OAEH,MAAMk3B,EAAa57B,KAAKynB,YAAYgJ,cAAc9R,iBAGlD,GAAIid,EAAW5uB,QAAU,EAEvB,YADAjM,QAAQ2D,KAAK,4DAKfk3B,EAAW7c,OAAOmY,EAAa,GAG/Bl3B,KAAKynB,YAAYgJ,cAAc7R,eAAegd,GAC9C,MAEF,IAAK,UAEH,MAAMvZ,EAAQriB,KAAKynB,YAAYgJ,cAAcvO,WAG7C,GAAIP,GAAa,GAAKA,EAAYU,EAAMrV,OAAQ,CAC9C,MAAM8S,EAAOuC,EAAMV,GAGnB,GAAI7B,EAAK9S,QAAU,EAEjB,YADAjM,QAAQ2D,KAAK,+DAKf,MAAM+K,EAAazP,KAAKynB,YAAYyR,eAAe1d,YAAY,cAG/DsE,EAAKf,OAAOtP,EAAY,GAGL,IAAfA,IACFqQ,EAAKA,EAAK9S,OAAS,GAAK8S,EAAK,IAI/B9f,KAAKynB,YAAYgJ,cAAcrO,SAASC,EAChD,EAKIriB,KAAKynB,YAAYyR,eAAiB,KAGlCl5B,KAAKw5B,wBAGLx5B,KAAKa,KAAK,gBAAiB,CACzBua,QAASpb,KAAKynB,YAAYgJ,cAC1ByG,YAAaA,GAEnB,CAQE,WAAAmD,CAAYz3B,EAAY8jB,GACtB,IAAK1mB,KAAKynB,YAAY+M,aAAex0B,KAAKynB,YAAY0R,kBACpD,OAIF,MAAMmD,EAAiBt8B,KAAK2mB,aAAaG,kBAAkB9mB,KAAKynB,YAAY0R,mBACtExpB,EAAWnN,KAAKqG,KACpBrG,KAAKukB,IAAIuV,EAAe,GAAK5V,EAAe,GAAI,GAChDlkB,KAAKukB,IAAIuV,EAAe,GAAK5V,EAAe,GAAI,IAOlD,OAHA1mB,KAAKynB,YAAY6R,gBAAkB3pB,EAG3B3P,KAAKynB,YAAY2R,eACzB,IAAK,aACHp5B,KAAKu8B,oBAAoB35B,GACzB,MAEF,IAAK,OACH5C,KAAKw8B,aAAa55B,GAGxB,CAOE,mBAAA25B,CAAoB35B,GAClB,IAAK5C,KAAKynB,YAAYgJ,gBAAkBzwB,KAAKynB,YAAYyR,eACvD,OAGF,MAAMhC,EAAcl3B,KAAKynB,YAAYyR,eAAe1d,YAAY,eAC1DmG,EAAY3hB,KAAKynB,YAAYyR,eAAe1d,YAAY,cAAgB,EAc9E,OAXAxb,KAAKynB,YAAYyR,eAAepc,cAAcla,GAG1C5C,KAAKgO,QAAQ4B,UAAY5P,KAAKgO,QAAQ4qB,gBACxC54B,KAAKsnB,QAAQ0E,mBAAmBhsB,KAAKynB,YAAYyR,gBAGjDt2B,EAAa5C,KAAKynB,YAAYyR,eAAerc,iBAIvC7c,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,QAEHlF,KAAKynB,YAAYgJ,cAAc3T,cAAcla,GAC7C,MAEF,IAAK,OAEH,MAAMg5B,EAAa57B,KAAKynB,YAAYgJ,cAAc9R,iBAClDid,EAAW1E,GAAet0B,EAC1B5C,KAAKynB,YAAYgJ,cAAc7R,eAAegd,GAC9C,MAEF,IAAK,UAEH,MAAMvZ,EAAQriB,KAAKynB,YAAYgJ,cAAcvO,WAG7C,GAAIP,GAAa,GAAKA,EAAYU,EAAMrV,OAAQ,CAC9C,MAAM8S,EAAOuC,EAAMV,GAGblS,EAAazP,KAAKynB,YAAYyR,eAAe1d,YAAY,cAG/DsE,EAAKrQ,GAAc7M,EAGA,IAAf6M,IACFqQ,EAAKA,EAAK9S,OAAS,GAAKpK,GAI1B5C,KAAKynB,YAAYgJ,cAAcrO,SAASC,EAChD,EAKIriB,KAAKw5B,wBAGLx5B,KAAKa,KAAK,cAAe,CACvBua,QAASpb,KAAKynB,YAAYgJ,cAC1ByG,YAAaA,EACbt0B,WAAYA,GAElB,CASE,YAAA45B,CAAa55B,GACX,IAAK5C,KAAKynB,YAAYgJ,gBAAkBzwB,KAAKynB,YAAY0R,kBACvD,OAIF,MAAMtB,OAAsDpwB,IAA3CzH,KAAKynB,YAAY0R,kBAAkBp2B,IAAoB/C,KAAKynB,YAAY0R,kBAAkBp2B,IAAM/C,KAAKynB,YAAY0R,kBAAkB/wB,EAC9I0vB,OAAsDrwB,IAA3CzH,KAAKynB,YAAY0R,kBAAkBz2B,IAAoB1C,KAAKynB,YAAY0R,kBAAkBz2B,IAAM1C,KAAKynB,YAAY0R,kBAAkBhxB,EAC9Is0B,OAAkEh1B,IAAjDzH,KAAKynB,YAAY0R,kBAAkBl2B,UAA0BjD,KAAKynB,YAAY0R,kBAAkBl2B,eAC3EwE,IAAzCzH,KAAKynB,YAAY0R,kBAAkB9wB,EAAkBrI,KAAKynB,YAAY0R,kBAAkB9wB,EAAI,EAEzFq0B,OAAgCj1B,IAAnB7E,EAAWG,IAAoBH,EAAWG,IAAMH,EAAWwF,EACxEu0B,OAAgCl1B,IAAnB7E,EAAWF,IAAoBE,EAAWF,IAAME,EAAWuF,EACxEy0B,OAA4Cn1B,IAAzB7E,EAAWK,UAA0BL,EAAWK,eACrDwE,IAAjB7E,EAAWyF,EAAkBzF,EAAWyF,EAAI,EAGzCw0B,EAAS,CACb95B,IAAK25B,EAAa7E,EAClBn1B,IAAKi6B,EAAa7E,EAClB70B,UAAWjD,KAAKgO,QAAQ4B,SAAWgtB,EAAmBH,EAAiB,GAIzE,OAAQz8B,KAAKynB,YAAYgJ,cAAcvrB,MACvC,IAAK,QAEH,MAAM43B,EAAa98B,KAAKynB,YAAYgJ,cAAc5T,gBAC5CkgB,OAA8Bt1B,IAAnBq1B,EAAW/5B,IAAoB+5B,EAAW/5B,IAAM+5B,EAAW10B,EACtE40B,OAA8Bv1B,IAAnBq1B,EAAWp6B,IAAoBo6B,EAAWp6B,IAAMo6B,EAAW30B,EACtE80B,OAA0Cx1B,IAAzBq1B,EAAW75B,UAA0B65B,EAAW75B,eACnDwE,IAAjBq1B,EAAWz0B,EAAkBy0B,EAAWz0B,EAAI,EAEzC4V,EAAW,CACflb,IAAKg6B,EAAWF,EAAO95B,IACvBL,IAAKs6B,EAAWH,EAAOn6B,IACvBO,UAAWg6B,EAAiBJ,EAAO55B,WAErCjD,KAAKynB,YAAYgJ,cAAc3T,cAAcmB,GAC7C,MAEF,IAAK,OAEH,MACMif,EADal9B,KAAKynB,YAAYgJ,cAAc9R,iBACjB5M,KAAI5D,IACnC,MAAMpL,OAAoB0E,IAAd0G,EAAMpL,IAAoBoL,EAAMpL,IAAMoL,EAAM/F,EAClD1F,OAAoB+E,IAAd0G,EAAMzL,IAAoByL,EAAMzL,IAAMyL,EAAMhG,EAClDlF,OAAgCwE,IAApB0G,EAAMlL,UAA0BkL,EAAMlL,eACzCwE,IAAZ0G,EAAM9F,EAAkB8F,EAAM9F,EAAI,EAErC,MAAO,CACLtF,IAAKA,EAAM85B,EAAO95B,IAClBL,IAAKA,EAAMm6B,EAAOn6B,IAClBO,UAAWA,EAAY45B,EAAO55B,UAC/B,IAEHjD,KAAKynB,YAAYgJ,cAAc7R,eAAese,GAC9C,MAEF,IAAK,UAEH,MACMC,EADQn9B,KAAKynB,YAAYgJ,cAAcvO,WACtBnQ,KAAI+N,GACzBA,EAAK/N,KAAI5D,IACP,MAAMpL,OAAoB0E,IAAd0G,EAAMpL,IAAoBoL,EAAMpL,IAAMoL,EAAM/F,EAClD1F,OAAoB+E,IAAd0G,EAAMzL,IAAoByL,EAAMzL,IAAMyL,EAAMhG,EAClDlF,OAAgCwE,IAApB0G,EAAMlL,UAA0BkL,EAAMlL,eACzCwE,IAAZ0G,EAAM9F,EAAkB8F,EAAM9F,EAAI,EAErC,MAAO,CACLtF,IAAKA,EAAM85B,EAAO95B,IAClBL,IAAKA,EAAMm6B,EAAOn6B,IAClBO,UAAWA,EAAY45B,EAAO55B,UAC/B,MAGLjD,KAAKynB,YAAYgJ,cAAcrO,SAAS+a,GAK1Cn9B,KAAKynB,YAAY0R,kBAAoBv2B,EAGrC5C,KAAKw5B,wBAGLx5B,KAAKa,KAAK,eAAgB,CACxBua,QAASpb,KAAKynB,YAAYgJ,cAC1BoM,OAAQA,GAEd,CAME,WAAAnC,GACO16B,KAAKynB,YAAY+M,aAKtBx0B,KAAKynB,YAAY+M,YAAa,EAC9Bx0B,KAAKynB,YAAY0R,kBAAoB,KAGjCn5B,KAAKynB,YAAYuR,iBAAmBh5B,KAAKynB,YAAYgJ,eACvDzwB,KAAKynB,YAAYgJ,cAAcxV,YAAYjb,KAAKynB,YAAYuR,gBAAgBl4B,MAI9Ed,KAAKw5B,wBAGLx5B,KAAKa,KAAK,gBAAiB,CACzBua,QAASpb,KAAKynB,YAAYgJ,gBAI5BzwB,KAAKynB,YAAY2R,cAAgB,OACrC,CAME,gBAAAO,GACE,IAAK35B,KAAKynB,YAAYgJ,cACpB,OAIEzwB,KAAKynB,YAAY+M,aACnBx0B,KAAKynB,YAAY+M,YAAa,EAC9Bx0B,KAAKynB,YAAY0R,kBAAoB,MAIvCn5B,KAAKsnB,QAAQ5C,SAAS0C,cAAcpnB,KAAKynB,YAAYgJ,eAGrDzwB,KAAK+6B,wBAGL,MAAM3f,EAAUpb,KAAKynB,YAAYgJ,cAGjCzwB,KAAKynB,YAAY4R,mBAAoB,EAGrCr5B,KAAK45B,uBAGL55B,KAAKynB,YAAYgJ,cAAgB,KACjCzwB,KAAKynB,YAAYuR,gBAAkB,KACnCh5B,KAAKynB,YAAYyR,eAAiB,KAClCl5B,KAAKynB,YAAY2R,cAAgB,OAGjCp5B,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASA,GAEf,CAME,cAAAwf,GACE,IAAK56B,KAAKynB,YAAYgJ,gBAAkBzwB,KAAKynB,YAAYuR,gBACvD,OAIFh5B,KAAKynB,YAAYgJ,cAAcxV,YAAYjb,KAAKynB,YAAYuR,gBAAgBl4B,MAG5Ed,KAAK+6B,wBAGL,MAAM3f,EAAUpb,KAAKynB,YAAYgJ,cAGjCzwB,KAAK45B,uBAGL55B,KAAKynB,YAAYgJ,cAAgB,KACjCzwB,KAAKynB,YAAYuR,gBAAkB,KACnCh5B,KAAKynB,YAAYyR,eAAiB,KAClCl5B,KAAKynB,YAAY2R,cAAgB,OAGjCp5B,KAAKa,KAAK,mBAAoB,CAC5Bua,QAASA,GAEf,CAOE,WAAAsU,CAAYC,GAaV,OAZA3vB,KAAKgO,QAAQ4B,WAAa+f,EAGtB3vB,KAAKynB,YAAYgJ,eACnBzwB,KAAKw5B,wBAIPx5B,KAAKa,KAAK,kBAAmB,CAC3B+O,SAAU5P,KAAKgO,QAAQ4B,WAGlB5P,KAAKgO,QAAQ4B,QACxB,CAOE,sBAAAwtB,CAAuBC,GAarB,OAZAr9B,KAAKgO,QAAQ0qB,sBAAwB2E,EAGjCr9B,KAAKynB,YAAYgJ,eACnBzwB,KAAKw5B,wBAIPx5B,KAAKa,KAAK,6BAA8B,CACtC63B,oBAAqB14B,KAAKgO,QAAQ0qB,sBAG7B14B,KAAKgO,QAAQ0qB,mBACxB,CAOE,sBAAA4E,CAAuBD,GAQrB,OAPAr9B,KAAKgO,QAAQ2qB,sBAAwB0E,EAGrCr9B,KAAKa,KAAK,6BAA8B,CACtC83B,oBAAqB34B,KAAKgO,QAAQ2qB,sBAG7B34B,KAAKgO,QAAQ2qB,mBACxB,CAOE,gBAAA4E,CAAiB5N,GAQf,OAPA3vB,KAAKgO,QAAQ4qB,gBAAkBjJ,EAG/B3vB,KAAKa,KAAK,uBAAwB,CAChC+3B,cAAe54B,KAAKgO,QAAQ4qB,gBAGvB54B,KAAKgO,QAAQ4qB,aACxB,CAME,WAAAhF,GACE,MAAO,CACLhkB,SAAU5P,KAAKgO,QAAQ4B,SACvB8oB,oBAAqB14B,KAAKgO,QAAQ0qB,oBAClCC,oBAAqB34B,KAAKgO,QAAQ2qB,oBAClCC,cAAe54B,KAAKgO,QAAQ4qB,cAC5BH,wBAAyBz4B,KAAKgO,QAAQyqB,wBAE5C,ECxjDO,MAAM+E,UAAwB19B,EAKnC,WAAAC,CAAYiO,EAAU,IAGpB,GAFAlJ,SAEKkJ,EAAQsZ,QACX,MAAM,IAAI7lB,MAAM,oEAGlB,IAAKuM,EAAQ2Y,aACX,MAAM,IAAIllB,MAAM,iEAIlBzB,KAAKsnB,QAAUtZ,EAAQsZ,QACvBtnB,KAAK2mB,aAAe3Y,EAAQ2Y,aAC5B3mB,KAAKunB,eAAiBvZ,EAAQuZ,gBAAkBvnB,KAAKsnB,QAAQC,eAG7DvnB,KAAKgO,QAAU3H,OAAOwhB,OAAO,CAC3BxK,UAAW,GACXzN,UAAU,EACV6tB,cAAc,EACdC,YAAY,EACZC,YAAY,EACZC,SAAU,GACVC,eAAe,EACfC,0BAA0B,EAC1BC,iBAAkB,CAChB74B,KAAM,SACNsgB,KAAM,GACNsF,MAAO,yBACPC,aAAc,EACdF,aAAc,WAEhBmT,eAAgB,CACd94B,KAAM,SACNsgB,KAAM,GACNsF,MAAO,0BACPC,aAAc,EACdF,aAAc,WAEhBoT,eAAgB,CACd/4B,KAAM,SACNsgB,KAAM,EACNsF,MAAO,uBACPC,aAAc,EACdF,aAAc,YAEf7c,GAGHhO,KAAKk+B,MAAQ,CACX1W,UAAU,EACV2W,YAAa,KACbC,cAAe,KACfC,kBAAmB,KACnB9E,YAAa,GACb+E,kBAAmB,MAIrBt+B,KAAKiqB,oBAAsBjqB,KAAKiqB,oBAAoBD,KAAKhqB,KAC7D,CAME,QAAA2nB,CAAS3Z,EAAU,IACbhO,KAAKk+B,MAAM1W,WAKXxZ,IACFhO,KAAKgO,QAAU3H,OAAOwhB,OAAO7nB,KAAKgO,QAASA,IAI7ChO,KAAK2mB,aAAalmB,iBAAiB,YAAaT,KAAKiqB,qBAGrDjqB,KAAKk+B,MAAM1W,UAAW,EAGtBxnB,KAAKa,KAAK,YAAab,KAAKgO,SAChC,CAKE,UAAA+Z,GACO/nB,KAAKk+B,MAAM1W,WAKhBxnB,KAAK2mB,aAAavlB,oBAAoB,YAAapB,KAAKiqB,qBAGxDjqB,KAAKu+B,aAGLv+B,KAAKk+B,MAAM1W,UAAW,EAGtBxnB,KAAKa,KAAK,eACd,CAME,cAAA29B,CAAeC,GAEb,MAAMC,EAAc/hB,MAAMC,QAAQ6hB,GAAWA,EAAU,CAACA,GAGxDz+B,KAAKk+B,MAAM3E,YAAcmF,EAGzB1+B,KAAKa,KAAK,qBAAsB69B,EACpC,CAKE,gBAAAC,GACE3+B,KAAKk+B,MAAM3E,YAAc,GAGzBv5B,KAAKa,KAAK,qBACd,CAME,oBAAA+9B,CAAqBxjB,GACnBpb,KAAKk+B,MAAMG,kBAAoBjjB,CACnC,CAOE,mBAAA6O,CAAoB7pB,GAElB,IAAKA,EAAMwC,aAAexC,EAAMo1B,MAC9B,OAIFx1B,KAAKk+B,MAAMI,kBAAoB,CAC7B17B,WAAYxC,EAAMwC,WAClB4yB,MAAOp1B,EAAMo1B,OAIf,MAAMqJ,EAAO7+B,KAAK8+B,eAAe1+B,EAAMwC,WAAYxC,EAAMo1B,OAGpDqJ,EAML7+B,KAAK++B,YAAYF,GALf7+B,KAAKu+B,YAMX,CASE,cAAAO,CAAel8B,EAAY4yB,GAEzB,IAAKx1B,KAAKk+B,MAAM1W,SACd,OAAO,KAIT,IAAIqX,EAAO,KAGX,OAAI7+B,KAAKgO,QAAQyvB,eACfoB,EAAO7+B,KAAKg/B,gBAAgBp8B,EAAY4yB,GACpCqJ,IAIF7+B,KAAKgO,QAAQ0vB,aACfmB,EAAO7+B,KAAKi/B,cAAcr8B,EAAY4yB,GAClCqJ,IAIF7+B,KAAKgO,QAAQ2vB,aACfkB,EAAO7+B,KAAKk/B,cAAct8B,GACtBi8B,GAZaA,EAeZ,IACX,CASE,eAAAG,CAAgBp8B,EAAY4yB,GAC1B,MAAM9Q,EAAW1kB,KAAKm/B,mBACtB,IAAIC,EAAe1hB,IACf2hB,EAAW,KAGf,IAAK,MAAMjkB,KAAWsJ,EAAU,CAE9B,GAAI1kB,KAAKk+B,MAAMG,mBACXjjB,EAAQ1B,KAAO1Z,KAAKk+B,MAAMG,kBAAkB3kB,GAC9C,SAIF,IAAI0T,EAAW,GAEf,OAAQhS,EAAQlW,MAChB,IAAK,QACHkoB,EAAW,CAAChS,EAAQyB,iBACpB,MAEF,IAAK,OACHuQ,EAAWhS,EAAQuD,iBACnB,MAEF,IAAK,UAEWvD,EAAQ8G,WAChBjhB,SAAQ6e,IACZsN,EAAWA,EAASjL,OAAOrC,EAAK,IAElC,MAEF,QACE,SAIF,IAAK,MAAMoV,KAAU9H,EAAU,CAE7B,MAAMkS,EAAct/B,KAAK2mB,aAAaG,kBAAkBoO,GAGxD,IAAKoK,IAAgB3iB,MAAMC,QAAQ0iB,IAAgBA,EAAYtyB,OAAS,IACnEwoB,IAAU7Y,MAAMC,QAAQ4Y,IAAUA,EAAMxoB,OAAS,EACpD,SAIF,MAAM2C,EAAWnN,KAAKqG,KACpBrG,KAAKukB,IAAIuY,EAAY,GAAK9J,EAAM,GAAI,GACpChzB,KAAKukB,IAAIuY,EAAY,GAAK9J,EAAM,GAAI,IAIlC7lB,GAAY3P,KAAKgO,QAAQqP,WAAa1N,EAAWyvB,IACnDA,EAAezvB,EACf0vB,EAAW,CACTn6B,KAAM,SACNkW,QAASA,EACTxY,WAAYsyB,EACZvlB,SAAUA,EACV4vB,WAAW,GAGvB,CACA,CAEI,OAAOF,CACX,CASE,aAAAJ,CAAcr8B,EAAY4yB,GACxB,MAAM9Q,EAAW1kB,KAAKm/B,mBACtB,IAAIC,EAAe1hB,IACf2hB,EAAW,KAGf,IAAK,MAAMjkB,KAAWsJ,EAAU,CAE9B,GAAI1kB,KAAKk+B,MAAMG,mBACXjjB,EAAQ1B,KAAO1Z,KAAKk+B,MAAMG,kBAAkB3kB,GAC9C,SAIF,GAAqB,UAAjB0B,EAAQlW,KACV,SAIF,MAAM2L,EAAW,GAEjB,OAAQuK,EAAQlW,MAChB,IAAK,OACH,MAAM4Y,EAAS1C,EAAQuD,iBAGvB,IAAK,IAAIzR,EAAI,EAAGA,EAAI4Q,EAAO9Q,OAAS,EAAGE,IACrC2D,EAASvQ,KAAK,CACZoN,MAAOoQ,EAAO5Q,GACdS,IAAKmQ,EAAO5Q,EAAI,GAChBkO,QAASA,IAGb,MAEF,IAAK,UAEWA,EAAQ8G,WAChBjhB,SAAQ6e,IACZ,IAAK,IAAI5S,EAAI,EAAGA,EAAI4S,EAAK9S,OAAS,EAAGE,IACnC2D,EAASvQ,KAAK,CACZoN,MAAOoS,EAAK5S,GACZS,IAAKmS,EAAK5S,EAAI,GACdkO,QAASA,GAEvB,IAEQ,MAEF,QACE,SAIF,IAAK,MAAMuS,KAAW9c,EAAU,CAE9B,MAAMsiB,EAAcnzB,KAAKunB,eAAe9Z,sBACtCkgB,EAAQjgB,MACRigB,EAAQhgB,IACR/K,GAGF,GAAIuwB,EAAa,CAEf,MAAMqM,EAAex/B,KAAK2mB,aAAaG,kBAAkBqM,EAAYvlB,OAG/D+B,EAAWnN,KAAKqG,KACpBrG,KAAKukB,IAAIyY,EAAa,GAAKhK,EAAM,GAAI,GACrChzB,KAAKukB,IAAIyY,EAAa,GAAKhK,EAAM,GAAI,IAInC7lB,GAAY3P,KAAKgO,QAAQqP,WAAa1N,EAAWyvB,IACnDA,EAAezvB,EACf0vB,EAAW,CACTn6B,KAAM,OACNkW,QAASuS,EAAQvS,QACjBxY,WAAYuwB,EAAYvlB,MACxBqH,aAAc0Y,EAAQjgB,MACtBwH,WAAYyY,EAAQhgB,IACpB+B,gBAAiByjB,EAAYzjB,gBAC7BC,SAAUA,EACV4vB,WAAW,GAGzB,CACA,CACA,CAEI,OAAOF,CACX,CAQE,aAAAH,CAAct8B,GAEZ,IAAK5C,KAAKgO,QAAQ2vB,WAChB,OAAO,KAIT,MAAMC,EAAW59B,KAAKgO,QAAQ4vB,SAIxB76B,OAAyB0E,IAAnB7E,EAAWG,IAAoBH,EAAWG,IAAMH,EAAWwF,EACjE1F,OAAyB+E,IAAnB7E,EAAWF,IAAoBE,EAAWF,IAAME,EAAWuF,EACjElF,OAAqCwE,IAAzB7E,EAAWK,UAA0BL,EAAWK,eAC9CwE,IAAjB7E,EAAWyF,EAAkBzF,EAAWyF,EAAI,EAE/C,QAAYZ,IAAR1E,QAA6B0E,IAAR/E,EAEvB,OADA3B,QAAQG,MAAM,+CAAgD0B,GACvD,KAKT,MAGM68B,EAAc7B,GAHO,EAAI,OAIzB8B,EAAc9B,GAHO,GAAK,MAASp7B,KAAKmG,IAAI5F,EAAMP,KAAK4B,GAAK,OAiBlE,MAAO,CACLc,KAAM,OACNtC,WATwB,CACxBG,IALiBP,KAAK+sB,MAAMxsB,EAAM08B,GAAeA,EAMjD/8B,IALiBF,KAAK+sB,MAAM7sB,EAAMg9B,GAAeA,EAMjDz8B,UAAWA,GAOX26B,SAAUA,EACV2B,WAAW,EAEjB,CAOE,gBAAAJ,GAEE,GAAIn/B,KAAKk+B,MAAM3E,YAAYvsB,OAAS,EAClC,OAAOhN,KAAKk+B,MAAM3E,YAIpB,MAAM7U,EAAW1kB,KAAKsnB,QAAQ5C,SAASS,iBAGvC,GAAInlB,KAAKgO,QAAQ8vB,yBAA0B,CACzC,MAGM6B,EAHkB3/B,KAAKsnB,QAAQ2D,gBAAgB9F,iBAGR5kB,QAAOsxB,IAClD,MAAM3sB,EAAO2sB,EAAErW,YAAY,QAC3B,QAAkB,WAATtW,GACQ,oBAATA,GACS,mBAATA,EAA0B,IAGpC,OAAOwf,EAASvC,OAAOwd,EAC7B,CAEI,OAAOjb,CACX,CAOE,WAAAqa,CAAYF,GAEV7+B,KAAKu+B,aAGLv+B,KAAKk+B,MAAMC,YAAcU,EAGrB7+B,KAAKgO,QAAQ6vB,eACf79B,KAAK4/B,qBAAqBf,GAI5B7+B,KAAKa,KAAK,OAAQg+B,EACtB,CAME,UAAAN,GAQE,GANIv+B,KAAKk+B,MAAME,gBACbp+B,KAAKsnB,QAAQ2D,gBAAgBpG,cAAc7kB,KAAKk+B,MAAME,eACtDp+B,KAAKk+B,MAAME,cAAgB,MAIzBp+B,KAAKk+B,MAAMC,YAAa,CAC1B,MAAM0B,EAAa7/B,KAAKk+B,MAAMC,YAAYoB,UAC1Cv/B,KAAKk+B,MAAMC,YAAc,KAGrB0B,GACF7/B,KAAKa,KAAK,SAElB,CACA,CAOE,oBAAA++B,CAAqBf,GAEnB,IAAIiB,EAEJ,OAAQjB,EAAK35B,MACb,IAAK,SAYL,QACE46B,EAAS9/B,KAAKgO,QAAQ+vB,uBATxB,IAAK,OACH+B,EAAS9/B,KAAKgO,QAAQgwB,eACtB,MAEF,IAAK,OACH8B,EAAS9/B,KAAKgO,QAAQiwB,eAQxB,MAAM8B,EAAY,IAAItjB,EAAaoiB,EAAKj8B,WAAY,CAClD8W,GAAI,kBAAkBC,KAAKC,QAC3BM,WAAY,CACVhV,KAAM,iBACN86B,SAAUnB,EAAK35B,KACfylB,WAAW,GAEb1Q,MAAO6lB,IAIT9/B,KAAKsnB,QAAQ2D,gBAAgBtG,WAAWob,GAGxC//B,KAAKk+B,MAAME,cAAgB2B,CAC/B,CAME,YAAArK,GACE,OAAO11B,KAAKk+B,MAAMC,WACtB,CAQE,WAAA8B,CAAYr9B,EAAY4yB,GAOtB,OALKA,GAASx1B,KAAK2mB,eACjB6O,EAAQx1B,KAAK2mB,aAAaG,kBAAkBlkB,IAIvC5C,KAAK8+B,eAAel8B,EAAY4yB,EAC3C,CAOE,eAAA0K,CAAgBvQ,GAQd,OAPA3vB,KAAKgO,QAAQyvB,eAAiB9N,EAG9B3vB,KAAKa,KAAK,sBAAuB,CAC/B48B,aAAcz9B,KAAKgO,QAAQyvB,eAGtBz9B,KAAKgO,QAAQyvB,YACxB,CAOE,aAAA0C,CAAcxQ,GAQZ,OAPA3vB,KAAKgO,QAAQ0vB,aAAe/N,EAG5B3vB,KAAKa,KAAK,sBAAuB,CAC/B68B,WAAY19B,KAAKgO,QAAQ0vB,aAGpB19B,KAAKgO,QAAQ0vB,UACxB,CAOE,aAAA0C,CAAczQ,GAQZ,OAPA3vB,KAAKgO,QAAQ2vB,aAAehO,EAG5B3vB,KAAKa,KAAK,sBAAuB,CAC/B88B,WAAY39B,KAAKgO,QAAQ2vB,aAGpB39B,KAAKgO,QAAQ2vB,UACxB,CAOE,WAAA0C,CAAY7a,GACV,OAAIlb,MAAMkb,IAASA,GAAQ,GACzBzkB,QAAQG,MAAM,iDACPlB,KAAKgO,QAAQ4vB,WAGtB59B,KAAKgO,QAAQ4vB,SAAWpY,EAGxBxlB,KAAKa,KAAK,sBAAuB,CAC/B+8B,SAAU59B,KAAKgO,QAAQ4vB,WAGlB59B,KAAKgO,QAAQ4vB,SACxB,CAOE,YAAA0C,CAAajjB,GACX,OAAI/S,MAAM+S,IAAcA,GAAa,GACnCtc,QAAQG,MAAM,iDACPlB,KAAKgO,QAAQqP,YAGtBrd,KAAKgO,QAAQqP,UAAYA,EAGzBrd,KAAKa,KAAK,sBAAuB,CAC/Bwc,UAAWrd,KAAKgO,QAAQqP,YAGnBrd,KAAKgO,QAAQqP,UACxB,CAME,WAAAuW,GACE,MAAO,CACLpM,SAAUxnB,KAAKk+B,MAAM1W,SACrBnK,UAAWrd,KAAKgO,QAAQqP,UACxBzN,SAAU5P,KAAKgO,QAAQ4B,SACvB6tB,aAAcz9B,KAAKgO,QAAQyvB,aAC3BC,WAAY19B,KAAKgO,QAAQ0vB,WACzBC,WAAY39B,KAAKgO,QAAQ2vB,WACzBC,SAAU59B,KAAKgO,QAAQ4vB,SACvBC,cAAe79B,KAAKgO,QAAQ6vB,cAC5BC,yBAA0B99B,KAAKgO,QAAQ8vB,yBAE7C,CAKE,OAAAzV,GAEMroB,KAAKk+B,MAAM1W,UACbxnB,KAAK+nB,aAIP/nB,KAAKk+B,MAAM3E,YAAc,GAGzBv5B,KAAKqB,oBACT,ECrsBO,MAAMk/B,UAAsBzgC,EAKjC,WAAAC,CAAYiO,EAAU,IACpBlJ,QAGA9E,KAAK2mB,aAAe3Y,EAAQ2Y,aAC5B3mB,KAAKgpB,SAAW3iB,OAAOwhB,OAAO,CAC5BjY,UAAU,EACV4wB,UAAU,EACVC,WAAY,GACZC,kBAAmB,eACnBC,cAAe,GACfxX,mBAAoB,CAClBjkB,KAAM,SACNsgB,KAAM,GACNsF,MAAO,WAET7B,kBAAmB,CACjB+B,MAAO,EACPF,MAAO,WAETF,qBAAsB,CACpBtB,UAAW,0BACXuB,aAAc,UACdE,aAAc,IAEf/c,EAAQgb,UAAY,IAGvBhpB,KAAK0kB,SAAW,IAAID,EACpBzkB,KAAKirB,gBAAkB,IAAIxG,EAC3BzkB,KAAKy5B,iBAAmB,IAAIhV,EAG5BzkB,KAAKunB,eAAiB,IAAIza,EAG1B9M,KAAK4gC,QAAU,CACbC,UAAW,GACXC,UAAW,GACXC,QAAS/gC,KAAKgpB,SAASyX,YAIzBzgC,KAAKghC,WAAa,KAClBhhC,KAAKihC,WAAa,SAClBjhC,KAAKkhC,WAAY,EACjBlhC,KAAKmhC,WAAY,EACjBnhC,KAAKohC,aAAc,EAGnBphC,KAAKma,SAAW,CACdknB,YAAa,GACbC,QAAS,IAAI3nB,KACb4nB,SAAU,IAAI5nB,KACd6nB,MAAO,GACPC,YAAa,GACb99B,WAAY,YACZ8kB,MAAO,CACL9Y,SAAU,SACVkH,KAAM,gBACN9F,MAAO,WAET2wB,iBAAkB,CAAE,GAItB1hC,KAAK0nB,uBAGL1nB,KAAK2hC,kBACT,CAME,gBAAAA,GAEE3hC,KAAK4hC,MAAQ,CACXzW,YAAa,IAAI5C,EAAgB,CAC/BjB,QAAStnB,KACT2mB,aAAc3mB,KAAK2mB,eAErBkW,OAAQ,IAAI9M,EAAW,CACrBzI,QAAStnB,KACT2mB,aAAc3mB,KAAK2mB,aACnBY,eAAgBvnB,KAAKunB,iBAEvBsa,QAAS,IAAIhO,EAAY,CACvBvM,QAAStnB,KACT2mB,aAAc3mB,KAAK2mB,eAErBmb,QAAS,IAAItJ,EAAY,CACvBlR,QAAStnB,KACT2mB,aAAc3mB,KAAK2mB,gBAKvB3mB,KAAKy1B,gBAAkB,IAAI+H,EAAgB,CACzClW,QAAStnB,KACTqd,UAAWrd,KAAKgpB,SAAS2X,cACzBha,aAAc3mB,KAAK2mB,aACnBY,eAAgBvnB,KAAKunB,iBAIvBvnB,KAAKy1B,gBAAgB9N,WAGrB3nB,KAAKa,KAAK,oBAAqB,CAC7B+gC,MAAOv7B,OAAOC,KAAKtG,KAAK4hC,OACxBG,gBAAgB,GAEtB,CAME,oBAAAra,GAEE1nB,KAAK0kB,SAASvkB,GAAG,iBAAiB,EAAGib,cACnCpb,KAAKgiC,qBAAqB,CACxB98B,KAAM,gBACN6f,UAAW3J,EAAQ1B,GACnBuoB,YAAa7mB,EAAQpP,cAEvBhM,KAAKa,KAAK,gBAAiB,CAAEua,YAC7Bpb,KAAKma,SAASonB,SAAW,IAAI5nB,IAAM,IAGrC3Z,KAAK0kB,SAASvkB,GAAG,mBAAmB,EAAGib,cACrCpb,KAAKgiC,qBAAqB,CACxB98B,KAAM,kBACN6f,UAAW3J,EAAQ1B,GACnBuoB,YAAa7mB,EAAQpP,cAEvBhM,KAAKa,KAAK,kBAAmB,CAAEua,YAC/Bpb,KAAKma,SAASonB,SAAW,IAAI5nB,IAAM,IAGrC3Z,KAAK0kB,SAASvkB,GAAG,mBAAmB,EAAGib,cACrCpb,KAAKgiC,qBAAqB,CACxB98B,KAAM,kBACN6f,UAAW3J,EAAQ1B,GACnBuoB,YAAa7mB,EAAQpP,YACrBk2B,aAAcliC,KAAKmiC,kBAAkB/mB,EAAQ1B,MAE/C1Z,KAAKa,KAAK,kBAAmB,CAAEua,YAC/Bpb,KAAKma,SAASonB,SAAW,IAAI5nB,IAAM,IAIrC3Z,KAAKmiC,kBAAoB,CAAE,EAC3BniC,KAAK0kB,SAASvkB,GAAG,4BAA4B,EAAGib,cAC9Cpb,KAAKmiC,kBAAkB/mB,EAAQ1B,IAAM0B,EAAQpP,WAAW,GAE9D,CAQE,YAAAo2B,CAAaC,EAAUr0B,EAAU,IAO/B,GALIhO,KAAKghC,YACPhhC,KAAK4hC,MAAM5hC,KAAKghC,YAAYjZ,cAIzB/nB,KAAK4hC,MAAMS,GAEd,OADAthC,QAAQG,MAAM,SAASmhC,iBAChB,EAIT,IAgBE,OAfAriC,KAAK4hC,MAAMS,GAAU1a,SAAS3Z,GAC9BhO,KAAKghC,WAAaqB,EAClBriC,KAAKihC,WAAaoB,EAGlBriC,KAAKkhC,UAAyB,YAAbmB,EACjBriC,KAAKmhC,UAAyB,YAAbkB,EACjBriC,KAAKohC,YAA2B,gBAAbiB,EAGnBriC,KAAKa,KAAK,iBAAkB,CAC1ByhC,KAAMD,EACNr0B,aAGK,CACR,CAAC,MAAO9M,GAEP,OADAH,QAAQG,MAAM,4BAA4BmhC,MAAcnhC,IACjD,CACb,CACA,CAME,oBAAA41B,GACE,IAAK92B,KAAKghC,WACR,OAAO,EAGT,IAaE,OAZAhhC,KAAK4hC,MAAM5hC,KAAKghC,YAAYjZ,aAG5B/nB,KAAKghC,WAAa,KAClBhhC,KAAKihC,WAAa,SAClBjhC,KAAKkhC,WAAY,EACjBlhC,KAAKmhC,WAAY,EACjBnhC,KAAKohC,aAAc,EAGnBphC,KAAKa,KAAK,qBAEH,CACR,CAAC,MAAOK,GAEP,OADAH,QAAQG,MAAM,6BAA8BA,IACrC,CACb,CACA,CAOE,oBAAA8gC,CAAqBhjB,GAEnBA,EAAOvE,UAAYd,KAAKC,MAGxB5Z,KAAK4gC,QAAQC,UAAUvgC,KAAK0e,GAG5Bhf,KAAK4gC,QAAQE,UAAY,GAGrB9gC,KAAK4gC,QAAQC,UAAU7zB,OAAShN,KAAK4gC,QAAQG,SAC/C/gC,KAAK4gC,QAAQC,UAAU0B,QAIzBviC,KAAKa,KAAK,iBAAkB,CAC1B2hC,QAASxiC,KAAK4gC,QAAQC,UAAU7zB,OAAS,EACzCy1B,QAASziC,KAAK4gC,QAAQE,UAAU9zB,OAAS,GAE/C,CAME,IAAA01B,GACE,GAAsC,IAAlC1iC,KAAK4gC,QAAQC,UAAU7zB,OACzB,OAAO,EAIT,MAAMgS,EAAShf,KAAK4gC,QAAQC,UAAU1gB,MAGtCngB,KAAK4gC,QAAQE,UAAUxgC,KAAK0e,GAG5B,IACE,OAAQA,EAAO9Z,MACf,IAAK,eACHlF,KAAK0kB,SAASG,cAAc7F,EAAO+F,WACnC,MACF,IAAK,iBACH/kB,KAAK0kB,SAASzJ,YAAY+D,EAAOijB,aACjC,MACF,IAAK,iBACH,GAAIjjB,EAAOkjB,aAAc,CACvB,MAAM9mB,EAAUpb,KAAK0kB,SAASO,WAAWjG,EAAO+F,WAC5C3J,IACFA,EAAQH,YAAY+D,EAAOkjB,aAAc,CAAES,QAAQ,IACnD3iC,KAAK0kB,SAAS0C,cAAchM,EAAS,CAAEunB,QAAQ,IAE3D,CACQ,MAEF,QACE5hC,QAAQ2D,KAAK,iCAAiCsa,EAAO9Z,QAWvD,OAPAlF,KAAKa,KAAK,iBAAkBme,GAC5Bhf,KAAKa,KAAK,kBAAmB,CAC3B2hC,QAASxiC,KAAK4gC,QAAQC,UAAU7zB,OAAS,EACzCy1B,QAASziC,KAAK4gC,QAAQE,UAAU9zB,OAAS,IAG3ChN,KAAKma,SAASonB,SAAW,IAAI5nB,MACtB,CACR,CAAC,MAAOzY,GAIP,OAFAlB,KAAK4gC,QAAQC,UAAUvgC,KAAKN,KAAK4gC,QAAQE,UAAU3gB,OACnDpf,QAAQG,MAAM,+BAAgCA,IACvC,CACb,CACA,CAME,IAAA0hC,GACE,GAAsC,IAAlC5iC,KAAK4gC,QAAQE,UAAU9zB,OACzB,OAAO,EAIT,MAAMgS,EAAShf,KAAK4gC,QAAQE,UAAU3gB,MAGtCngB,KAAK4gC,QAAQC,UAAUvgC,KAAK0e,GAG5B,IACE,OAAQA,EAAO9Z,MACf,IAAK,eACHlF,KAAK0kB,SAASzJ,YAAY+D,EAAOijB,aACjC,MACF,IAAK,iBACHjiC,KAAK0kB,SAASG,cAAc7F,EAAO+F,WACnC,MACF,IAAK,iBACH,MAAM3J,EAAUpb,KAAK0kB,SAASO,WAAWjG,EAAO+F,WAC5C3J,IACFA,EAAQH,YAAY+D,EAAOijB,YAAa,CAAEU,QAAQ,IAClD3iC,KAAK0kB,SAAS0C,cAAchM,EAAS,CAAEunB,QAAQ,KAEjD,MAEF,QACE5hC,QAAQ2D,KAAK,iCAAiCsa,EAAO9Z,QAWvD,OAPAlF,KAAKa,KAAK,iBAAkBme,GAC5Bhf,KAAKa,KAAK,kBAAmB,CAC3B2hC,QAASxiC,KAAK4gC,QAAQC,UAAU7zB,OAAS,EACzCy1B,QAASziC,KAAK4gC,QAAQE,UAAU9zB,OAAS,IAG3ChN,KAAKma,SAASonB,SAAW,IAAI5nB,MACtB,CACR,CAAC,MAAOzY,GAIP,OAFAlB,KAAK4gC,QAAQE,UAAUxgC,KAAKN,KAAK4gC,QAAQC,UAAU1gB,OACnDpf,QAAQG,MAAM,+BAAgCA,IACvC,CACb,CACA,CAOE,SAAA2hC,CAAUnrB,EAAW,IACnB,MAAMorB,EAAa,CACjB3oB,SAAU,IAAKna,KAAKma,UACpBuK,SAAU1kB,KAAK0kB,SAAS1Y,YACxBgd,SAAU,IAAKhpB,KAAKgpB,WAStB,OALA8Z,EAAW3oB,SAASonB,SAAW,IAAI5nB,KAGnC3Z,KAAKa,KAAK,eAAgBiiC,GAEnBA,CACX,CAQE,SAAAC,CAAUD,EAAYprB,EAAW,IAC/B,IAAKorB,IAAeA,EAAWpe,SAE7B,OADA3jB,QAAQG,MAAM,+BACP,EAGT,IA8BE,OA5BAlB,KAAK0kB,SAASpiB,QACdtC,KAAKirB,gBAAgB3oB,QACrBtC,KAAKy5B,iBAAiBn3B,QAGlBwgC,EAAW3oB,WACbna,KAAKma,SAAW,IAAK2oB,EAAW3oB,UAGhCna,KAAKma,SAASmnB,QAAU,IAAI3nB,KAAK3Z,KAAKma,SAASmnB,SAC/CthC,KAAKma,SAASonB,SAAW,IAAI5nB,KAAK3Z,KAAKma,SAASonB,WAI9CuB,EAAW9Z,WACbhpB,KAAKgpB,SAAW3iB,OAAOwhB,OAAO7nB,KAAKgpB,SAAU8Z,EAAW9Z,WAI1DhpB,KAAK0kB,SAASzJ,YAAY6nB,EAAWpe,UAGrC1kB,KAAK4gC,QAAQC,UAAY,GACzB7gC,KAAK4gC,QAAQE,UAAY,GAGzB9gC,KAAKa,KAAK,gBAAiBiiC,IAEpB,CACR,CAAC,MAAO5hC,GAEP,OADAH,QAAQG,MAAM,6BAA8BA,IACrC,CACb,CACA,CAME,mBAAA2kB,GACE,OAAO7lB,KAAKy5B,iBAAiBtU,gBACjC,CAUE,aAAA6W,CAAc5gB,EAASpN,EAAU,IAC/B,MAAMg1B,EAAgC,iBAAZ5nB,EACtBpb,KAAK0kB,SAASO,WAAW7J,GACzBA,EAEJ,IAAK4nB,EACH,OAAO,EAIT,MAAM5H,EAAap7B,KAAKy5B,iBAAiBvU,WAAW8d,EAAWtpB,IAG/D,OAAI1L,EAAQi1B,QAAU7H,EACbp7B,KAAKkjC,gBAAgBF,IAIzBh1B,EAAQm1B,gBACXnjC,KAAKojC,iBAIHhI,IAKJp7B,KAAKy5B,iBAAiB9U,WAAWqe,GAGjCA,EAAWnnB,SAGX7b,KAAKa,KAAK,mBAAoB,CAAEua,QAAS4nB,MAVhC,EAab,CAOE,eAAAE,CAAgB9nB,GACd,MAAM4nB,EAAgC,iBAAZ5nB,EACtBpb,KAAK0kB,SAASO,WAAW7J,GACzBA,EAEJ,QAAK4nB,KAKAhjC,KAAKy5B,iBAAiBvU,WAAW8d,EAAWtpB,MAKjD1Z,KAAKy5B,iBAAiB5U,cAAcme,GAGpCA,EAAWlnB,WAGX9b,KAAKa,KAAK,qBAAsB,CAAEua,QAAS4nB,KAEpC,GACX,CAKE,cAAAI,GAEE,MAAM3J,EAAmBz5B,KAAKy5B,iBAAiBtU,iBAG/CnlB,KAAKy5B,iBAAiBn3B,QAGtBm3B,EAAiBx4B,SAAQma,IACvBA,EAAQU,UAAU,IAIhB2d,EAAiBzsB,OAAS,GAC5BhN,KAAKa,KAAK,oBAAqB,CAAE6jB,SAAU+U,GAEjD,CAQE,wBAAMzN,CAAmBtH,GAEvB,MAAM2e,EAAe1mB,MAAMC,QAAQ8H,GAAYA,EAAW,CAACA,GAE3D,GAA4B,IAAxB2e,EAAar2B,OACf,OAAOrI,QAAQC,QAAQ,IAIzB,IAAK5E,KAAKgpB,SAASpZ,SACjB,OAAOjL,QAAQC,QAAQy+B,GAGzB,IAEE,GAAwC,iBAApCrjC,KAAKgpB,SAAS0X,mBACd1gC,KAAK2mB,cACqC,mBAAnC3mB,KAAK2mB,aAAa2c,aAA6B,CAGxD,IAAK,MAAMloB,KAAWioB,EACpB,IAEE,OAAQjoB,EAAQlW,MAChB,IAAK,QACH,MAAM43B,EAAa1hB,EAAQyB,gBAE3B,IAAKigB,EAAW75B,UAAW,CACzB,MAAMA,QAAkBjD,KAAK2mB,aAAa2c,aAAaxG,GACvDA,EAAWzwB,KAAKpJ,EAChC,CACc,MAEF,IAAK,OACH,MAAM24B,EAAaxgB,EAAQuD,iBAE3B,IAAK,MAAMxQ,KAASytB,EAClB,IAAKztB,EAAMlL,UAAW,CACpB,MAAMA,QAAkBjD,KAAK2mB,aAAa2c,aAAan1B,GACvDA,EAAM9B,KAAKpJ,EAC7B,CAEcmY,EAAQwD,eAAegd,GACvB,MAEF,IAAK,UACH,MAAMvZ,EAAQjH,EAAQ8G,WAEtB,IAAK,MAAMpC,KAAQuC,EACjB,IAAK,MAAMlU,KAAS2R,EAClB,IAAK3R,EAAMlL,UAAW,CACpB,MAAMA,QAAkBjD,KAAK2mB,aAAa2c,aAAan1B,GACvDA,EAAM9B,KAAKpJ,EAC/B,CAGcmY,EAAQgH,SAASC,GAKfriB,KAAK0kB,SAASQ,WAAW9J,EAAQ1B,KACnC1Z,KAAK0kB,SAAS0C,cAAchM,EAE/B,CAAC,MAAOla,GACPH,QAAQG,MAAM,uCAAuCka,EAAQ1B,MAAOxY,EAChF,CAMQ,OAFAlB,KAAKa,KAAK,yBAA0B,CAAE6jB,SAAU2e,IAEzCA,CACf,CAEQ,OADAtiC,QAAQ2D,KAAK,yCACN2+B,CAEV,CAAC,MAAOniC,GAEP,OADAH,QAAQG,MAAM,iCAAkCA,GACzCmiC,CACb,CACA,CAQE,iBAAAE,CAAkBC,EAAYx1B,EAAU,IACtC,IAAKw1B,EAEH,OADAziC,QAAQG,MAAM,iCACP,EAGT,IAgCE,OA9BAlB,KAAKwjC,WAAaA,EAGlBxjC,KAAKyjC,YAAcp9B,OAAOwhB,OAAO,CAC/B6b,qBAAqB,EACrBC,uBAAuB,EACvBC,2BAA4B,CAC1B9Y,MAAO,UACPtF,KAAM,GACNqF,aAAc,UACdE,aAAc,GAEhB8Y,gBAAgB,EAChBC,kBAAkB,GACjB91B,GAGHhO,KAAK+jC,0BAGD/jC,KAAKyjC,YAAYE,uBAAyB3jC,KAAK2mB,cACjD3mB,KAAKgkC,wBAIPhkC,KAAKa,KAAK,iBAAkB,CAC1B2iC,WAAYxjC,KAAKwjC,WACjBx1B,QAAShO,KAAKyjC,eAGT,CACR,CAAC,MAAOviC,GAEP,OADAH,QAAQG,MAAM,gCAAiCA,IACxC,CACb,CACA,CAME,uBAAA6iC,GACO/jC,KAAKwjC,YAAexjC,KAAKwjC,WAAWvjC,QAA+C,mBAA9BD,KAAKwjC,WAAWvjC,OAAOE,IAMjFH,KAAKwjC,WAAWvjC,OAAOE,GAAG,YAAastB,IACrCztB,KAAKikC,sBAAsBxW,EAAS,IAItCztB,KAAKwjC,WAAWvjC,OAAOE,GAAG,wBAAyBW,IACjDd,KAAKa,KAAK,wBAAyBC,EAAK,IAG1Cd,KAAKwjC,WAAWvjC,OAAOE,GAAG,2BAA2B,KACnDH,KAAKa,KAAK,2BAA2B,IAGvCb,KAAKwjC,WAAWvjC,OAAOE,GAAG,oBAAqBe,IAC7ClB,KAAKa,KAAK,oBAAqBK,EAAM,IAIvClB,KAAKwjC,WAAWvjC,OAAOE,GAAG,mBAAoBW,IAC5Cd,KAAKa,KAAK,uBAAwBC,EAAK,IAGzCd,KAAKwjC,WAAWvjC,OAAOE,GAAG,sBAAsB,KAC9CH,KAAKa,KAAK,0BAA0B,IAGtCb,KAAKwjC,WAAWvjC,OAAOE,GAAG,eAAgBe,IACxClB,KAAKa,KAAK,mBAAoBK,EAAM,KAhCpCH,QAAQ2D,KAAK,sCAkCnB,CAOE,qBAAAu/B,CAAsBxW,GACfA,GAAaA,EAAS7iB,UAAa6iB,EAAS5iB,YAKjD7K,KAAKkkC,gBAAkBzW,EAGnBztB,KAAKyjC,YAAYE,uBAAyB3jC,KAAKmkC,gBAAkBnkC,KAAK2mB,cACxE3mB,KAAKokC,sBAAsB3W,GAIzBztB,KAAKyjC,YAAYC,qBAAuB1jC,KAAK2mB,cAC/C3mB,KAAK2mB,aAAa0d,UAAU,CAC1BthC,IAAK0qB,EAAS7iB,SACdlI,IAAK+qB,EAAS5iB,YAKlB7K,KAAKa,KAAK,wBAAyB4sB,GACvC,CAME,qBAAAuW,GACOhkC,KAAK2mB,eAGN3mB,KAAKmkC,iBAKLnkC,KAAK2mB,cAA0D,mBAAnC3mB,KAAK2mB,aAAa2d,eAChDtkC,KAAKmkC,eAAiBnkC,KAAK2mB,aAAa2d,aAAa,CACnDvhC,IAAK,EACLL,IAAK,GACJ,IACE1C,KAAKyjC,YAAYG,2BACpBvpB,SAAS,EACTkqB,OAAQ,OAKRvkC,KAAKyjC,YAAYI,gBAA4D,mBAAnC7jC,KAAK2mB,aAAa3V,eAC9DhR,KAAK6jC,eAAiB7jC,KAAK2mB,aAAa3V,aAAa,CACnDjO,IAAK,EACLL,IAAK,GACJ,EAAG,CACJ4mB,UAAW,0BACXC,YAAa,UACbib,aAAc,EACdnqB,SAAS,EACTkqB,OAAQ,QAGhB,CAOE,qBAAAH,CAAsB3W,GACpB,IAAKA,IAAaA,EAAS7iB,WAAa6iB,EAAS5iB,UAC/C,OAIF,MAAMoP,EAAQja,KAAKykC,2BAA2BhX,EAASiX,SAGnD1kC,KAAKmkC,iBACPnkC,KAAKmkC,eAAeQ,YAAY,CAC9B5hC,IAAK0qB,EAAS7iB,SACdlI,IAAK+qB,EAAS5iB,YAG4B,mBAAjC7K,KAAKmkC,eAAehpB,UAC7Bnb,KAAKmkC,eAAehpB,SAASlB,GAGe,mBAAnCja,KAAKmkC,eAAeS,YAC7B5kC,KAAKmkC,eAAeS,YAAW,IAK/B5kC,KAAK6jC,gBAAkBpW,EAASoX,WAClC7kC,KAAK6jC,eAAeQ,UAAU,CAC5BthC,IAAK0qB,EAAS7iB,SACdlI,IAAK+qB,EAAS5iB,YAGhB7K,KAAK6jC,eAAeiB,UAAUrX,EAASoX,UAEO,mBAAnC7kC,KAAK6jC,eAAee,YAC7B5kC,KAAK6jC,eAAee,YAAW,GAGvC,CAQE,0BAAAH,CAA2BC,GACzB,MAAMK,EAAY,IAAK/kC,KAAKyjC,YAAYG,4BAGxC,OAAQc,GACR,KAAK,EACHK,EAAUja,MAAQ,UAClB,MAEF,KAAK,EACHia,EAAUja,MAAQ,UAClB,MAEF,KAAK,EACHia,EAAUja,MAAQ,UAClB,MAEF,KAAK,EACHia,EAAUja,MAAQ,UAClB,MAGF,QACEia,EAAUja,MAAQ,UAIpB,OAAOia,CACX,CAOE,yBAAMC,CAAoBh3B,EAAU,IAClC,IAAKhO,KAAKwjC,aAAexjC,KAAKkkC,gBAE5B,OADAnjC,QAAQ2D,KAAK,8BACN,KAGT,MAAM+oB,EAAWztB,KAAKkkC,gBAEtB,IAEE,MAAMznB,aAAEA,SAAuB9X,QAAqCC,UAAA0U,MAAA,WAAA,OAAA2rB,CAAA,KAC9D5hC,WAAEA,SAAqBsB,QAA+BC,UAAA0U,MAAA,WAAA,OAAA4rB,CAAA,IAGtDtiC,EAAa,IAAIS,EACrBoqB,EAAS7iB,SACT6iB,EAAS5iB,UACT4iB,EAAS3iB,UAAY,GAIjBmP,EAAQja,KAAKykC,2BAA2BhX,EAASiX,SAgBjDtpB,EAAU,IAAIqB,EAAa7Z,EAbVyD,OAAOwhB,OAAO,CACnC9N,KAAM,eAAc,IAAIJ,MAAOwrB,uBAC/BjrB,WAAY,CACVxW,OAAQ,OACRghC,QAASjX,EAASiX,QAClBU,WAAY3X,EAAS2X,WACrBP,SAAUpX,EAASoX,SACnBpqB,UAAWgT,EAAShT,YAAa,IAAId,MAAO0rB,eAE9CprB,SACCjM,IAcH,OARAhO,KAAK0kB,SAASC,WAAWvJ,GAGzBpb,KAAKa,KAAK,yBAA0B,CAClCua,UACAqS,aAGKrS,CACR,CAAC,MAAOla,GAEP,OADAH,QAAQG,MAAM,iCAAkCA,GACzC,IACb,CACA,CAME,oBAAAokC,GACE,IAAKtlC,KAAKwjC,WACR,OAAO,EAGT,IA0BE,OAxBIxjC,KAAKmkC,iBACmC,mBAA/BnkC,KAAKmkC,eAAeoB,QAC7BvlC,KAAKmkC,eAAeoB,OAAO,MAE7BvlC,KAAKmkC,eAAiB,MAIpBnkC,KAAK6jC,iBACmC,mBAA/B7jC,KAAK6jC,eAAe0B,QAC7BvlC,KAAK6jC,eAAe0B,OAAO,MAE7BvlC,KAAK6jC,eAAiB,MAIxB7jC,KAAKkkC,gBAAkB,KAGvBlkC,KAAKwjC,WAAa,KAGlBxjC,KAAKa,KAAK,sBAEH,CACR,CAAC,MAAOK,GAEP,OADAH,QAAQG,MAAM,mCAAoCA,IAC3C,CACb,CACA,CAKE,OAAAmnB,GAEMroB,KAAKwjC,YACPxjC,KAAKslC,uBAIPtlC,KAAK82B,uBAGL92B,KAAKqB,qBAGLgF,OAAO2D,OAAOhK,KAAK4hC,OAAO3gC,SAAQqhC,IACJ,mBAAjBA,EAAKja,SACdia,EAAKja,SACb,IAIIroB,KAAK0kB,SAASpiB,QACdtC,KAAKirB,gBAAgB3oB,QACrBtC,KAAKy5B,iBAAiBn3B,QAGtBtC,KAAK4gC,QAAQC,UAAY,GACzB7gC,KAAK4gC,QAAQE,UAAY,GAGzB9gC,KAAKa,KAAK,YAAa,CAAEymB,QAAStnB,MACtC,EC//BO,SAASwlC,EAAY5iC,EAAYoL,EAAU,IAChD,MAAMyO,aAAEA,GAAiBgpB,QAAQ,qBACjC,OAAO,IAAIhpB,EAAa7Z,EAAYoL,EACtC,CAQO,SAAS03B,EAAWx5B,EAAa8B,EAAU,IAChD,MAAMmQ,YAAEA,GAAgBsnB,QAAQ,oBAChC,OAAO,IAAItnB,EAAYjS,EAAa8B,EACtC,CAQO,SAAS23B,EAAcz5B,EAAa8B,EAAU,IACnD,MAAMuT,eAAEA,GAAmBkkB,QAAQ,uBACnC,OAAO,IAAIlkB,EAAerV,EAAa8B,EACzC,CAQO,SAAS43B,EAAwBlhB,EAAW,GAAI1W,EAAU,CAAA,GAC/D,MAAMyW,kBAAEA,GAAsBghB,QAAQ,0BACtC,OAAO,IAAIhhB,EAAkBC,EAAU1W,EACzC,CAQO,SAAS63B,EAAkBjoB,EAAS5P,EAAU,IACnD,IAAK4P,EAAS,MAAO,GAGrB,GAAqB,sBAAjBA,EAAQ1Y,MAAgCyX,MAAMC,QAAQgB,EAAQ8G,UAChE,OAAO9G,EAAQ8G,SAAS3S,KAAIqJ,GACnB0qB,EAA0B1qB,EAASpN,KACzCzN,OAAOwlC,SAIZ,GAAqB,YAAjBnoB,EAAQ1Y,KAAoB,CAC9B,MAAMkW,EAAU0qB,EAA0BloB,EAAS5P,GACnD,OAAOoN,EAAU,CAACA,GAAW,EACjC,CAGE,GAAIwC,EAAQ1Y,MAAQ0Y,EAAQ1R,YAAa,CAEvC,MAAMkP,EAAU0qB,EAA0B,CACxC5gC,KAAM,UACN2Y,SAAUD,GACT5P,GACH,OAAOoN,EAAU,CAACA,GAAW,EACjC,CAEE,MAAO,EACT,CASA,SAAS0qB,EAA0BloB,EAAS5P,EAAU,IACpD,IAAK4P,IAAYA,EAAQC,WAAaD,EAAQC,SAAS3Y,KACrD,OAAO,KAGT,IAAIkW,EAEJ,OAAQwC,EAAQC,SAAS3Y,MACzB,IAAK,QACHkW,EAAUoqB,EAAY,GAAI,CAAE9rB,GAAIkE,EAAQlE,KACxC,MAEF,IAAK,aACH0B,EAAUsqB,EAAW,GAAI,CAAEhsB,GAAIkE,EAAQlE,KACvC,MAEF,IAAK,UACH0B,EAAUuqB,EAAc,GAAI,CAAEjsB,GAAIkE,EAAQlE,KAC1C,MAEF,QAEE,OADA3Y,QAAQ2D,KAAK,sCAAsCkZ,EAAQC,SAAS3Y,QAC7D,KAOT,OAJIkW,GACFA,EAAQH,YAAY2C,EAAS5P,GAGxBoN,CACT,CChIO,MAAM4qB,EAKX,WAAAjmC,CAAYiO,EAAU,IACpB,GAAIhO,KAAKD,cAAgBimC,EACvB,MAAM,IAAIvkC,MAAM,kEAGlBzB,KAAKgO,QAAUA,CACnB,CAOE,SAAAusB,CAAU0L,GACR,MAAM,IAAIxkC,MAAM,4CACpB,CAOE,gBAAMykC,CAAWC,GACf,MAAM,IAAI1kC,MAAM,6CACpB,CAOE,eAAM4iC,CAAUtiC,GACd,MAAM,IAAIN,MAAM,4CACpB,CAOE,aAAM2kC,CAAQC,GACZ,MAAM,IAAI5kC,MAAM,0CACpB,CAQE,eAAM6kC,CAAUvkC,EAAa2V,EAAW,IACtC,MAAM,IAAIjW,MAAM,4CACpB,CAOE,kBAAM8kC,CAAaC,GACjB,MAAM,IAAI/kC,MAAM,+CACpB,CAQE,iBAAMglC,CAAYC,EAAchvB,EAAW,IACzC,MAAM,IAAIjW,MAAM,8CACpB,CAOE,oBAAMklC,CAAeC,GACnB,MAAM,IAAInlC,MAAM,iDACpB,CAQE,gBAAMolC,CAAWH,EAAchvB,EAAW,IACxC,MAAM,IAAIjW,MAAM,6CACpB,CAOE,mBAAMqlC,CAAcC,GAClB,MAAM,IAAItlC,MAAM,gDACpB,CAME,eAAMmZ,GACJ,MAAM,IAAInZ,MAAM,4CACpB,CAQE,eAAMulC,CAAUC,EAASvvB,EAAW,IAClC,MAAM,IAAIjW,MAAM,4CACpB,CAQE,sBAAMhB,CAAiBymC,EAAYC,GACjC,MAAM,IAAI1lC,MAAM,mDACpB,CAQE,yBAAML,CAAoB8lC,EAAYE,GACpC,MAAM,IAAI3lC,MAAM,sDACpB,CAOE,kBAAM6hC,CAAavhC,GACjB,MAAM,IAAIN,MAAM,+CACpB,CAOE,0BAAM4lC,CAAqBX,GACzB,MAAM,IAAIjlC,MAAM,uDACpB,CAOE,iBAAAqlB,CAAkB/kB,GAChB,MAAM,IAAIN,MAAM,oDACpB,CAOE,iBAAA6lC,CAAkBC,GAChB,MAAM,IAAI9lC,MAAM,oDACpB,EChLO,MAAM+lC,UAAuBxB,EAKlC,WAAAjmC,CAAYiO,EAAU,IAGpB,GAFAlJ,MAAMkJ,GAEFhO,KAAKD,cAAgBynC,EACvB,MAAM,IAAI/lC,MAAM,mEAEtB,CAOE,aAAMgmC,CAAQC,GACZ,MAAM,IAAIjmC,MAAM,0CACpB,CAOE,gBAAMkmC,CAAWD,GACf,MAAM,IAAIjmC,MAAM,6CACpB,CAME,uBAAMmmC,GACJ,MAAM,IAAInmC,MAAM,oDACpB,CAWE,uBAAMomC,CAAkBC,GACtB,MAAM,IAAIrmC,MAAM,oDACpB,CAQE,cAAMsmC,CAAShmC,EAAa2V,EAAW,IACrC,MAAM,IAAIjW,MAAM,2CACpB,CAOE,iBAAMumC,CAAYC,GAChB,MAAM,IAAIxmC,MAAM,8CACpB,CAOE,gBAAMymC,CAAWxwB,EAAW,IAC1B,MAAM,IAAIjW,MAAM,6CACpB,CAME,mBAAM0mC,GACJ,MAAM,IAAI1mC,MAAM,gDACpB,CAOE,4BAAM2mC,CAAuBC,GAC3B,MAAM,IAAI5mC,MAAM,yDACpB,ECjGO,MAAM6mC,EAKX,WAAAvoC,CAAYiO,EAAU,IACpB,GAAIhO,KAAKD,cAAgBuoC,EACvB,MAAM,IAAI7mC,MAAM,sEAGlBzB,KAAKgO,QAAUA,CACnB,CAOE,kBAAMs1B,CAAavhC,GACjB,MAAM,IAAIN,MAAM,+CACpB,CAOE,0BAAM4lC,CAAqBX,GACzB,MAAM,IAAIjlC,MAAM,uDACpB,CAOE,+BAAM8mC,CAA0B7B,GAC9B,MAAM,IAAIjlC,MAAM,4DACpB,ECnCO,MAAM+mC,UAA0BxC,EAOrC,WAAAjmC,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAGNhO,KAAK+R,IAAM/D,EAAQy6B,aAAe,KAClCzoC,KAAK0oC,UAAyB,OAAb1oC,KAAK+R,KAAiB42B,OAAOC,QAAUD,OAAOC,OAAOC,KACtE7oC,KAAK8oC,OAAS96B,EAAQ86B,OACtB9oC,KAAK+oC,WAAa/6B,EAAQ+6B,YAAc,CACtCt4B,OAAQ,CAAE1N,IAAK,EAAGL,IAAK,GACvBsmC,KAAM,EACNC,UAAW,SACXC,gBAAgB,EAChBC,mBAAmB,EACnBC,mBAAmB,GAKrBppC,KAAKqpC,eAAiB,IAAI1nC,GAC9B,CAOE,SAAA44B,CAAU+O,GACHtpC,KAAK+R,MAGV/R,KAAK+R,IAAIw3B,SAAStvB,MAAMuvB,OAASF,EACrC,CAOE,wBAAMG,GACJ,IAAId,OAAOC,SAAUD,OAAOC,OAAOC,KAAnC,CAKA,IAAK7oC,KAAK8oC,OACR,MAAM,IAAIrnC,MAAM,sDAGlB,OAAO,IAAIkD,SAAQ,CAACC,EAAS8kC,KAC3B,MAAMC,EAAe,sBAAsBhwB,KAAKC,QAChD+uB,OAAOgB,GAAgB,KACrB3pC,KAAK0oC,WAAY,SACVC,OAAOgB,GACd/kC,GAAS,EAGX,MAAMglC,EAAStf,SAASuf,cAAc,UACtCD,EAAOE,IAAM,+CAA+C9pC,KAAK8oC,mBAAmBa,8BACpFC,EAAOzwB,OAAQ,EACfywB,EAAOG,OAAQ,EACfH,EAAOI,QAAU,IAAMN,EAAO,IAAIjoC,MAAM,mCACxC6oB,SAAS2f,KAAKC,YAAYN,EAAO,GAnBvC,CAFM5pC,KAAK0oC,WAAY,CAuBvB,CAOE,gBAAMxC,CAAWiE,GAEf,GAAInqC,KAAK+R,IACP,OAAOpN,QAAQC,gBAGX5E,KAAKypC,qBAEX,MAAMW,EAA+B,iBAAdD,EACnB7f,SAAS+f,eAAeF,GACxBA,EAEJ,IAAKC,EACH,MAAM,IAAI3oC,MAAM,oCAAoC0oC,KAMtD,OAHAnqC,KAAK+R,IAAM,IAAI62B,OAAOC,KAAKlnC,IAAIyoC,EAASpqC,KAAK+oC,YAGtC,IAAIpkC,SAASC,IAClBgkC,OAAOC,KAAKzoC,MAAMkqC,gBAAgBtqC,KAAK+R,IAAK,QAAQ,KAClDnN,GAAS,GACT,GAER,CAQE,SAAA2lC,CAAU3nC,GACR,OAAO,IAAIgmC,OAAOC,KAAK2B,OAAO5nC,EAAWG,IAAKH,EAAWF,IAC7D,CASE,aAAA+nC,CAAcpV,EAAQpyB,EAAY,MAEhC,MAAMwH,EAAgBxH,QAAgDA,EAAY,EAClF,OAAO,IAAII,EAAWgyB,EAAOtyB,MAAOsyB,EAAO3yB,MAAO+H,EACtD,CAOE,eAAM45B,CAAUzhC,GACd,IAAK5C,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,OADAzB,KAAK+R,IAAIsyB,UAAUrkC,KAAKuqC,UAAU3nC,IAC3B+B,QAAQC,SACnB,CAOE,aAAMwhC,CAAQsE,GACZ,IAAK1qC,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,OADAzB,KAAK+R,IAAIq0B,QAAQsE,GACV/lC,QAAQC,SACnB,CAQE,eAAM0hC,CAAU1jC,EAAYoL,EAAU,IACpC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAMkpC,EAAgB,CACpBld,SAAUztB,KAAKuqC,UAAU3nC,GACzBmP,IAAK/R,KAAK+R,IACV64B,MAAO58B,EAAQ48B,OAAS,GACxBxf,MAAOpd,EAAQod,OAAS,KACxByf,KAAM78B,EAAQ68B,MAAQ,KACtBC,UAAW98B,EAAQ88B,YAAa,EAChCvG,OAAQv2B,EAAQu2B,QAAU,QACvBv2B,EAAQ28B,eAGPI,EAAS,IAAInC,OAAOC,KAAKmC,OAAOL,GAKtC,OAFAI,EAAO9nC,UAAYL,EAAWK,UAEvB0B,QAAQC,QAAQmmC,EAC3B,CAOE,kBAAMxE,CAAawE,GACjB,OAAKA,GAILA,EAAOxF,OAAO,MACP5gC,QAAQC,WAJND,QAAQC,SAKrB,CAQE,iBAAM6hC,CAAYv6B,EAAa8B,EAAU,IACvC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAEMwpC,EAAkB,CACtBC,KAHWh/B,EAAY6F,KAAI5D,GAASnO,KAAKuqC,UAAUp8B,KAInD4D,IAAK/R,KAAK+R,IACVwX,YAAavb,EAAQub,aAAe,UACpC4hB,cAAen9B,EAAQm9B,eAAiB,EACxC3G,aAAcx2B,EAAQw2B,cAAgB,KACnCx2B,EAAQi9B,iBAGPG,EAAW,IAAIxC,OAAOC,KAAKwC,SAASJ,GAK1C,OAFAG,EAASE,oBAAsB,IAAIp/B,GAE5BvH,QAAQC,QAAQwmC,EAC3B,CAOE,oBAAMzE,CAAeyE,GACnB,OAAKA,GAILA,EAAS7F,OAAO,MACT5gC,QAAQC,WAJND,QAAQC,SAKrB,CAQE,gBAAMiiC,CAAW36B,EAAa8B,EAAU,IACtC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAEM8pC,EAAiB,CACrBC,MAHWt/B,EAAY6F,KAAI5D,GAASnO,KAAKuqC,UAAUp8B,KAInD4D,IAAK/R,KAAK+R,IACVwX,YAAavb,EAAQub,aAAe,UACpC4hB,cAAen9B,EAAQm9B,eAAiB,GACxC3G,aAAcx2B,EAAQw2B,cAAgB,EACtClb,UAAWtb,EAAQsb,WAAa,UAChCmiB,YAAaz9B,EAAQy9B,aAAe,OACjCz9B,EAAQu9B,gBAGP55B,EAAU,IAAIi3B,OAAOC,KAAK6C,QAAQH,GAKxC,OAFA55B,EAAQ25B,oBAAsB,IAAIp/B,GAE3BvH,QAAQC,QAAQ+M,EAC3B,CAOE,mBAAMm1B,CAAcn1B,GAClB,OAAKA,GAILA,EAAQ4zB,OAAO,MACR5gC,QAAQC,WAJND,QAAQC,SAKrB,CAME,eAAMgW,GACJ,IAAK5a,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAM6kB,EAAStmB,KAAK+R,IAAI6I,YACxB,IAAK0L,EACH,OAAO3hB,QAAQC,QAAQ,MAGzB,MAAM+mC,EAAKrlB,EAAOslB,eACZC,EAAKvlB,EAAOwlB,eAElB,OAAOnnC,QAAQC,QAAQ,CACrBY,MAAOmmC,EAAG5oC,MACVka,KAAM0uB,EAAGjpC,MACTwa,MAAO2uB,EAAG9oC,MACVoa,KAAM0uB,EAAGnpC,MACTqa,UAAW/c,KAAKyqC,cAAckB,GAC9B3uB,UAAWhd,KAAKyqC,cAAcoB,IAEpC,CAQE,eAAM7E,CAAU1gB,EAAQtY,EAAU,IAChC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,IAAIsqC,EAEJ,GAAIzlB,EAAOvJ,WAAauJ,EAAOtJ,UAC7B+uB,EAAe,IAAInD,OAAOC,KAAKmD,aAC7BhsC,KAAKuqC,UAAUjkB,EAAOtJ,WACtBhd,KAAKuqC,UAAUjkB,EAAOvJ,iBAEnB,GAAIuJ,EAAO9gB,OAAS8gB,EAAOpJ,OAASoJ,EAAOrJ,MAAQqJ,EAAOnJ,KAC/D4uB,EAAe,IAAInD,OAAOC,KAAKmD,aAC7B,IAAIpD,OAAOC,KAAK2B,OAAOlkB,EAAOpJ,MAAOoJ,EAAOnJ,MAC5C,IAAIyrB,OAAOC,KAAK2B,OAAOlkB,EAAO9gB,MAAO8gB,EAAOrJ,WAEzC,KAAIN,MAAMC,QAAQ0J,GAOvB,MAAM,IAAI7kB,MAAM,yBALhBsqC,EAAe,IAAInD,OAAOC,KAAKmD,aAC/B1lB,EAAOrlB,SAAQkN,IACb49B,EAAaE,OAAOjsC,KAAKuqC,UAAUp8B,GAAO,GAIlD,CAEI,MAAM+9B,EAAa,CACjBC,QAASn+B,EAAQm+B,SAAW,KACzBn+B,EAAQk+B,YAIb,OADAlsC,KAAK+R,IAAIi1B,UAAU+E,EAAcG,GAC1BvnC,QAAQC,SACnB,CAQE,sBAAMnE,CAAiB2rC,EAAW/rC,GAChC,IAAKL,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,MAAM4qC,EAAgC,gBAAdD,EAA8B,aAAeA,EAGrE,IAAIE,EAAe,EAKnB,IAAIC,EAAgB,EACpB,MAEMC,EAAS5D,OAAOC,KAAKzoC,MAAMqsC,YAAYzsC,KAAK+R,IAAKs6B,GAAiBjsC,IAEtE,GAAkB,UAAdgsC,GAAuC,aAAdA,EAA0B,CACrD,MAAMxyB,EAAMD,KAAKC,MACjB,GAAIA,EAAM2yB,EANY,IASpB,YADAxrC,QAAQk1B,MAAM,aAAamW,sCAO7B,GAJAG,EAAgB3yB,EAIZxZ,EAAMssC,SAAWtsC,EAAMgb,QAIzB,YAFAra,QAAQk1B,MAAM,+CAIxB,CAGM,GAAkB,cAAdmW,EAA2B,CAC7B,MAAMxyB,EAAMD,KAAKC,MACjB,GAAIA,EAAM0yB,EA/BW,GAgCnB,OAEFA,EAAe1yB,CACvB,CAKM,MAAM+yB,EAA0B,CAC9BjhB,eAAgB,WAEVtrB,EAAMwsC,UAAqD,mBAAlCxsC,EAAMwsC,SAASlhB,gBAC1CtrB,EAAMwsC,SAASlhB,gBAElB,EACDmhB,gBAAiB,WAEXzsC,EAAMwsC,UAAsD,mBAAnCxsC,EAAMwsC,SAASC,iBAC1CzsC,EAAMwsC,SAASC,iBAElB,EAEDD,SAAUxsC,EAAMwsC,UAAY,QAEzBxsC,GAGC0sC,EAAiB,CACrB5nC,KAAMknC,EACN3gB,cAAekhB,GAIjB,GAAIvsC,EAAMi1B,OAAQ,CAEE,UAAd+W,GAAuC,aAAdA,GAA0C,gBAAdA,GAEvDU,EAAelqC,WAAa5C,KAAKyqC,cAAcrqC,EAAMi1B,QAGrDt0B,QAAQC,IAAI,eAAeorC,WACzB,GAAGhsC,EAAMi1B,OAAOtyB,MAAMC,QAAQ,OAAO5C,EAAMi1B,OAAO3yB,MAAMM,QAAQ,KAChE5C,EAAMwsC,SAAW,cAAcxsC,EAAMwsC,SAAS1nC,OAAS,KAGzD4nC,EAAelqC,WAAa,CAC1BG,IAAK3C,EAAMi1B,OAAOtyB,MAClBL,IAAKtC,EAAMi1B,OAAO3yB,MAClBO,UAAW,GAKf6pC,EAAezX,OAASj1B,EAAMi1B,OAG9B,IACE,GAAIr1B,KAAK+R,IAAIg7B,gBAAiB,CAC5B,MAAM5+B,EAAQ/N,EAAMi1B,OAEdznB,EADa5N,KAAK+R,IAAIg7B,gBACHC,kBAAkB7+B,GACrC8+B,EAAQzqC,KAAKukB,IAAI,EAAG/mB,KAAK+R,IAAIm7B,WAC7BC,EAAa,IAAIvE,OAAOC,KAAKuE,MACjCx/B,EAAMzF,EAAI8kC,EACVr/B,EAAMxF,EAAI6kC,GAINI,EADertC,KAAK+R,IAAIw3B,SACC+D,wBAE/BR,EAAetX,MAAQ,CACrBhzB,KAAKqX,MAAMszB,EAAWhlC,GAAKklC,EAAUE,KAAO5E,OAAO6E,UACnDhrC,KAAKqX,MAAMszB,EAAW/kC,GAAKilC,EAAUI,IAAM9E,OAAO+E,WAIlC,UAAdtB,GACFrrC,QAAQk1B,MAAM,mBAAmB6W,EAAetX,MAAM,OAAOsX,EAAetX,MAAM,KAEhG,CACS,CAAC,MAAOxqB,GACPjK,QAAQ2D,KAAK,qCAAsCsG,EAC7D,CACA,CAGM3K,EAASysC,EAAe,IAU1B,OALK9sC,KAAKqpC,eAAez/B,IAAIwiC,IAC3BpsC,KAAKqpC,eAAe/hC,IAAI8kC,EAAW,IAAIzqC,KAEzC3B,KAAKqpC,eAAe1iC,IAAIylC,GAAW9kC,IAAIjH,EAAUmsC,GAE1C7nC,QAAQC,QAAQ4nC,EAC3B,CAQE,yBAAMprC,CAAoBgrC,EAAWuB,GACnC,IAAKA,EACH,OAAOhpC,QAAQC,UAGjB,IAAI4nC,EAASmB,EAGb,GAAgC,mBAArBA,EAAiC,CAE1C,IAAI3tC,KAAKqpC,eAAez/B,IAAIwiC,KAClBpsC,KAAKqpC,eAAe1iC,IAAIylC,GAAWxiC,IAAI+jC,GAQ/C,OADA5sC,QAAQ2D,KAAK,+BAA+B0nC,KACrCznC,QAAQC,UAPf4nC,EAASxsC,KAAKqpC,eAAe1iC,IAAIylC,GAAWzlC,IAAIgnC,GAGhD3tC,KAAKqpC,eAAe1iC,IAAIylC,GAAWpnB,OAAO2oB,EAMlD,CAGI,IACE/E,OAAOC,KAAKzoC,MAAMwtC,eAAepB,EAClC,CAAC,MAAOxhC,GACPjK,QAAQ2D,KAAK,+BAA+B0nC,KAAcphC,EAChE,CAEI,OAAOrG,QAAQC,SACnB,CAOE,kBAAM0+B,CAAa1gC,GACjB,IAAK5C,KAAK0oC,UACR,MAAM,IAAIjnC,MAAM,wDAIlB,GAA6B,OAAzBmB,EAAWK,gBAA+CwE,IAAzB7E,EAAWK,UAC9C,OAAO0B,QAAQC,QAAQhC,EAAWK,WAGpC,MAAM4qC,EAAmB,IAAIjF,OAAOC,KAAKP,iBACnCwF,EAAY,CAAC9tC,KAAKuqC,UAAU3nC,IAElC,OAAO,IAAI+B,SAAQ,CAACC,EAAS8kC,KAC3BmE,EAAiBE,yBAAyB,CAAED,cAAa,CAACE,EAASC,KAC7DA,IAAWrF,OAAOC,KAAKqF,gBAAgBC,IAAMH,GAAWA,EAAQhhC,OAAS,EAC3EpI,EAAQopC,EAAQ,GAAG/qC,WAEnBymC,EAAO,IAAIjoC,MAAM,6BAA6BwsC,KACxD,GACQ,GAER,CAOE,0BAAM5G,CAAqBn7B,GACzB,IAAKlM,KAAK0oC,UACR,MAAM,IAAIjnC,MAAM,wDAMlB,MAAMosC,EAAmB,IAAIjF,OAAOC,KAAKP,iBACnC4C,EAAOh/B,EAAY6F,KAAI5D,GAASnO,KAAKuqC,UAAUp8B,KAI/CigC,EAAU5rC,KAAKgI,IAAI0B,EAAYc,OADjB,KAGpB,OAAO,IAAIrI,SAAQ,CAACC,EAAS8kC,KAC3BmE,EAAiBQ,sBACf,CACEnD,KAAMA,EACNkD,QAASA,IAEX,CAACJ,EAASC,KACR,GAAIA,IAAWrF,OAAOC,KAAKqF,gBAAgBC,IAAMH,GAAWA,EAAQhhC,OAAS,EAAG,CAC9E,MAAMsR,EAAa0vB,EAAQj8B,KAAInL,GAAUA,EAAO3D,YAChD2B,EAAQ0Z,EACpB,MACYorB,EAAO,IAAIjoC,MAAM,6BAA6BwsC,KAC1D,GAEO,GAEP,CAOE,iBAAAnnB,CAAkBlkB,GAChB,IAAK5C,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAM4zB,EAASr1B,KAAKuqC,UAAU3nC,GACxBe,EAAa3D,KAAK+R,IAAIg7B,gBAE5B,IAAKppC,EACH,MAAM,IAAIlC,MAAM,6BAGlB,MAAMmM,EAAQjK,EAAWqpC,kBAAkB3X,GACrC4X,EAAQzqC,KAAKukB,IAAI,EAAG/mB,KAAK+R,IAAIm7B,WAC7BC,EAAa,IAAIvE,OAAOC,KAAKuE,MACjCx/B,EAAMzF,EAAI8kC,EACVr/B,EAAMxF,EAAI6kC,GAINI,EADertC,KAAK+R,IAAIw3B,SACC+D,wBAGzBgB,EAAU,IAAI1F,OAAOC,KAAKuE,MAC9BC,EAAUE,KAAO5E,OAAO6E,QACxBH,EAAUI,IAAM9E,OAAO+E,SAIzB,MAAO,CACLlrC,KAAKqX,MAAMszB,EAAWhlC,EAAImmC,EAAQnmC,GAClC3F,KAAKqX,MAAMszB,EAAW/kC,EAAIkmC,EAAQlmC,GAExC,CAOE,iBAAAk/B,CAAkB9R,GAChB,IAAKx1B,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAMkC,EAAa3D,KAAK+R,IAAIg7B,gBAE5B,IAAKppC,EACH,MAAM,IAAIlC,MAAM,6BAGlB,MACM4rC,EADertC,KAAK+R,IAAIw3B,SACC+D,wBAGzBgB,EAAU,IAAI1F,OAAOC,KAAKuE,MAC9BC,EAAUE,KAAO5E,OAAO6E,QACxBH,EAAUI,IAAM9E,OAAO+E,SAInBT,EAAQzqC,KAAKukB,IAAI,EAAG/mB,KAAK+R,IAAIm7B,WAC7BC,EAAa,IAAIvE,OAAOC,KAAKuE,OAChC5X,EAAM,GAAK8Y,EAAQnmC,GAAK8kC,GACxBzX,EAAM,GAAK8Y,EAAQlmC,GAAK6kC,GAIrB5X,EAAS1xB,EAAW4qC,kBAAkBpB,GAG5C,OAAOntC,KAAKyqC,cAAcpV,EAC9B,CAUE,WAAA7H,CAAYxf,GACV,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,MAAMgsB,EAAWzf,EAAQyf,SACnBC,EAAO1f,EAAQ0f,MAAQ,GACvBzT,EAAQjM,EAAQiM,OAAS,CAAE,EAG5Bja,KAAKwuC,UACRxuC,KAAKwuC,QAAU,IAIjB,MAAMnZ,EAAS5H,EAAS1qB,KAAO0qB,EAAS/qB,IACtC,IAAIkmC,OAAOC,KAAK2B,OAAO/c,EAAS1qB,IAAK0qB,EAAS/qB,KAC9C1C,KAAKuqC,UAAU9c,GAGXghB,EAAYx0B,EAAMoP,MAAQ,aAC1BC,EAAYrP,EAAMqP,WAAa,QAC/BC,EAActP,EAAMsP,aAAe,QACnCC,EAAcvP,EAAMuP,aAAe,EAGzC,MAAMklB,UAAqB9F,OAAOC,KAAK8F,YACrC,WAAA5uC,CAAYgS,EAAKsjB,EAAQ3H,EAAMzT,GAC7BnV,QACA9E,KAAK+R,IAAMA,EACX/R,KAAKq1B,OAASA,EACdr1B,KAAK0tB,KAAOA,EACZ1tB,KAAKia,MAAQA,EACbja,KAAK4uC,IAAM,KACX5uC,KAAKulC,OAAOxzB,EACpB,CAEM,KAAA88B,GACE,MAAMD,EAAMtkB,SAASuf,cAAc,OACnC+E,EAAI30B,MAAMwT,SAAW,WACrBmhB,EAAI30B,MAAMkyB,QAAU,UACpByC,EAAI30B,MAAM60B,aAAe,MACzBF,EAAI30B,MAAM80B,gBAAkB,2BAC5BH,EAAI30B,MAAMoP,KAAOrpB,KAAKia,MAAMoP,KAC5BulB,EAAI30B,MAAM6Q,MAAQ9qB,KAAKia,MAAMqP,UAC7BslB,EAAI30B,MAAM+0B,WAAa,GAAGhvC,KAAKia,MAAMuP,mBAAmBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,2DAC5DvpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,0DACpEvpB,KAAKia,MAAMuP,mBAAmBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,4DACnEvpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,cACvGqlB,EAAI30B,MAAMg1B,WAAa,SACvBL,EAAI30B,MAAMi1B,WAAa,OACvBN,EAAI30B,MAAMk1B,cAAgB,OAC1BP,EAAIQ,UAAYpvC,KAAK0tB,KAErB1tB,KAAK4uC,IAAMA,EACG5uC,KAAKqvC,WACbC,aAAapF,YAAY0E,EACvC,CAEM,IAAAW,GACE,IAAKvvC,KAAK4uC,IAAK,OAEf,MACMnhB,EADoBztB,KAAK+sC,gBACIyC,qBAAqBxvC,KAAKq1B,QAG7Dr1B,KAAK4uC,IAAI30B,MAAMszB,KAAO,GAAG9f,EAAStlB,MAClCnI,KAAK4uC,IAAI30B,MAAMwzB,IAAM,GAAGhgB,EAASrlB,MACjCpI,KAAK4uC,IAAI30B,MAAMnY,UAAY,wBACnC,CAEM,QAAA2tC,GACMzvC,KAAK4uC,MACP5uC,KAAK4uC,IAAIc,WAAWC,YAAY3vC,KAAK4uC,KACrC5uC,KAAK4uC,IAAM,KAErB,CAEM,WAAAjK,CAAYtP,GACVr1B,KAAKq1B,OAASA,EACdr1B,KAAKuvC,MACb,CAEM,OAAAK,CAAQliB,GACN1tB,KAAK0tB,KAAOA,EACR1tB,KAAK4uC,MACP5uC,KAAK4uC,IAAIQ,UAAY1hB,EAE/B,CAEM,QAAAvS,CAASlB,GACPja,KAAKia,MAAQ,IAAKja,KAAKia,SAAUA,GAC7Bja,KAAK4uC,MACP5uC,KAAK4uC,IAAI30B,MAAMoP,KAAOrpB,KAAKia,MAAMoP,KACjCrpB,KAAK4uC,IAAI30B,MAAM6Q,MAAQ9qB,KAAKia,MAAMqP,UAClCtpB,KAAK4uC,IAAI30B,MAAM+0B,WAAa,GAAGhvC,KAAKia,MAAMuP,mBAAmBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,mEAC3DvpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,kEACpEvpB,KAAKia,MAAMuP,mBAAmBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,oEACnEvpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMuP,iBAAiBxpB,KAAKia,MAAMsP,cAEvH,EAII,MAAM6B,EAAQ,IAAIsjB,EAChB1uC,KAAK+R,IACLsjB,EACA3H,EACA,CACErE,KAAMolB,EACNnlB,UAAWA,EACXC,YAAaA,EACbC,YAAaA,IAOjB,OAFAxpB,KAAKwuC,QAAQluC,KAAK8qB,GAEXA,CACX,CAOE,WAAAC,CAAYD,GACV,GAAKA,IAGLA,EAAMma,OAAO,MAGTvlC,KAAKwuC,SAAS,CAChB,MAAM1vB,EAAQ9e,KAAKwuC,QAAQqB,QAAQzkB,IACrB,IAAVtM,GACF9e,KAAKwuC,QAAQzvB,OAAOD,EAAO,EAEnC,CACA,ECt0BO,MAAMgxB,UAAuB9J,EAQlC,WAAAjmC,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAENhO,KAAK+R,IAAM,KACX/R,KAAK0oC,WAAY,EACjB1oC,KAAK+oC,WAAa/6B,EAAQ+6B,YAAc,CACtCt4B,OAAQ,CAAC,EAAG,GACZu4B,KAAM,EACN+G,QAAS,EACTC,QAAS,IAGXhwC,KAAKiwC,aAAejiC,EAAQiiC,cACpB,qDAIRjwC,KAAKqpC,eAAiB,IAAI1nC,IAE1B3B,KAAKkwC,iBAAmBliC,EAAQkiC,kBAAoB,CAClDC,YAAa,2FAIfnwC,KAAKqpC,eAAiB,IAAI1nC,GAC9B,CAOE,SAAA44B,CAAU+O,GACHtpC,KAAK+R,MAGV/R,KAAK+R,IAAIq+B,eAAen2B,MAAMuvB,OAASF,EAC3C,CAOE,qBAAM+G,GACJ,GAAI1H,OAAO2H,EAET,OADAtwC,KAAK0oC,WAAY,EACV/jC,QAAQC,UAGjB,MAAM2rC,EAAU,IAAI5rC,SAAQ,CAACC,EAAS8kC,KACpC,MAAM8G,EAAOlmB,SAASuf,cAAc,QACpC2G,EAAKC,IAAM,aACXD,EAAKE,KAAO,mDACZF,EAAKG,UAAY,sDACjBH,EAAKI,YAAc,GACnBJ,EAAKK,OAASjsC,EACd4rC,EAAKxG,QAAU,IAAMN,EAAO,IAAIjoC,MAAM,+BACtC6oB,SAAS2f,KAAKC,YAAYsG,EAAK,IAG3BM,EAAS,IAAInsC,SAAQ,CAACC,EAAS8kC,KACnC,MAAME,EAAStf,SAASuf,cAAc,UACtCD,EAAOE,IAAM,kDACbF,EAAO+G,UAAY,sDACnB/G,EAAOgH,YAAc,GACrBhH,EAAOzwB,OAAQ,EACfywB,EAAOiH,OAAS,KACd7wC,KAAK0oC,WAAY,EACjB9jC,GAAS,EAEXglC,EAAOI,QAAU,IAAMN,EAAO,IAAIjoC,MAAM,8BACxC6oB,SAAS2f,KAAKC,YAAYN,EAAO,IAGnC,OAAOjlC,QAAQosC,IAAI,CAACR,EAASO,GACjC,CAOE,gBAAM5K,CAAWiE,SACTnqC,KAAKqwC,kBAEX,MAAMjG,EAA+B,iBAAdD,EACnB7f,SAAS+f,eAAeF,GACxBA,EAEJ,IAAKC,EACH,MAAM,IAAI3oC,MAAM,oCAAoC0oC,KAQtD,OALAnqC,KAAK+R,IAAMu+B,EAAEv+B,IAAIq4B,EAASpqC,KAAK+oC,YAG/BuH,EAAEU,UAAUhxC,KAAKiwC,aAAcjwC,KAAKkwC,kBAAkBe,MAAMjxC,KAAK+R,KAE1DpN,QAAQC,SACnB,CAQE,SAAA2lC,CAAU3nC,GACR,OAAO0tC,EAAEjb,OAAOzyB,EAAWgI,SAAUhI,EAAWiI,UACpD,CASE,aAAA4/B,CAAcpV,EAAQpyB,EAAY,MAChC,OAAO,IAAII,EAAWgyB,EAAOtyB,IAAKsyB,EAAO3yB,IAAKO,EAClD,CAOE,eAAMohC,CAAUzhC,GACd,IAAK5C,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,OADAzB,KAAK+R,IAAIm/B,QAAQlxC,KAAKuqC,UAAU3nC,GAAa5C,KAAK+R,IAAIm7B,WAC/CvoC,QAAQC,SACnB,CAOE,aAAMwhC,CAAQsE,GACZ,IAAK1qC,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,OADAzB,KAAK+R,IAAIq0B,QAAQsE,GACV/lC,QAAQC,SACnB,CAQE,eAAM0hC,CAAU1jC,EAAYoL,EAAU,IACpC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAMkpC,EAAgB,CACpBC,MAAO58B,EAAQ48B,OAAS,GACxB7/B,IAAKiD,EAAQod,OAAS,GACtB0f,UAAW98B,EAAQ88B,YAAa,KAC7B98B,EAAQ28B,eAIT38B,EAAQ68B,OACkB,iBAAjB78B,EAAQ68B,KAEjBF,EAAcE,KAAOyF,EAAEzF,KAAK,CAC1BsG,QAASnjC,EAAQ68B,KACjBuG,SAAUpjC,EAAQojC,UAAY,CAAC,GAAI,IACnCC,WAAYrjC,EAAQqjC,YAAc,CAAC,GAAI,IACvCC,YAAatjC,EAAQsjC,aAAe,CAAC,GAAG,MAEjCtjC,EAAQ68B,KAAK78B,UAEtB28B,EAAcE,KAAO78B,EAAQ68B,OAIjC,MAAME,EAASuF,EAAEvF,OACf,CAACnoC,EAAWgI,SAAUhI,EAAWiI,WACjC8/B,GACAsG,MAAMjxC,KAAK+R,KAKb,OAFAg5B,EAAO9nC,UAAYL,EAAWK,UAEvB0B,QAAQC,QAAQmmC,EAC3B,CAOE,kBAAMxE,CAAawE,GACjB,OAAKA,GAIL/qC,KAAK+R,IAAIw/B,YAAYxG,GACdpmC,QAAQC,WAJND,QAAQC,SAKrB,CAQE,iBAAM6hC,CAAYv6B,EAAa8B,EAAU,IACvC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAM+vC,EAAUtlC,EAAY6F,KAAI5D,GAAS,CAACA,EAAMvD,SAAUuD,EAAMtD,aAE1DogC,EAAkB,CACtBngB,MAAO9c,EAAQub,aAAe,UAC9B2K,QAASlmB,EAAQm9B,eAAiB,EAClCsG,OAAQzjC,EAAQw2B,cAAgB,KAC7Bx2B,EAAQi9B,iBAGPG,EAAWkF,EAAElF,SAASoG,EAASvG,GAAiBgG,MAAMjxC,KAAK+R,KAKjE,OAFAq5B,EAASE,oBAAsB,IAAIp/B,GAE5BvH,QAAQC,QAAQwmC,EAC3B,CAOE,oBAAMzE,CAAeyE,GACnB,OAAKA,GAILprC,KAAK+R,IAAIw/B,YAAYnG,GACdzmC,QAAQC,WAJND,QAAQC,SAKrB,CAQE,gBAAMiiC,CAAW36B,EAAa8B,EAAU,IACtC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAM+vC,EAAUtlC,EAAY6F,KAAI5D,GAAS,CAACA,EAAMvD,SAAUuD,EAAMtD,aAE1D0gC,EAAiB,CACrBzgB,MAAO9c,EAAQub,aAAe,UAC9B2K,QAASlmB,EAAQm9B,eAAiB,GAClCsG,OAAQzjC,EAAQw2B,cAAgB,EAChClb,UAAWtb,EAAQsb,WAAa,UAChCmiB,YAAaz9B,EAAQy9B,aAAe,OACjCz9B,EAAQu9B,gBAGP55B,EAAU2+B,EAAE3+B,QAAQ6/B,EAASjG,GAAgB0F,MAAMjxC,KAAK+R,KAK9D,OAFAJ,EAAQ25B,oBAAsB,IAAIp/B,GAE3BvH,QAAQC,QAAQ+M,EAC3B,CAOE,mBAAMm1B,CAAcn1B,GAClB,OAAKA,GAIL3R,KAAK+R,IAAIw/B,YAAY5/B,GACdhN,QAAQC,WAJND,QAAQC,SAKrB,CAME,eAAMgW,GACJ,IAAK5a,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,MAAM6kB,EAAStmB,KAAK+R,IAAI6I,YAClB+wB,EAAKrlB,EAAOslB,eACZC,EAAKvlB,EAAOwlB,eAElB,OAAOnnC,QAAQC,QAAQ,CACrBY,MAAOmmC,EAAG5oC,IACVka,KAAM0uB,EAAGjpC,IACTwa,MAAO2uB,EAAG9oC,IACVoa,KAAM0uB,EAAGnpC,IACTqa,UAAW/c,KAAKyqC,cAAckB,GAC9B3uB,UAAWhd,KAAKyqC,cAAcoB,IAEpC,CAQE,eAAM7E,CAAU1gB,EAAQtY,EAAU,IAChC,IAAKhO,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAGlB,IAAIiwC,EAEJ,GAAIprB,EAAOvJ,WAAauJ,EAAOtJ,UAC7B00B,EAAgBpB,EAAEqB,aAChB3xC,KAAKuqC,UAAUjkB,EAAOtJ,WACtBhd,KAAKuqC,UAAUjkB,EAAOvJ,iBAEnB,GAAIuJ,EAAO9gB,OAAS8gB,EAAOpJ,OAASoJ,EAAOrJ,MAAQqJ,EAAOnJ,KAC/Du0B,EAAgBpB,EAAEqB,aAChBrB,EAAEjb,OAAO/O,EAAOpJ,MAAOoJ,EAAOnJ,MAC9BmzB,EAAEjb,OAAO/O,EAAO9gB,MAAO8gB,EAAOrJ,WAE3B,KAAIN,MAAMC,QAAQ0J,GAKvB,MAAM,IAAI7kB,MAAM,yBALgB,CAEhC,MAAM+vC,EAAUlrB,EAAOvU,KAAI5D,GAASnO,KAAKuqC,UAAUp8B,KACnDujC,EAAgBpB,EAAEqB,aAAaH,EACrC,CAEA,CAEI,MAAMtF,EAAa,CACjBC,QAASn+B,EAAQm+B,QAAUmE,EAAE1iC,MAAMI,EAAQm+B,QAASn+B,EAAQm+B,SAAW,KACvE6D,QAAShiC,EAAQgiC,SAAW,KAC5B4B,SAA6B,IAApB5jC,EAAQ4jC,WACd5jC,EAAQk+B,YAIb,OADAlsC,KAAK+R,IAAIi1B,UAAU0K,EAAexF,GAC3BvnC,QAAQC,SACnB,CAQE,sBAAMnE,CAAiB2rC,EAAW/rC,GAChC,IAAKL,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,MAAMowC,EAAiC,UAAdzF,EAAwB,QACjC,iBAAdA,EAA+B,UACf,mBAAdA,GACgB,mBAAdA,EAD+B,UAE7BA,EAEF0F,EAAkB1xC,IAEtB,MAAM0sC,EAAiB,CACrB5nC,KAAMknC,EACN3gB,cAAerrB,GAIjB,GAAIA,EAAM2xC,OAAQ,CAEhBjF,EAAelqC,WAAa5C,KAAKyqC,cAAcrqC,EAAM2xC,QAGrD,MAAMvc,EAAQx1B,KAAK8mB,kBAAkBgmB,EAAelqC,YACpDkqC,EAAetX,MAAQA,CAC/B,CAEMn1B,EAASysC,EAAe,EAG1B9sC,KAAK+R,IAAI5R,GAAG0xC,EAAkBC,GAG9B,MAAMtF,EAAS,CACbqF,mBACAC,mBAUF,OALK9xC,KAAKqpC,eAAez/B,IAAIwiC,IAC3BpsC,KAAKqpC,eAAe/hC,IAAI8kC,EAAW,IAAIzqC,KAEzC3B,KAAKqpC,eAAe1iC,IAAIylC,GAAW9kC,IAAIjH,EAAUmsC,GAE1C7nC,QAAQC,QAAQ4nC,EAC3B,CAQE,yBAAMprC,CAAoBgrC,EAAWuB,GACnC,IAAKA,IAAqB3tC,KAAK+R,IAC7B,OAAOpN,QAAQC,UAGjB,IAAI4nC,EAASmB,EAGb,GAAgC,mBAArBA,EAAiC,CAE1C,IAAI3tC,KAAKqpC,eAAez/B,IAAIwiC,KAClBpsC,KAAKqpC,eAAe1iC,IAAIylC,GAAWxiC,IAAI+jC,GAQ/C,OADA5sC,QAAQ2D,KAAK,+BAA+B0nC,KACrCznC,QAAQC,UAPf4nC,EAASxsC,KAAKqpC,eAAe1iC,IAAIylC,GAAWzlC,IAAIgnC,GAGhD3tC,KAAKqpC,eAAe1iC,IAAIylC,GAAWpnB,OAAO2oB,EAMlD,CAGI,IACE3tC,KAAK+R,IAAI5Q,IAAIqrC,EAAOqF,iBAAkBrF,EAAOsF,gBAC9C,CAAC,MAAO9mC,GACPjK,QAAQ2D,KAAK,+BAA+B0nC,KAAcphC,EAChE,CAEI,OAAOrG,QAAQC,SACnB,CASE,kBAAM0+B,CAAa1gC,GAEjB,OAA6B,OAAzBA,EAAWK,gBAA+CwE,IAAzB7E,EAAWK,UACvC0B,QAAQC,QAAQhC,EAAWK,YAMpClC,QAAQ2D,KAAK,gEACNC,QAAQC,QAAQ,GAC3B,CASE,0BAAMyiC,CAAqBn7B,GAEzB,MAAMoS,EAAapS,EAAY6F,KAAI5D,GACL,OAApBA,EAAMlL,gBAA0CwE,IAApB0G,EAAMlL,UACtCkL,EAAMlL,UACN,IAIN,OADAlC,QAAQ2D,KAAK,wEACNC,QAAQC,QAAQ0Z,EAC3B,CAOE,iBAAAwI,CAAkBlkB,GAChB,IAAK5C,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,MAAM4zB,EAASib,EAAEjb,OAAOzyB,EAAWG,IAAKH,EAAWF,KAG7CkL,EAAQ5N,KAAK+R,IAAIigC,uBAAuB3c,GAE9C,MAAO,CAACznB,EAAMzF,EAAGyF,EAAMxF,EAC3B,CAOE,iBAAAk/B,CAAkB9R,GAChB,IAAKx1B,KAAK+R,IACR,MAAM,IAAItQ,MAAM,iDAIlB,MAAMmM,EAAQ0iC,EAAE1iC,MAAM4nB,EAAM,GAAIA,EAAM,IAGhCH,EAASr1B,KAAK+R,IAAIkgC,uBAAuBrkC,GAG/C,OAAO5N,KAAKyqC,cAAcpV,EAC9B,EC5hBO,MAAM6c,UAAmC5J,EAM9C,WAAAvoC,CAAYiO,EAAU,IACpBlJ,MAAMkJ,GAENhO,KAAK0oC,WAAY,EACjB1oC,KAAK8oC,OAAS96B,EAAQ86B,OACtB9oC,KAAK6tC,iBAAmB,IAC5B,CAOE,wBAAMpE,GACJ,GAAId,OAAOC,QAAUD,OAAOC,OAAOC,KAOjC,OANA7oC,KAAK0oC,WAAY,QAEZ1oC,KAAK6tC,kBAAoBlF,OAAOC,OAAOC,KAAKP,mBAC/CtoC,KAAK6tC,iBAAmB,IAAIjF,OAAOC,KAAKP,mBAM5C,IAAKtoC,KAAK8oC,OACR,MAAM,IAAIrnC,MAAM,sDAGlB,OAAO,IAAIkD,SAAQ,CAACC,EAAS8kC,KAC3B,MAAMC,EAAe,sBAAsBhwB,KAAKC,QAChD+uB,OAAOgB,GAAgB,KACrB3pC,KAAK0oC,WAAY,EACjB1oC,KAAK6tC,iBAAmB,IAAIjF,OAAOC,KAAKP,wBACjCK,OAAOgB,GACd/kC,GAAS,EAGX,MAAMglC,EAAStf,SAASuf,cAAc,UACtCD,EAAOE,IAAM,+CAA+C9pC,KAAK8oC,mBAAmBa,uBACpFC,EAAOzwB,OAAQ,EACfywB,EAAOG,OAAQ,EACfH,EAAOI,QAAU,IAAMN,EAAO,IAAIjoC,MAAM,mCACxC6oB,SAAS2f,KAAKC,YAAYN,EAAO,GAEvC,CAQE,SAAAW,CAAU3nC,GACR,OAAO,IAAIgmC,OAAOC,KAAK2B,OAAO5nC,EAAWgI,SAAUhI,EAAWiI,UAClE,CAOE,kBAAMy4B,CAAa1gC,GAOjB,GALK5C,KAAK0oC,iBACF1oC,KAAKypC,qBAIgB,OAAzB7mC,EAAWK,gBAA+CwE,IAAzB7E,EAAWK,UAC9C,OAAO0B,QAAQC,QAAQhC,EAAWK,WAGpC,MAAM6qC,EAAY,CAAC9tC,KAAKuqC,UAAU3nC,IAElC,OAAO,IAAI+B,SAAQ,CAACC,EAAS8kC,KAC3B1pC,KAAK6tC,iBAAiBE,yBAAyB,CAAED,cAAa,CAACE,EAASC,KAClEA,IAAWrF,OAAOC,KAAKqF,gBAAgBC,IAAMH,GAAWA,EAAQhhC,OAAS,EAC3EpI,EAAQopC,EAAQ,GAAG/qC,WAEnBymC,EAAO,IAAIjoC,MAAM,6BAA6BwsC,KACxD,GACQ,GAER,CAOE,0BAAM5G,CAAqBn7B,GAEpBlM,KAAK0oC,iBACF1oC,KAAKypC,qBAGb,MAAMyB,EAAOh/B,EAAY6F,KAAI5D,GAASnO,KAAKuqC,UAAUp8B,KAI/CigC,EAAU5rC,KAAKgI,IAAI0B,EAAYc,OADjB,KAGpB,OAAO,IAAIrI,SAAQ,CAACC,EAAS8kC,KAC3B1pC,KAAK6tC,iBAAiBQ,sBACpB,CACEnD,KAAMA,EACNkD,QAASA,IAEX,CAACJ,EAASC,KACR,GAAIA,IAAWrF,OAAOC,KAAKqF,gBAAgBC,IAAMH,GAAWA,EAAQhhC,OAAS,EAAG,CAC9E,MAAMsR,EAAa0vB,EAAQj8B,KAAInL,GAAUA,EAAO3D,YAChD2B,EAAQ0Z,EACpB,MACYorB,EAAO,IAAIjoC,MAAM,6BAA6BwsC,KAC1D,GAEO,GAEP,CAOE,+BAAM1F,CAA0Br8B,GAEzBlM,KAAK0oC,iBACF1oC,KAAKypC,qBAIb,MACM0I,EAAU,GAEhB,IAAK,IAAIjlC,EAAI,EAAGA,EAAIhB,EAAYc,OAAQE,GAHlB,IAGsC,CAC1D,MACM4gC,EADmB5hC,EAAYmV,MAAMnU,EAAGA,EAJ1B,KAKe6E,KAAI5D,GAASnO,KAAKuqC,UAAUp8B,KAE/DgkC,EAAQ7xC,KACN,IAAIqE,SAAQ,CAACC,EAAS8kC,KACpB1pC,KAAK6tC,iBAAiBE,yBACpB,CAAED,cACF,CAACE,EAASC,KACJA,IAAWrF,OAAOC,KAAKqF,gBAAgBC,IAAMH,EAC/CppC,EAAQopC,EAAQj8B,KAAInL,GAAUA,EAAO3D,aAErCymC,EAAO,IAAIjoC,MAAM,6BAA6BwsC,KAC9D,GAEW,IAGX,CAII,aADsBtpC,QAAQosC,IAAIoB,IACnBC,MACnB,ECnKO,IAAAC,EAAA,MAOL,gBAAOC,CAAUC,EAAcvkC,EAAU,IACvC,OAAQukC,EAAaC,eACrB,IAAK,SACH,OAAO,IAAIhK,EAAkBx6B,GAE/B,IAAK,UACH,OAAO,IAAI8hC,EAAe9hC,GAE5B,QACE,MAAM,IAAIvM,MAAM,kCAAkC8wC,KAExD,CAQE,0BAAOE,CAAoBF,EAAcvkC,EAAU,IACjD,OAAQukC,EAAaC,eACrB,IAAK,SACH,MAAyB,oBAAX7J,cACqBlhC,IAAlBkhC,OAAOC,aAA2CnhC,IAAnBuG,EAAQ86B,QAE1D,IAAK,UACH,MAAyB,oBAAXH,OAEhB,QACE,OAAO,EAEb,CAME,4BAAO+J,GACL,MAAO,CAAC,SAAU,UACtB,GClDO,MAAMC,EAMX,WAAA5yC,CAAYgS,EAAK/D,EAAU,IACzB,GAAIhO,KAAKD,cAAgB4yC,EACvB,MAAM,IAAIlxC,MAAM,uEAGlBzB,KAAK+R,IAAMA,EACX/R,KAAKgO,QAAUA,CACnB,CASE,iBAAM4kC,CAAYC,EAAUn7B,EAAW,IACrC,MAAM,IAAIjW,MAAM,8CACpB,CASE,gBAAMqxC,CAAWD,EAAUn7B,EAAW,IACpC,MAAM,IAAIjW,MAAM,6CACpB,CAUE,mBAAMsxC,CAAcF,EAAUn7B,EAAW,IACvC,MAAM,IAAIjW,MAAM,gDACpB,CAOE,mBAAMojB,CAAcmuB,GAClB,MAAM,IAAIvxC,MAAM,gDACpB,CASE,mBAAM2lB,CAAc4rB,EAAkBC,EAAiBv7B,EAAW,CAAA,GAChE,MAAM,IAAIjW,MAAM,gDACpB,CAQE,sBAAMyxC,CAAiBF,EAAkBt7B,EAAW,IAClD,MAAM,IAAIjW,MAAM,mDACpB,CAOE,wBAAM0xC,CAAmBH,GACvB,MAAM,IAAIvxC,MAAM,qDACpB,ECpFO,MAAM2xC,UAAoCT,EAM/C,WAAA5yC,CAAYgS,EAAK/D,EAAU,IAGzB,GAFAlJ,MAAMiN,EAAK/D,IAEN+D,IAAQA,EAAIA,IACf,MAAM,IAAItQ,MAAM,2EAIlBzB,KAAKqzC,UAAYthC,EAAIA,IAGrB/R,KAAKszC,iBAAmB,IAAI3xC,GAChC,CAQE,iBAAMixC,CAAYx3B,EAASpN,EAAU,IACnC,IACE,MAAMpL,EAAawY,EAAQyB,cAAgBzB,EAAQyB,gBAAkBzB,EAAQxY,WAC7E,IAAKA,EACH,MAAM,IAAInB,MAAM,8CAIlBV,QAAQC,IAAI,yCACZD,QAAQC,IAAI,eAAe4B,EAAWG,IAAIC,QAAQ,OAAOJ,EAAWF,IAAIM,QAAQ,MAChFjC,QAAQC,IAAI,eAAeoa,EAAQ1B,IAAM,aACzC3Y,QAAQC,IAAI,WAAWoa,EAAQlB,YAAYxW,QAAU,cAErD,MAAMuW,EAAQmB,EAAQnB,OAASjM,EAAQiM,OAASja,KAAKgO,QAAQulC,mBAAqB,CAAE,EAMpF,GALAxyC,QAAQC,IAAI,kBAAiBiZ,EAAM+Z,cAAgB,cAAiB/Z,EAAMk3B,QAAU,QAAU,WAC9FpwC,QAAQC,IAAI,iBAAiBiZ,EAAM6Q,OAAS,aAC5C/pB,QAAQC,IAAI,4CAGPhB,KAAKwzC,6BACR,MAAM,IAAI/xC,MAAM,0FAIlB,MAAMgyC,EAAazzC,KAAK0zC,kBAAkBz5B,EAAOmB,GAG3CuvB,EAAgB,CACpBld,SAAU,CAAE1qB,IAAKH,EAAWG,IAAKL,IAAKE,EAAWF,KACjDqP,IAAK/R,KAAKqzC,UACVzI,MAAOxvB,EAAQrB,MAAQqB,EAAQlB,YAAYH,MAAQ,GACnD45B,aAAc3lC,EAAQ88B,YAAa,EACnC8I,QAASH,EAAWG,SAIhB7I,EAAS,IAAInC,OAAOC,KAAKkC,OAAO8I,sBAAsBlJ,GAG5DI,EAAO/R,gBAAkB5d,GAGrBpN,EAAQ8lC,UAAkC,IAAvB9lC,EAAQ+lC,aAE7BhJ,EAAOtqC,iBAAiB,aAAcL,IAEpCW,QAAQC,IAAI,mDAAmDoa,EAAQ1B,MAGnEtZ,EAAMysC,iBACRzsC,EAAMysC,kBAIJzsC,EAAM4zC,0BACR5zC,EAAM4zC,2BAIJ5zC,EAAMsrB,gBACRtrB,EAAMsrB,iBAGJ1d,EAAQ8lC,SACV9lC,EAAQ8lC,QAAQ,CACd14B,UACA64B,gBAAiBlJ,EACjBtf,cAAerrB,KAIQ,IAAvB4N,EAAQ+lC,YACV/zC,KAAKk0C,oBAAoB94B,EAAS2vB,EAAQ3qC,IAGrC,KAKX,MAAM6zC,EAAkB,CACtBv6B,GAAI0B,EAAQ1B,GACZxU,KAAM,QACN8zB,gBAAiB5d,EACjBkB,eAAgByuB,EAChB/8B,WAIF,OADAhO,KAAKszC,iBAAiBhsC,IAAI8T,EAAQ1B,GAAIu6B,GAC/BA,CACR,CAAC,MAAO/yC,GAEP,MADAH,QAAQG,MAAM,iCAAkCA,GAC1CA,CACZ,CACA,CAQE,gBAAM4xC,CAAW13B,EAASpN,EAAU,IAClC,IAEE,IAAI9B,EAAckP,EAAQuD,eAAiBvD,EAAQuD,iBAAmBvD,EAAQlP,YAGzEA,GAAgByQ,MAAMC,QAAQ1Q,KACjCnL,QAAQ2D,KAAK,yCAEbwH,EAAc,IAIhB,MAAM+N,EAAQmB,EAAQnB,OAASjM,EAAQiM,OAASja,KAAKgO,QAAQmmC,kBAAoB,CAAE,EAGnF,IAAIjJ,EACJ,GAAIh/B,EAAYc,OAAS,EAAG,CAG1B,IAAIoO,EAAQlB,YAAYyQ,YAAavP,EAAQlB,YAAY8a,UAsBvD,MAAM,IAAIvzB,MAAM,8EAjBhB,GAJAV,QAAQC,IAAI,0CAA0CkL,EAAYc,iBAIvC,IAAvBd,EAAYc,OAAc,CAE5B,MAAMyD,EAASzQ,KAAKqzC,UAAUx4B,YAC9BqwB,EAAO,CACL,CAAEnoC,IAAK0N,EAAO1N,MAAOL,IAAK+N,EAAO/N,OACjC,CAAEK,IAAK0N,EAAO1N,MAAOL,IAAK+N,EAAO/N,OAE/C,KAAiB,CAEL,MAAM0xC,EAAcloC,EAAY,GAChCg/B,EAAO,CACL,CAAEnoC,IAAKqxC,EAAYrxC,IAAKL,IAAK0xC,EAAY1xC,KACzC,CAAEK,IAAKqxC,EAAYrxC,IAAKL,IAAK0xC,EAAY1xC,KAEvD,CAKA,MAEQwoC,EAAOh/B,EAAY6F,KAAI5D,IAAU,CAC/BpL,IAAKoL,EAAMpL,IACXL,IAAKyL,EAAMzL,QAKf,MAAMuoC,EAAkB,CACtBC,OACAn5B,IAAK/R,KAAKqzC,UACVgB,UAA+B,IAArBrmC,EAAQqmC,SAClB9qB,YAAatP,EAAM6Q,OAAS7Q,EAAMsP,aAAe,UACjD4hB,cAAelxB,EAAMia,SAAWja,EAAMkxB,eAAiB,EACvD3G,aAAcvqB,EAAM+Q,OAAS/Q,EAAMuqB,cAAgB,EACnD8P,WAAW,EAEX/P,OAAQ,KAIJ6G,EAAW,IAAIxC,OAAOC,KAAKwC,SAASJ,GAG1CG,EAASpS,gBAAkB5d,GAGvBpN,EAAQ8lC,UAAkC,IAAvB9lC,EAAQ+lC,aAC7B3I,EAASqB,YAAY,SAAUrsC,IAE7BW,QAAQC,IAAI,oCAAoCoa,EAAQ1B,MAGpDtZ,EAAMm0C,MAAMn0C,EAAMm0C,OAClBn0C,EAAMwsC,UAAYxsC,EAAMwsC,SAASC,iBACnCzsC,EAAMwsC,SAASC,kBAEbzsC,EAAMqrB,eAAiBrrB,EAAMqrB,cAAcohB,iBAC7CzsC,EAAMqrB,cAAcohB,kBAIlBzsC,EAAMwsC,UAAYxsC,EAAMwsC,SAASoH,0BACnC5zC,EAAMwsC,SAASoH,2BAIb5zC,EAAMwsC,UAAYxsC,EAAMwsC,SAASlhB,gBACnCtrB,EAAMwsC,SAASlhB,iBAGb1d,EAAQ8lC,SACV9lC,EAAQ8lC,QAAQ,CACd14B,UACA64B,gBAAiB7I,EACjB3f,cAAerrB,KAIQ,IAAvB4N,EAAQ+lC,YACV/zC,KAAKk0C,oBAAoB94B,EAASgwB,EAAUhrC,IAIvC,KAKX,MAAM6zC,EAAkB,CACtBv6B,GAAI0B,EAAQ1B,GACZxU,KAAM,OACN8zB,gBAAiB5d,EACjBkB,eAAgB8uB,EAChBp9B,WAIF,OADAhO,KAAKszC,iBAAiBhsC,IAAI8T,EAAQ1B,GAAIu6B,GAC/BA,CACR,CAAC,MAAO/yC,GAEP,MADAH,QAAQG,MAAM,gCAAiCA,GACzCA,CACZ,CACA,CAQE,mBAAM6xC,CAAc33B,EAASpN,EAAU,IACrC,IAEE,IAAIw9B,EAAQ,GAGZ,GAAIpwB,EAAQ8G,UAAwC,mBAArB9G,EAAQ8G,SAAyB,CAC9D,MAAMG,EAAQjH,EAAQ8G,WAClBG,GAASA,EAAMrV,OAAS,IAE1Bw+B,EAAQnpB,EAAMtQ,KAAI+N,GAChBA,EAAK/N,KAAI5D,IAAU,CACjBpL,IAAKoL,EAAMpL,IACXL,IAAKyL,EAAMzL,UAIzB,MAAiB0Y,EAAQlP,aAAeyQ,MAAMC,QAAQxB,EAAQlP,eAEtDs/B,EAAQ,CAACpwB,EAAQlP,YAAY6F,KAAI5D,IAAU,CACzCpL,IAAKoL,EAAMpL,IACXL,IAAKyL,EAAMzL,UAKf,GAAqB,IAAjB8oC,EAAMx+B,QAAgBw+B,EAAM,GAAGx+B,OAAS,EAAG,CAE7C,IAAIoO,EAAQlB,YAAYyQ,YAAavP,EAAQlB,YAAY8a,UAiBvD,MAAM,IAAIvzB,MAAM,iFAjBkD,CAClEV,QAAQC,IAAI,6CAA6CwqC,EAAMx+B,OAAS,EAAIw+B,EAAM,GAAGx+B,OAAS,YAG9F,MAAMyD,EAASzQ,KAAKqzC,UAAUx4B,YACxB9X,EAAM0N,EAAO1N,MACbL,EAAM+N,EAAO/N,MAInB8oC,EAAQ,CAAC,CACP,CAAEzoC,MAAKL,OACP,CAAEK,MAAKL,IAAKA,EAAM,MAClB,CAAEK,IAAKA,EAAM,KAAWL,QAEpC,CAIA,CAGM,MAAMuX,EAAQmB,EAAQnB,OAASjM,EAAQiM,OAASja,KAAKgO,QAAQwmC,qBAAuB,CAAE,EAGhFjJ,EAAiB,CACrBC,QACAz5B,IAAK/R,KAAKqzC,UACV9pB,YAAatP,EAAM4Q,cAAgB5Q,EAAMsP,aAAe,UACxD4hB,cAAelxB,EAAMw6B,gBAAkBx6B,EAAMkxB,eAAiB,GAC9D3G,aAAcvqB,EAAM8Q,cAAgB9Q,EAAMuqB,cAAgB,EAC1Dlb,UAAWrP,EAAMqP,WAAa,UAC9BmiB,YAAaxxB,EAAMwxB,aAAe,IAClC6I,WAAW,EAEX/P,OAAQ,KAIJ5yB,EAAU,IAAIi3B,OAAOC,KAAK6C,QAAQH,GAGxC55B,EAAQqnB,gBAAkB5d,GAGtBpN,EAAQ8lC,UAAkC,IAAvB9lC,EAAQ+lC,aAC7BpiC,EAAQ86B,YAAY,SAAUrsC,IAE5BW,QAAQC,IAAI,uCAAuCoa,EAAQ1B,MAGvDtZ,EAAMm0C,MAAMn0C,EAAMm0C,OAClBn0C,EAAMwsC,UAAYxsC,EAAMwsC,SAASC,iBACnCzsC,EAAMwsC,SAASC,kBAEbzsC,EAAMqrB,eAAiBrrB,EAAMqrB,cAAcohB,iBAC7CzsC,EAAMqrB,cAAcohB,kBAIlBzsC,EAAMwsC,UAAYxsC,EAAMwsC,SAASoH,0BACnC5zC,EAAMwsC,SAASoH,2BAIb5zC,EAAMwsC,UAAYxsC,EAAMwsC,SAASlhB,gBACnCtrB,EAAMwsC,SAASlhB,iBAGb1d,EAAQ8lC,SACV9lC,EAAQ8lC,QAAQ,CACd14B,UACA64B,gBAAiBtiC,EACjB8Z,cAAerrB,KAIQ,IAAvB4N,EAAQ+lC,YACV/zC,KAAKk0C,oBAAoB94B,EAASzJ,EAASvR,IAItC,KAKX,MAAM6zC,EAAkB,CACtBv6B,GAAI0B,EAAQ1B,GACZxU,KAAM,UACN8zB,gBAAiB5d,EACjBkB,eAAgB3K,EAChB3D,WAIF,OADAhO,KAAKszC,iBAAiBhsC,IAAI8T,EAAQ1B,GAAIu6B,GAC/BA,CACR,CAAC,MAAO/yC,GAEP,MADAH,QAAQG,MAAM,mCAAoCA,GAC5CA,CACZ,CACA,CASE,yBAAMwzC,CAAoBt5B,EAAS6L,EAAajZ,EAAU,CAAA,GACxD,OAAQiZ,GACR,IAAK,QACH,OAAOjnB,KAAK4yC,YAAYx3B,EAASpN,GACnC,IAAK,OACH,OAAOhO,KAAK8yC,WAAW13B,EAASpN,GAClC,IAAK,UACH,OAAOhO,KAAK+yC,cAAc33B,EAASpN,GACrC,QACE,MAAM,IAAIvM,MAAM,6BAA6BwlB,KAEnD,CAOE,mBAAMpC,CAAcovB,GAClB,IACE,MAAMU,EAAYV,EAAgB33B,eAClC,IAAKq4B,EAAW,OAGZA,aAAqB/L,OAAOC,KAAKkC,OAAO8I,sBAE1Cc,EAAU5iC,IAAM,MACP4iC,aAAqB/L,OAAOC,KAAKwC,UAC5BsJ,aAAqB/L,OAAOC,KAAK6C,UAE/CiJ,EAAUpP,OAAO,MAInBvlC,KAAKszC,iBAAiBtuB,OAAOivB,EAAgBv6B,GAE9C,CAAC,MAAOxY,GAEP,MADAH,QAAQG,MAAM,0BAA2BA,GACnCA,CACZ,CACA,CASE,mBAAMkmB,CAAc6sB,EAAiBW,EAAgB5mC,EAAU,CAAA,GAC7D,UAEQhO,KAAK6kB,cAAcovB,GASzB,aANiCj0C,KAAK00C,oBACpCE,EACAX,EAAgB/uC,KAChB8I,GAAWimC,EAAgBjmC,QAI9B,CAAC,MAAO9M,GAEP,MADAH,QAAQG,MAAM,0BAA2BA,GACnCA,CACZ,CACA,CAQE,sBAAMgyC,CAAiBe,EAAiBjmC,EAAU,IAChD,IACE,MAAM2mC,EAAYV,EAAgB33B,eAClC,IAAKq4B,EAAW,OAQhB,OALKA,EAAUE,gBACb70C,KAAK80C,qBAAqBH,EAAWV,EAAgB/uC,MAI/C+uC,EAAgB/uC,MACxB,IAAK,QACHlF,KAAK+0C,iBAAiBJ,EAAW3mC,GACjC,MAEF,IAAK,OACHhO,KAAKg1C,mBAAmBL,EAAW3mC,GACnC,MAEF,IAAK,UACHhO,KAAKi1C,kBAAkBN,EAAW3mC,GAGrC,CAAC,MAAO9M,GAEP,MADAH,QAAQG,MAAM,8BAA+BA,GACvCA,CACZ,CACA,CAOE,wBAAMiyC,CAAmBc,GACvB,IACE,MAAMU,EAAYV,EAAgB33B,eAClC,IAAKq4B,IAAcA,EAAUE,eAAgB,OAG7C,OAAQZ,EAAgB/uC,MACxB,IAAK,QACHlF,KAAKk1C,mBAAmBP,GACxB,MAEF,IAAK,OACH30C,KAAKm1C,qBAAqBR,GAC1B,MAEF,IAAK,UACH30C,KAAKo1C,oBAAoBT,GAG5B,CAAC,MAAOzzC,GAEP,MADAH,QAAQG,MAAM,gCAAiCA,GACzCA,CACZ,CACA,CAQE,oBAAA4zC,CAAqBH,EAAWzvC,GAG9B,OAFAyvC,EAAUE,eAAiB,CAAE,EAErB3vC,GACR,IAAK,QAEH,GAAIyvC,aAAqB/L,OAAOC,KAAKkC,OAAO8I,uBAAyBc,EAAUf,QAAS,CACtF,MAAMxJ,EAAUuK,EAAUf,QAC1Be,EAAUE,eAAe/yC,UAAYsoC,EAAQnwB,MAAMnY,UACnD6yC,EAAUE,eAAeQ,UAAYjL,EAAQnwB,MAAMo7B,UACnDV,EAAUE,eAAetQ,OAAS6F,EAAQnwB,MAAMsqB,MACxD,CACM,MAEF,IAAK,OACHoQ,EAAUE,eAAetrB,YAAcorB,EAAUhuC,IAAI,eACrDguC,EAAUE,eAAerQ,aAAemQ,EAAUhuC,IAAI,gBACtDguC,EAAUE,eAAe1J,cAAgBwJ,EAAUhuC,IAAI,iBACvDguC,EAAUE,eAAetQ,OAASoQ,EAAUhuC,IAAI,UAChD,MAEF,IAAK,UACHguC,EAAUE,eAAetrB,YAAcorB,EAAUhuC,IAAI,eACrDguC,EAAUE,eAAerQ,aAAemQ,EAAUhuC,IAAI,gBACtDguC,EAAUE,eAAe1J,cAAgBwJ,EAAUhuC,IAAI,iBACvDguC,EAAUE,eAAevrB,UAAYqrB,EAAUhuC,IAAI,aACnDguC,EAAUE,eAAepJ,YAAckJ,EAAUhuC,IAAI,eACrDguC,EAAUE,eAAetQ,OAASoQ,EAAUhuC,IAAI,UAGtD,CAQE,gBAAAouC,CAAiBhK,EAAQ/8B,EAAU,IACjC,MAAMsnC,EAAiBtnC,EAAQ8c,OAAS,UAExC,IAEE,GAAIigB,EAAO6I,QAAS,CAClB,MAAMxJ,EAAUW,EAAO6I,QAGlBxJ,EAAQmL,kBACXnL,EAAQmL,gBAAkB,CACxBzzC,UAAWsoC,EAAQnwB,MAAMnY,WAAa,GACtC0zC,WAAYpL,EAAQnwB,MAAMu7B,YAAc,GACxCH,UAAWjL,EAAQnwB,MAAMo7B,WAAa,GACtC9Q,OAAQ6F,EAAQnwB,MAAMsqB,QAAU,KAKpC6F,EAAQnwB,MAAMnY,UAAY,aAC1BsoC,EAAQnwB,MAAMu7B,WAAa,6BAC3BpL,EAAQnwB,MAAMo7B,UAAY,aAAaC,+BACvClL,EAAQnwB,MAAMsqB,OAAS,MAC/B,CACK,CAAC,MAAOrjC,GACPH,QAAQG,MAAM,6BAA8BA,EAClD,CACA,CAOE,kBAAAg0C,CAAmBnK,GACjB,IAEE,GAAIA,EAAO6I,SAAW7I,EAAO6I,QAAQ2B,gBAAiB,CACpD,MAAMnL,EAAUW,EAAO6I,QACjBiB,EAAiBzK,EAAQmL,gBAG/BnL,EAAQnwB,MAAMnY,UAAY+yC,EAAe/yC,WAAa,GACtDsoC,EAAQnwB,MAAMu7B,WAAaX,EAAeW,YAAc,GACxDpL,EAAQnwB,MAAMo7B,UAAYR,EAAeQ,WAAa,GACtDjL,EAAQnwB,MAAMsqB,OAASsQ,EAAetQ,QAAU,EACxD,CACK,CAAC,MAAOrjC,GACPH,QAAQG,MAAM,+BAAgCA,EACpD,CACA,CAQE,kBAAA8zC,CAAmB5J,EAAUp9B,EAAU,IACrC,MAAMsnC,EAAiBtnC,EAAQ8c,OAAS,UAExCsgB,EAASqK,WAAW,CAClBlsB,YAAa+rB,EACb9Q,aAAc4G,EAASyJ,eAAerQ,aAAe,EACrD2G,cAAe,EACf5G,OAAQ,KAEd,CAOE,oBAAA4Q,CAAqB/J,GACdA,EAASyJ,gBAEdzJ,EAASqK,WAAW,CAClBlsB,YAAa6hB,EAASyJ,eAAetrB,YACrCib,aAAc4G,EAASyJ,eAAerQ,aACtC2G,cAAeC,EAASyJ,eAAe1J,cACvC5G,OAAQ6G,EAASyJ,eAAetQ,QAEtC,CAQE,iBAAA0Q,CAAkBtjC,EAAS3D,EAAU,IACnC,MAAMsnC,EAAiBtnC,EAAQ8c,OAAS,UAExCnZ,EAAQ8jC,WAAW,CACjBlsB,YAAa+rB,EACb9Q,aAAc7yB,EAAQkjC,eAAerQ,aAAe,EACpD2G,cAAe,EACfM,YAAkD,IAArC95B,EAAQkjC,eAAepJ,YACpClH,OAAQ,KAEd,CAOE,mBAAA6Q,CAAoBzjC,GACbA,EAAQkjC,gBAEbljC,EAAQ8jC,WAAW,CACjBlsB,YAAa5X,EAAQkjC,eAAetrB,YACpCib,aAAc7yB,EAAQkjC,eAAerQ,aACrC2G,cAAex5B,EAAQkjC,eAAe1J,cACtC7hB,UAAW3X,EAAQkjC,eAAevrB,UAClCmiB,YAAa95B,EAAQkjC,eAAepJ,YACpClH,OAAQ5yB,EAAQkjC,eAAetQ,QAErC,CASE,mBAAA2P,CAAoB94B,EAASu5B,EAAWv0C,GAGlCJ,KAAKgO,QAAQ0nC,gBACf11C,KAAKgO,QAAQ0nC,eAAe,CAC1Bt6B,UACA64B,gBAAiB,CACfv6B,GAAI0B,EAAQ1B,GACZxU,KAAMlF,KAAK21C,gBAAgBhB,GAC3B3b,gBAAiB5d,EACjBkB,eAAgBq4B,GAElBlpB,cAAerrB,GAGvB,CAQE,eAAAu1C,CAAgBhB,GACd,OAAIA,aAAqB/L,OAAOC,KAAKkC,OAAO8I,sBACnC,QACEc,aAAqB/L,OAAOC,KAAKwC,SACnC,OACEsJ,aAAqB/L,OAAOC,KAAK6C,QACnC,UAEF,SACX,CASE,iBAAAgI,CAAkBz5B,EAAOmB,GAEvB,IAAI0P,EAAQ7Q,EAAM6Q,MAWlB,GARmC,SAA/B1P,EAAQlB,YAAYxW,aAAqD+D,IAAhC2T,EAAQlB,YAAYwqB,UAC/D5Z,EAAQ9qB,KAAK41C,iBAAiBx6B,EAAQlB,WAAWwqB,UAAY5Z,GAI/DA,EAAQA,GAAS,UAGb7Q,EAAM+Z,eAAiB/Z,EAAM47B,cAAe,CAE9C,MAAMrwB,EAAOvL,EAAMuL,MAAQ,GAGrB2kB,EAAY7f,SAASuf,cAAc,OACzCM,EAAUlwB,MAAMwT,SAAW,WAC3B0c,EAAUlwB,MAAM+Q,MAAQ,IACxBmf,EAAUlwB,MAAM/V,OAAS,IAGzB,MAAM4xC,EAAMxrB,SAASyrB,gBAAgB,6BAA8B,OACnED,EAAIE,aAAa,QAAS,GAAGxwB,OAC7BswB,EAAIE,aAAa,SAAoB,IAAPxwB,EAAH,MAC3BswB,EAAIE,aAAa,UAAW,aAC5BF,EAAI77B,MAAMwT,SAAW,WACrBqoB,EAAI77B,MAAMszB,MAAW/nB,EAAK,EAAT,KACjBswB,EAAI77B,MAAMwzB,IAAiB,KAAPjoB,EAAJ,KAGhB,MAAM0lB,EAAO5gB,SAASyrB,gBAAgB,6BAA8B,QACpE7K,EAAK8K,aAAa,IAAK,8EACvB9K,EAAK8K,aAAa,OAAQlrB,GAC1BogB,EAAK8K,aAAa,SAAU/7B,EAAM4Q,cAAgB,SAClDqgB,EAAK8K,aAAa,eAAgB/7B,EAAM8Q,cAAgB,GAGxD+qB,EAAI5L,YAAYgB,GAGhB,MAAM+K,EAAa3rB,SAASuf,cAAc,OAkB1C,OAjBAoM,EAAWh8B,MAAMwT,SAAW,WAC5BwoB,EAAWh8B,MAAM+Q,MAAQ,MACzBirB,EAAWh8B,MAAM/V,OAAS,MAC1B+xC,EAAWh8B,MAAMszB,KAAO,OACxB0I,EAAWh8B,MAAMwzB,IAAM,OACvBwI,EAAWh8B,MAAM80B,gBAAkB,QACnCkH,EAAWh8B,MAAMi8B,OAAS,kBAC1BD,EAAWh8B,MAAM60B,aAAe,MAChCmH,EAAWh8B,MAAMsqB,OAAS,KAG1B4F,EAAUD,YAAY4L,GACtB3L,EAAUD,YAAY+L,GAGtBl1C,QAAQC,IAAI,gEAEL,CAAE4yC,QAASzJ,EACxB,CAAW,GAAIlwB,EAAMk3B,QAAS,CAExB,MAAMnmB,EAAQ/Q,EAAMm3B,WAAW,IAAM,GAC/BltC,EAAS+V,EAAMm3B,WAAW,IAAM,GAGhCjH,EAAY7f,SAASuf,cAAc,OACzCM,EAAUlwB,MAAMwT,SAAW,WAC3B0c,EAAUlwB,MAAM+Q,MAAQ,IACxBmf,EAAUlwB,MAAM/V,OAAS,IAGzB,MAAMiyC,EAAM7rB,SAASuf,cAAc,OAcnC,OAbAsM,EAAIrM,IAAM7vB,EAAMk3B,QAChBgF,EAAIl8B,MAAMwT,SAAW,WACrB0oB,EAAIl8B,MAAM+Q,MAAQ,GAAGA,MACrBmrB,EAAIl8B,MAAM/V,OAAS,GAAGA,MACtBiyC,EAAIl8B,MAAMszB,MAAWviB,EAAM,EAAV,KACjBmrB,EAAIl8B,MAAMwzB,KAAUvpC,EAAJ,KAGhBimC,EAAUD,YAAYiM,GAGtBp1C,QAAQC,IAAI,8DAEL,CAAE4yC,QAASzJ,EACxB,CAAW,CAEL,MAAM3kB,EAAOvL,EAAMuL,MAAQ,GAGrB4wB,EAAY9rB,SAASuf,cAAc,OAazC,GAZAuM,EAAUn8B,MAAM+Q,MAAkB,EAAPxF,EAAH,KACxB4wB,EAAUn8B,MAAM/V,OAAmB,EAAPshB,EAAH,KACzB4wB,EAAUn8B,MAAM60B,aAAe,MAC/BsH,EAAUn8B,MAAM80B,gBAAkBjkB,EAClCsrB,EAAUn8B,MAAMi8B,OAAS,GAAGj8B,EAAM8Q,cAAgB,aAAa9Q,EAAM4Q,cAAgB,UACrFurB,EAAUn8B,MAAMo8B,UAAY,aAC5BD,EAAUn8B,MAAMwT,SAAW,WAG3B2oB,EAAUn8B,MAAMq8B,OAAS,IAAI9wB,YAAeA,MAGxCvL,EAAMs8B,cAAe,CAEvB,MAAMC,EAAQlsB,SAASuf,cAAc,OACrC2M,EAAMv8B,MAAMwT,SAAW,WACvB+oB,EAAMv8B,MAAM+Q,MAAQ,MACpBwrB,EAAMv8B,MAAM/V,OAAS,MACrBsyC,EAAMv8B,MAAM80B,gBAAkB,QAC9ByH,EAAMv8B,MAAMszB,KAAO,MACnBiJ,EAAMv8B,MAAMwzB,IAAM,MAGlB,MAAMgJ,EAAQnsB,SAASuf,cAAc,OACrC4M,EAAMx8B,MAAMwT,SAAW,WACvBgpB,EAAMx8B,MAAM+Q,MAAQ,MACpByrB,EAAMx8B,MAAM/V,OAAS,MACrBuyC,EAAMx8B,MAAM80B,gBAAkB,QAC9B0H,EAAMx8B,MAAMszB,KAAO,MACnBkJ,EAAMx8B,MAAMwzB,IAAM,MAElB2I,EAAUlM,YAAYsM,GACtBJ,EAAUlM,YAAYuM,EAC9B,CAKM,OAFA11C,QAAQC,IAAI,gDAEL,CAAE4yC,QAASwC,EACxB,CACA,CAOE,0BAAA5C,GACE,OAAO7K,OAAOC,QACJD,OAAOC,OAAOC,MACdF,OAAOC,OAAOC,KAAKkC,QACnBpC,OAAOC,OAAOC,KAAKkC,OAAO8I,qBACxC,CAQE,gBAAA+B,CAAiBlR,GASf,MARsB,CACpB,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,UACH,EAAG,WAGgBA,IAAY,SACrC,ECp5BO,MAAMgS,EAOX,WAAA32C,CAAYgS,EAAK4kC,EAAmB3oC,EAAU,CAAA,GAC5ChO,KAAK+R,IAAMA,EACX/R,KAAK22C,kBAAoBA,EACzB32C,KAAKgO,QAAUA,EAGfhO,KAAK42C,OAAS,IAAIj1C,IAGlB3B,KAAKy5B,iBAAmB,IAAI93B,IAGxBqM,EAAQ6oC,cACV72C,KAAK82C,YAAY9oC,EAAQ6oC,aAE/B,CASE,2BAAAE,CAA4B37B,EAAS64B,GAC9B74B,GAAYA,EAAQjb,IAA4B,mBAAfib,EAAQjb,IAM9Cib,EAAQjb,GAAG,YAAY,KACrBY,QAAQC,IAAI,WAAWoa,EAAQ1B,8BAC/B1Z,KAAKy5B,iBAAiBnyB,IAAI8T,EAAQ1B,GAAIu6B,GACtCj0C,KAAK22C,kBAAkBzD,iBAAiBe,GAAiB+C,OAAM91C,IAC7DH,QAAQG,MAAM,8BAA8Bka,EAAQ1B,MAAOxY,EAAM,GACjE,IAIJka,EAAQjb,GAAG,cAAc,KACvBY,QAAQC,IAAI,WAAWoa,EAAQ1B,gCAC/B1Z,KAAKy5B,iBAAiBzU,OAAO5J,EAAQ1B,IACrC1Z,KAAK22C,kBAAkBxD,mBAAmBc,GAAiB+C,OAAM91C,IAC/DH,QAAQG,MAAM,gCAAgCka,EAAQ1B,MAAOxY,EAAM,GACnE,KAnBFH,QAAQ2D,KAAK,8DAqBnB,CAQE,WAAAoyC,CAAYG,EAASjpC,EAAU,IAC7B,GAAIhO,KAAK42C,OAAOhtC,IAAIqtC,GAClB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQ,CACZx9B,GAAIu9B,EACJjpC,UACA0W,SAAU,IAAI/iB,IACd0Y,SAA6B,IAApBrM,EAAQqM,QACjB05B,YAAmC,IAAvB/lC,EAAQ+lC,WACpBz5B,UAA+B,IAArBtM,EAAQsM,UAIpB,OADAta,KAAK42C,OAAOtvC,IAAI2vC,EAASC,GAClBA,CACX,CAOE,iBAAM3F,CAAY0F,GAChB,IAAKj3C,KAAK42C,OAAOhtC,IAAIqtC,GACnB,OAAOtyC,QAAQC,UAGjB,MAAMsyC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAGxBE,EAAiB,GACvB,IAAK,MAAM/7B,KAAW87B,EAAMxyB,SAAS1a,SACnCmtC,EAAe72C,KAAKN,KAAK22C,kBAAkB9xB,cAAczJ,IAQ3D,aALMzW,QAAQosC,IAAIoG,GAGlBn3C,KAAK42C,OAAO5xB,OAAOiyB,GAEZtyC,QAAQC,SACnB,CAQE,wBAAMwyC,CAAmBH,EAAS58B,GAChC,IAAKra,KAAK42C,OAAOhtC,IAAIqtC,GACnB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAG9B,GAAIC,EAAM78B,UAAYA,EACpB,OAAO1V,QAAQC,UAGjBsyC,EAAM78B,QAAUA,EAGhB,MAAMg9B,EAAW,GACjB,IAAK,MAAMj8B,KAAW87B,EAAMxyB,SAAS1a,SAC/BqQ,EAEFg9B,EAAS/2C,KACPN,KAAK22C,kBAAkBjC,oBACrBt5B,EAAQ4d,gBACR5d,EAAQlW,OAKZmyC,EAAS/2C,KAAKN,KAAK22C,kBAAkB9xB,cAAczJ,IAMvD,aAFMzW,QAAQosC,IAAIsG,GAEX1yC,QAAQC,SACnB,CAUE,gBAAM+f,CAAWsyB,EAAS77B,EAAS6L,EAAajZ,EAAU,CAAA,GACxD,IAAKhO,KAAK42C,OAAOhtC,IAAIqtC,GACnB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAG9B,IAAIhD,EAAkB,KAEtB,GAAIiD,EAAM78B,QACR,OAAQ4M,GACR,IAAK,QACHgtB,QAAwBj0C,KAAK22C,kBAAkB/D,YAAYx3B,EAASpN,GACpE,MAEF,IAAK,OACHimC,QAAwBj0C,KAAK22C,kBAAkB7D,WAAW13B,EAASpN,GACnE,MAEF,IAAK,UACHimC,QAAwBj0C,KAAK22C,kBAAkB5D,cAAc33B,EAASpN,GACtE,MAEF,QACE,MAAM,IAAIvM,MAAM,6BAA6BwlB,SAE1C,CAGLgtB,EAAkB,CAChBv6B,GAFS0B,EAAQ1B,IAAM,WAAWC,KAAKC,SAASpX,KAAKqX,MAAsB,IAAhBrX,KAAKsX,YAGhEkf,gBAAiB5d,EACjBkB,eAAgB,KAChBpX,KAAM+hB,EACNqwB,aAAa,EAErB,CAmBI,OAhBAJ,EAAMxyB,SAASpd,IAAI2sC,EAAgBv6B,GAAIu6B,GAGvCj0C,KAAK+2C,4BAA4B37B,EAAS64B,GAGtC74B,EAAQhB,WACVrZ,QAAQC,IAAI,WAAWoa,EAAQ1B,uDAC/B1Z,KAAKy5B,iBAAiBnyB,IAAI8T,EAAQ1B,GAAIu6B,GAClCA,EAAgB33B,gBAClBtc,KAAK22C,kBAAkBzD,iBAAiBe,GAAiB+C,OAAM91C,IAC7DH,QAAQG,MAAM,8BAA8Bka,EAAQ1B,MAAOxY,EAAM,KAKhE+yC,CACX,CAQE,mBAAMpvB,CAAcoyB,EAASlyB,GAC3B,IAAK/kB,KAAK42C,OAAOhtC,IAAIqtC,GACnB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAE9B,IAAKC,EAAMxyB,SAAS9a,IAAImb,GACtB,OAAOpgB,QAAQC,UAGjB,MAAMqvC,EAAkBiD,EAAMxyB,SAAS/d,IAAIoe,GACrCiU,EAAkBib,EAAgBjb,gBAgBxC,GAbIh5B,KAAKy5B,iBAAiB7vB,IAAImb,KAC5BhkB,QAAQC,IAAI,6BAA6B+jB,6BACzC/kB,KAAKy5B,iBAAiBzU,OAAOD,IAI3BiU,GAAkD,mBAAxBA,EAAgB73B,MAC5CJ,QAAQC,IAAI,yCAAyC+jB,KACrDiU,EAAgB73B,IAAI,YACpB63B,EAAgB73B,IAAI,eAIlB8yC,EAAgB33B,eAAgB,CAElC,GAAI23B,EAAgB33B,eAAeu4B,eACjC,UACQ70C,KAAK22C,kBAAkBxD,mBAAmBc,EACjD,CAAC,MAAO/yC,GACPH,QAAQG,MAAM,gDAAgDA,EAAMuC,UAC9E,OAGYzD,KAAK22C,kBAAkB9xB,cAAcovB,EACjD,CAKI,OAFAiD,EAAMxyB,SAASM,OAAOD,GAEfpgB,QAAQC,SACnB,CAUE,mBAAMwiB,CAAc6vB,EAASlyB,EAAW6vB,EAAgB5mC,EAAU,CAAA,GAChE,IAAKhO,KAAK42C,OAAOhtC,IAAIqtC,GACnB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAE9B,IAAKC,EAAMxyB,SAAS9a,IAAImb,GACtB,MAAM,IAAItjB,MAAM,oBAAoBsjB,+BAAuCkyB,MAG7E,MAAMM,EAAkBL,EAAMxyB,SAAS/d,IAAIoe,GAG3C,IAAIyyB,EAmBJ,OAhBEA,EADEN,EAAM78B,SAAWk9B,EAAgBj7B,qBACJtc,KAAK22C,kBAAkBvvB,cACpDmwB,EACA3C,EACA5mC,GAIuB,IACpBupC,EACHve,gBAAiB4b,GAKrBsC,EAAMxyB,SAASpd,IAAIyd,EAAWyyB,GAEvBA,CACX,CAME,SAAAC,GACE,OAAO96B,MAAMrM,KAAKtQ,KAAK42C,OAAO5sC,SAClC,CAOE,QAAA0tC,CAAST,GACP,OAAOj3C,KAAK42C,OAAOjwC,IAAIswC,IAAY,IACvC,CAOE,gBAAAU,CAAiBV,GACf,IAAKj3C,KAAK42C,OAAOhtC,IAAIqtC,GACnB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAC9B,OAAOt6B,MAAMrM,KAAK4mC,EAAMxyB,SAAS1a,SACrC,CAQE,UAAAib,CAAWgyB,EAASlyB,GAClB,IAAK/kB,KAAK42C,OAAOhtC,IAAIqtC,GACnB,OAAO,KAIT,OADcj3C,KAAK42C,OAAOjwC,IAAIswC,GACjBvyB,SAAS/d,IAAIoe,IAAc,IAC5C,CAQE,oBAAM6yB,CAAeX,EAASjpC,EAAU,IACtC,IAAKhO,KAAK42C,OAAOhtC,IAAIqtC,GACnB,MAAM,IAAIx1C,MAAM,kBAAkBw1C,qBAGpC,MAAMC,EAAQl3C,KAAK42C,OAAOjwC,IAAIswC,GAE9B,GAA4B,IAAxBC,EAAMxyB,SAASc,KACjB,OAAO7gB,QAAQC,UAIjB,MAAMizC,EAAiB,GAEvB,IAAK,MAAMz8B,KAAW87B,EAAMxyB,SAAS1a,SAAU,CAC7C,MAAM8tC,EAAgB93C,KAAK+3C,uBAAuB38B,GAClDy8B,EAAev3C,QAAQw3C,EAC7B,CAEI,OAA8B,IAA1BD,EAAe7qC,cAKbhN,KAAK+R,IAAIi1B,UAAU6Q,EAAgB7pC,GAJhCrJ,QAAQC,SAOrB,CAQE,sBAAAmzC,CAAuB38B,GACrB,IAAKA,EAAQ4d,gBACX,MAAO,GAGT,OAAQ5d,EAAQlW,MAChB,IAAK,QACH,MAAO,CAACkW,EAAQ4d,gBAAgBp2B,YAElC,IAAK,OACL,IAAK,UACH,OAAOwY,EAAQ4d,gBAAgB9sB,aAAe,GAEhD,QACE,MAAO,GAEb,ECnYO,SAASomC,EAAU0F,EAAUhqC,EAAU,IAC5C,OAAOiqC,WAAW3F,UAAU0F,EAAUhqC,EACxC,CAMO,SAAS0kC,IACd,OAAOuF,WAAWvF,uBACpB,CC/BO,MAAMwF,UAA8Bp4C,EAKzC,WAAAC,CAAYiO,EAAU,IACpBlJ,QAEA9E,KAAK+R,IAAM/D,EAAQ+D,IACnB/R,KAAKunB,eAAiBvZ,EAAQuZ,eAE9BvnB,KAAKgO,QAAU,CACbwa,KAAM,QACN5Y,UAAU,EACVkkB,mBAAmB,EACnB5K,YAAa,CACX4B,MAAO,UACPtF,KAAM,GAERuD,WAAY,CACV+B,MAAO,UACPE,MAAO,GAETmJ,cAAe,CACb7K,UAAW,0BACXuB,aAAc,UACdE,aAAc,MAEb/c,GAGLhO,KAAKwnB,UAAW,EAChBxnB,KAAKm4C,UAAY,GACjBn4C,KAAKo4C,eAAiB,KACtBp4C,KAAKotB,SAAW,GAChBptB,KAAKq4C,QAAU,GACfr4C,KAAKorC,SAAW,KAChBprC,KAAK2R,QAAU,IACnB,CAME,QAAAgW,CAAS3Z,EAAU,IACbhO,KAAKwnB,UACPxnB,KAAKkoB,SAIP7hB,OAAOwhB,OAAO7nB,KAAKgO,QAASA,GAG5BhO,KAAKwnB,UAAW,EAGhBxnB,KAAKs4C,mBAGLv3C,QAAQC,IAAI,sCAAsChB,KAAKgO,QAAQwa,aAG/DxoB,KAAKa,KAAK,YAAa,CAAE2nB,KAAMxoB,KAAKgO,QAAQwa,MAChD,CAME,gBAAA8vB,GAEEt4C,KAAKu4C,sBAGL,MAAMC,EAAgB5P,OAAOC,KAAKzoC,MAAMqsC,YAAYzsC,KAAK+R,IAAK,QAAS/R,KAAK+pB,gBAAgBC,KAAKhqB,OAIjG,GAHAA,KAAKm4C,UAAU73C,KAAKk4C,GAGM,SAAtBx4C,KAAKgO,QAAQwa,MAAyC,YAAtBxoB,KAAKgO,QAAQwa,KAAoB,CACnE,MAAMiwB,EAAe7P,OAAOC,KAAKzoC,MAAMqsC,YAAYzsC,KAAK+R,IAAK,YAAa/R,KAAKiqB,oBAAoBD,KAAKhqB,OACxGA,KAAKm4C,UAAU73C,KAAKm4C,EAC1B,CACA,CAME,mBAAAF,GACEv4C,KAAKm4C,UAAUl3C,SAAQZ,IACrBuoC,OAAOC,KAAKzoC,MAAMwtC,eAAevtC,EAAS,IAE5CL,KAAKm4C,UAAY,EACrB,CAOE,eAAApuB,CAAgB3pB,GACd,MAAM2C,EAAM3C,EAAMi1B,OAAOtyB,MACnBL,EAAMtC,EAAMi1B,OAAO3yB,MAIzB,OAFA3B,QAAQC,IAAI,kBAAkB+B,MAAQL,QAAU1C,KAAKgO,QAAQwa,aAErDxoB,KAAKgO,QAAQwa,MACrB,IAAK,QACHxoB,KAAK21B,aAAa5yB,EAAKL,GACvB,MAEF,IAAK,OACH1C,KAAK04C,eAAe31C,EAAKL,GACzB,MAEF,IAAK,UACH1C,KAAK24C,kBAAkB51C,EAAKL,GAGlC,CAOE,mBAAAunB,CAAoB7pB,GAClB,IAAKJ,KAAKwnB,UAAqC,IAAzBxnB,KAAKotB,SAASpgB,OAAc,OAElD,MAAMjK,EAAM3C,EAAMi1B,OAAOtyB,MACnBL,EAAMtC,EAAMi1B,OAAO3yB,MAGC,SAAtB1C,KAAKgO,QAAQwa,KACfxoB,KAAK44C,mBAAmB71C,EAAKL,GACE,YAAtB1C,KAAKgO,QAAQwa,MACtBxoB,KAAK64C,sBAAsB91C,EAAKL,EAEtC,CAQE,YAAAizB,CAAa5yB,EAAKL,GAEhB,MAAMqoC,EAAS,IAAInC,OAAOC,KAAKmC,OAAO,CACpCvd,SAAU,CAAE1qB,MAAKL,OACjBqP,IAAK/R,KAAK+R,IACV64B,MAAO,UAAU7nC,EAAIC,QAAQ,OAAON,EAAIM,QAAQ,MAChD81C,UAAWlQ,OAAOC,KAAKkQ,UAAUC,OAGnCh5C,KAAKq4C,QAAQ/3C,KAAKyqC,GAGlB,MAAMnoC,EAAa,IAAIS,EAAWN,EAAKL,EAAK,GAC5C1C,KAAKa,KAAK,iBAAkB,CAC1BqE,KAAM,QACNtC,WAAYA,EACZmoC,OAAQA,IAIL/qC,KAAKgO,QAAQ8lB,mBAChB9zB,KAAK+nB,YAEX,CAQE,cAAA2wB,CAAe31C,EAAKL,GAElB1C,KAAKotB,SAAS9sB,KAAK,CAAEyC,MAAKL,QAG1B,MAAMqoC,EAAS,IAAInC,OAAOC,KAAKmC,OAAO,CACpCvd,SAAU,CAAE1qB,MAAKL,OACjBqP,IAAK/R,KAAK+R,IACV64B,MAAO,UAAU5qC,KAAKotB,SAASpgB,SAC/B69B,KAAM,CACJK,KAAMtC,OAAOC,KAAKoQ,WAAWC,OAC7B5vB,UAAWtpB,KAAKgO,QAAQ+a,WAAW+B,MACnC2gB,YAAa,EACbjH,aAAc,EACdjb,YAAa,UACb0jB,MAAO,KAOX,GAHAjtC,KAAKq4C,QAAQ/3C,KAAKyqC,GAGW,IAAzB/qC,KAAKotB,SAASpgB,OAChBhN,KAAKorC,SAAW,IAAIxC,OAAOC,KAAKwC,SAAS,CACvCH,KAAMlrC,KAAKotB,SACXinB,UAAU,EACV9qB,YAAavpB,KAAKgO,QAAQ+a,WAAW+B,MACrCqgB,cAAe,EACf3G,aAAcxkC,KAAKgO,QAAQ+a,WAAWiC,MACtCjZ,IAAK/R,KAAK+R,WAOZ,GAHA/R,KAAKorC,SAAS+N,QAAQn5C,KAAKotB,UAGvBptB,KAAKotB,SAASpgB,QAAU,EAAG,CAE7B,MAAM4M,EAAMD,KAAKC,MACjB,GAAI5Z,KAAKo5C,gBAAkBx/B,EAAM5Z,KAAKo5C,eAAiB,IAErD,YADAp5C,KAAKq5C,gBAGPr5C,KAAKo5C,eAAiBx/B,CAC9B,CAEA,CAQE,iBAAA++B,CAAkB51C,EAAKL,GAErB1C,KAAKotB,SAAS9sB,KAAK,CAAEyC,MAAKL,QAG1B,MAAMqoC,EAAS,IAAInC,OAAOC,KAAKmC,OAAO,CACpCvd,SAAU,CAAE1qB,MAAKL,OACjBqP,IAAK/R,KAAK+R,IACV64B,MAAO,UAAU5qC,KAAKotB,SAASpgB,SAC/B69B,KAAM,CACJK,KAAMtC,OAAOC,KAAKoQ,WAAWC,OAC7B5vB,UAAWtpB,KAAKgO,QAAQmmB,cAActJ,aACtC4gB,YAAa,EACbjH,aAAc,EACdjb,YAAa,UACb0jB,MAAO,KAOX,GAHAjtC,KAAKq4C,QAAQ/3C,KAAKyqC,GAGW,IAAzB/qC,KAAKotB,SAASpgB,OAEhBhN,KAAKorC,SAAW,IAAIxC,OAAOC,KAAKwC,SAAS,CACvCH,KAAMlrC,KAAKotB,SACXinB,UAAU,EACV9qB,YAAavpB,KAAKgO,QAAQmmB,cAActJ,aACxCsgB,cAAe,EACf3G,aAAcxkC,KAAKgO,QAAQmmB,cAAcpJ,aACzChZ,IAAK/R,KAAK+R,WAEP,GAA6B,IAAzB/R,KAAKotB,SAASpgB,OAAc,CAEjChN,KAAKorC,WACPprC,KAAKorC,SAAS7F,OAAO,MACrBvlC,KAAKorC,SAAW,MAIlBprC,KAAK2R,QAAU,IAAIi3B,OAAOC,KAAK6C,QAAQ,CACrCF,MAAO,IAAIxrC,KAAKotB,SAAUptB,KAAKotB,SAAS,IACxC7D,YAAavpB,KAAKgO,QAAQmmB,cAActJ,aACxCsgB,cAAe,EACf3G,aAAcxkC,KAAKgO,QAAQmmB,cAAcpJ,aACzCzB,UAAWtpB,KAAKgO,QAAQmmB,cAAc7K,UACtCmiB,YAAa,IACb15B,IAAK/R,KAAK+R,MAIZ,MAAM6H,EAAMD,KAAKC,MACjB,GAAI5Z,KAAKo5C,gBAAkBx/B,EAAM5Z,KAAKo5C,eAAiB,IAErD,YADAp5C,KAAKs5C,mBAGPt5C,KAAKo5C,eAAiBx/B,CACvB,MAAM,GAAI5Z,KAAKotB,SAASpgB,OAAS,EAAG,CAEnChN,KAAK2R,QAAQ4nC,SAAS,IAAIv5C,KAAKotB,SAAUptB,KAAKotB,SAAS,KAGvD,MAAMxT,EAAMD,KAAKC,MACjB,GAAI5Z,KAAKo5C,gBAAkBx/B,EAAM5Z,KAAKo5C,eAAiB,IAErD,YADAp5C,KAAKs5C,mBAGPt5C,KAAKo5C,eAAiBx/B,CAC5B,MAEM5Z,KAAKorC,SAAS+N,QAAQn5C,KAAKotB,SAEjC,CAQE,kBAAAwrB,CAAmB71C,EAAKL,GACtB,GAA6B,IAAzB1C,KAAKotB,SAASpgB,SAAiBhN,KAAKorC,SAAU,OAGlD,MAAMoO,EAAc,IAAIx5C,KAAKotB,SAAU,CAAErqB,MAAKL,QAC9C1C,KAAKorC,SAAS+N,QAAQK,EAC1B,CAQE,qBAAAX,CAAsB91C,EAAKL,GACzB,GAA6B,IAAzB1C,KAAKotB,SAASpgB,OAElB,GAAIhN,KAAKotB,SAASpgB,OAAS,GAEzB,GAAIhN,KAAKorC,SAAU,CACjB,MAAMoO,EAAc,IAAIx5C,KAAKotB,SAAU,CAAErqB,MAAKL,QAC9C1C,KAAKorC,SAAS+N,QAAQK,EAC9B,OAGM,GAAIx5C,KAAK2R,QAAS,CAChB,MAAM6nC,EAAc,IAAIx5C,KAAKotB,SAAU,CAAErqB,MAAKL,OAAO1C,KAAKotB,SAAS,IACnEptB,KAAK2R,QAAQ4nC,SAASC,EAC9B,CAEA,CAME,aAAAH,GACE,GAAIr5C,KAAKotB,SAASpgB,OAAS,EAAG,OAG9B,MAAMysC,EAAY,IAAI7Q,OAAOC,KAAKwC,SAAS,CACzCH,KAAMlrC,KAAKotB,SACXinB,UAAU,EACV9qB,YAAavpB,KAAKgO,QAAQ+a,WAAW+B,MACrCqgB,cAAe,EACf3G,aAAcxkC,KAAKgO,QAAQ+a,WAAWiC,MACtCjZ,IAAK/R,KAAK+R,MAIN7F,EAAclM,KAAKotB,SAASrb,KAAI+G,GAAK,IAAIzV,EAAWyV,EAAE/V,IAAK+V,EAAEpW,IAAK,KACxE1C,KAAKa,KAAK,iBAAkB,CAC1BqE,KAAM,OACNgH,YAAaA,EACbk/B,SAAUqO,IAIZz5C,KAAKkoB,SAGAloB,KAAKgO,QAAQ8lB,mBAChB9zB,KAAK+nB,YAEX,CAME,gBAAAuxB,GACE,GAAIt5C,KAAKotB,SAASpgB,OAAS,EAAG,OAG9B,MAAM0sC,EAAe,IAAI9Q,OAAOC,KAAK6C,QAAQ,CAC3CF,MAAOxrC,KAAKotB,SACZ7D,YAAavpB,KAAKgO,QAAQmmB,cAActJ,aACxCsgB,cAAe,EACf3G,aAAcxkC,KAAKgO,QAAQmmB,cAAcpJ,aACzCzB,UAAWtpB,KAAKgO,QAAQmmB,cAAc7K,UACtCmiB,YAAa,IACb15B,IAAK/R,KAAK+R,MAIN7F,EAAclM,KAAKotB,SAASrb,KAAI+G,GAAK,IAAIzV,EAAWyV,EAAE/V,IAAK+V,EAAEpW,IAAK,KACxE1C,KAAKa,KAAK,iBAAkB,CAC1BqE,KAAM,UACNgH,YAAaA,EACbyF,QAAS+nC,IAIX15C,KAAKkoB,SAGAloB,KAAKgO,QAAQ8lB,mBAChB9zB,KAAK+nB,YAEX,CAME,MAAAG,GAEEloB,KAAKq4C,QAAQp3C,SAAQ8pC,GAAUA,EAAOxF,OAAO,QAC7CvlC,KAAKq4C,QAAU,GAGXr4C,KAAKorC,WACPprC,KAAKorC,SAAS7F,OAAO,MACrBvlC,KAAKorC,SAAW,MAIdprC,KAAK2R,UACP3R,KAAK2R,QAAQ4zB,OAAO,MACpBvlC,KAAK2R,QAAU,MAIjB3R,KAAKotB,SAAW,GAGhBptB,KAAKo5C,eAAiB,IAC1B,CAKE,UAAArxB,GACO/nB,KAAKwnB,WAGVxnB,KAAKu4C,sBAGLv4C,KAAKkoB,SAGLloB,KAAKwnB,UAAW,EAGhBxnB,KAAKa,KAAK,eACd,EC/YOsY,eAAe+sB,EAAWl4B,EAAU,IAKzC,aAHMoL,EAAepL,EAAQ2rC,MAGtB,CACLC,QAASC,EACTF,KAAM,CACJG,aAAa,EACbz2C,aACAyJ,iBACA/I,aACAyI,kBACApD,sBAGN,CAkHY,MAAC2wC,EAAS,CACpBC,QAASzZ,EACT0Z,KAAM,CACJ52C,aACAyJ,iBACA/I,aACAyI,kBACApD,qBACA5H,wBACAqD,yBACA/E,gBAEFo6C,SAAU,CACRzgC,cACAgD,eACA0B,cACAoD,iBACAkD,oBACA+gB,cACAE,aACAC,gBACAC,0BACAC,qBAEFlkC,IAAK,CACHqkC,eACAwB,iBACAc,mBACAE,oBACAsH,iBACAoC,6BACJ+F,WAAIA,EACAvB,eACA/D,oBACAS,8BACAd,YACAI,yBAEFyH,MAAO,CACLtmB,cACAtL,kBACAiQ,cACAzI,aACAyN,kBACAnW,WACA6wB,0BAKS2B,EAAU,QACVO,GAAa,IAAIzgC,MAAO0rB,iwBA5J9BlsB,eAA4BsvB,EAAa4R,EAASrsC,EAAU,CAAA,SAE3Dk4B,EAAWl4B,GAGjB,MAAM2Y,EAAesxB,EAAW3F,UAAU+H,EAAS,CACjD5R,iBACGz6B,EAAQ+6B,aAIPuR,EAAgB,IAAI/Z,EAAc,CACtC5Z,eACAqC,SAAU,CACRpZ,cAA+BnI,IAArBuG,EAAQ4B,UAAgC5B,EAAQ4B,SAC1DkkB,uBAAiDrsB,IAA9BuG,EAAQ8lB,mBAAyC9lB,EAAQ8lB,kBAC5E0M,SAAUxyB,EAAQwyB,WAAY,EAC9BC,WAAYzyB,EAAQyyB,YAAc,GAClCC,kBAAmB1yB,EAAQ0yB,mBAAqB,kBAC7C1yB,EAAQgb,YAKf,IAAiC,IAA7Bhb,EAAQusC,iBAA4B,CACtC,MAAM5D,EAAgC,WAAZ0D,EACxB,IAAIjH,EAA4BzsB,GAChC,IAAIgsB,EAAkBhsB,GAExB2zB,EAAcE,aAAe,IAAI9D,EAAa/vB,EAAcgwB,EAAmB,CAC7EE,aAAc,SAIhByD,EAAcE,aAAa1D,YAAY,SAAU,CAAE/8B,KAAM,SAAUM,SAAS,IAC5EigC,EAAcE,aAAa1D,YAAY,QAAS,CAAE/8B,KAAM,QAASM,SAAS,IAC1EigC,EAAcE,aAAa1D,YAAY,WAAY,CAAE/8B,KAAM,WAAYM,SAAS,IAChFigC,EAAcE,aAAa1D,YAAY,UAAW,CAChD/8B,KAAM,mBACNM,SAAS,EACTkqB,OAAQ,KAEd,CAEE,OAAO+V,CACT"}