/**
 * @brandon7lewis/gis-survey.js v1.0.68
 * Mapping and surveying tools module for GIS and RTK surveying
 * https://github.com/BrandonLewis/gis-survey.js
 * 
 * @license MIT
 * @copyright 2025 Brandon Lewis
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).GisSurvey={})}(this,(function(e){"use strict";class t{constructor(){this.events={},this.debugMode=!1}on(e,t){return this.events[e]||(this.events[e]=[]),this.events[e].push(t),()=>{this.events[e]=this.events[e].filter((e=>e!==t))}}addEventListener(e,t){return this.on(e,t)}once(e,t){const i=this.on(e,((...e)=>{i(),t(...e)}))}emit(e,t){this.debugMode&&console.log(`[EventEmitter] ${e}:`,t),this.events[e]&&this.events[e].forEach((i=>{try{i(t)}catch(t){console.error(`Error in event listener for '${e}':`,t)}}))}off(e,t){this.events[e]&&(this.events[e]=this.events[e].filter((e=>e!==t)))}removeEventListener(e,t){return this.off(e,t)}removeAllListeners(e){e?delete this.events[e]:this.events={}}setDebug(e){this.debugMode=e}}class i{constructor(){if(this.constructor===i)throw new Error("CoordinateTransformer is an abstract class and cannot be instantiated directly");this._transformCache=new Map,this._geoidCache=new Map,this._datelineHandled=!1}transform(e,t,i){throw new Error("Method transform() must be implemented by subclasses")}getSupportedProjections(){throw new Error("Method getSupportedProjections() must be implemented by subclasses")}convertEllipsoidalToOrthometric(e){throw new Error("Method convertEllipsoidalToOrthometric() must be implemented by subclasses")}convertOrthometricToEllipsoidal(e){throw new Error("Method convertOrthometricToEllipsoidal() must be implemented by subclasses")}clearCache(){this._transformCache.clear(),this._geoidCache.clear()}_crossesDateLine(e,t,i){return Math.abs(e.lng)>170}_getCacheKey(e,t,i){return`${e.lat.toFixed(9)}:${e.lng.toFixed(9)}:${e.elevation.toFixed(3)}:${t}:${i}`}_handleDateLineCrossing(e,t,i){if(this._datelineHandled)return this._datelineHandled=!1,this._doTransform(e,t,i);let o;this._datelineHandled=!0,o=e.lng>0?new l(e.lat,e.lng-360,e.elevation,e.heightReference,t):new l(e.lat,e.lng+360,e.elevation,e.heightReference,t);const n=this.transform(o,t,i);return n.lng<-180?n.lng+=360:n.lng>180&&(n.lng-=360),this._datelineHandled=!1,n}_logTransformationError(e,t,i,o){console.error(`Transformation error: ${e.message}`,{source:{projection:i,lat:t.lat,lng:t.lng,elev:t.elevation},target:o,error:e.stack})}}class o{static getHeight(e,t){if(e<-90||e>90||t<-180||t>180)throw new Error(`Invalid coordinates: ${e}, ${t}`);if(e>=24&&e<=50&&t>=-125&&t<=-66)return this._approximateUSGeoidHeight(e,t);let i=0;i=e>=0&&e<=90?e/90*15-30:e/-90*15-30;return i+=5*Math.sin((t+100)*Math.PI/180),i}static _approximateUSGeoidHeight(e,t){const i=[{lat:24,lng:-125,height:-32.5},{lat:24,lng:-66,height:-29.5},{lat:50,lng:-125,height:-22.5},{lat:50,lng:-66,height:-34}],o=(e-24)/26,n=(t- -125)/59;return(i[0].height*(1-n)+i[1].height*n)*(1-o)+(i[2].height*(1-n)+i[3].height*n)*o+Math.sin(8*e)*Math.sin(6*t)*2.5}static async loadModel(e){return console.warn(`GeoidModel.loadModel: ${e} not implemented. Using approximation.`),Promise.resolve(!1)}}var n=Object.freeze({__proto__:null,GeoidModel:o});class r extends i{constructor(){super(),this.projections={WGS84:{datum:"WGS84",type:"geographic",epsg:"4326",params:{}},NAD83:{datum:"NAD83",type:"geographic",epsg:"4269",params:{}},NAD27:{datum:"NAD27",type:"geographic",epsg:"4267",params:{}},UTM_NAD83_N:{datum:"NAD83",type:"utm",params:{north:!0}},UTM_NAD83_S:{datum:"NAD83",type:"utm",params:{north:!1}},StatePlane_NAD83:{datum:"NAD83",type:"stateplane",params:{}}},this.datumShifts={WGS84_to_NAD83:{dx:.99343,dy:-1.90331,dz:-.52655,rx:.025915,ry:.009426,rz:.011599,ds:-62e-5},NAD83_to_NAD27:{dx:-8,dy:160,dz:176}}}getSupportedProjections(){return Object.keys(this.projections)}transform(e,t,i){if(this._validateProjection(t),this._validateProjection(i),t===i)return e.clone();const o=this._getCacheKey(e,t,i),n=this._transformCache.get(o);if(n)return n;if(this._crossesDateLine(e,t,i))return this._handleDateLineCrossing(e,t,i);let r;try{let n,a;if("geographic"===this.projections[t].type)n=e.clone();else if("utm"===this.projections[t].type)n=this._utmToGeographic(e,this.projections[t].params);else{if("stateplane"!==this.projections[t].type)throw new Error(`Unsupported projection type: ${this.projections[t].type}`);n=this._statePlaneToGeographic(e)}const s=this.projections[t].datum,l=this.projections[i].datum;if(a=s===l?n:this._transformDatum(n,s,l),"geographic"===this.projections[i].type)r=a.clone(),r.projection=i;else if("utm"===this.projections[i].type)r=this._geographicToUtm(a,this.projections[i].params),r.projection=i;else{if("stateplane"!==this.projections[i].type)throw new Error(`Unsupported projection type: ${this.projections[i].type}`);r=this._geographicToStatePlane(a),r.projection=i}return this._transformCache.set(o,r),r}catch(o){throw this._logTransformationError(o,e,t,i),new Error(`Transformation failed from ${t} to ${i}: ${o.message}`)}}convertEllipsoidalToOrthometric(e){const t=this._getGeoidHeight(e.lat,e.lng);return new l(e.lat,e.lng,e.elevation-t,"orthometric",e.projection)}convertOrthometricToEllipsoidal(e){const t=this._getGeoidHeight(e.lat,e.lng);return new l(e.lat,e.lng,e.elevation+t,"ellipsoidal",e.projection)}_getGeoidHeight(e,t){const i=`${e.toFixed(4)}:${t.toFixed(4)}`,n=this._geoidCache.get(i);if(void 0!==n)return n;const r=o.getHeight(e,t);return this._geoidCache.set(i,r),r}_validateProjection(e){if(!this.projections[e])throw new Error(`Unsupported projection: ${e}. Supported projections are: ${this.getSupportedProjections().join(", ")}`)}_transformDatum(e,t,i){if(t===i)return e.clone();if("WGS84"===t&&"NAD83"===i)return this._applyHelmertTransformation(e,this.datumShifts.WGS84_to_NAD83);if("NAD83"===t&&"WGS84"===i)return this._applyHelmertTransformation(e,this._invertHelmertParams(this.datumShifts.WGS84_to_NAD83));if("NAD83"===t&&"NAD27"===i)return this._applyHelmertTransformation(e,this.datumShifts.NAD83_to_NAD27);if("NAD27"===t&&"NAD83"===i)return this._applyHelmertTransformation(e,this._invertHelmertParams(this.datumShifts.NAD83_to_NAD27));if("WGS84"===t&&"NAD27"===i){const t=this._transformDatum(e,"WGS84","NAD83");return this._transformDatum(t,"NAD83","NAD27")}if("NAD27"===t&&"WGS84"===i){const t=this._transformDatum(e,"NAD27","NAD83");return this._transformDatum(t,"NAD83","WGS84")}throw new Error(`Unsupported datum transformation: ${t} to ${i}`)}_applyHelmertTransformation(e,t){const i=this._geographicToECEF(e),o=t.dx||0,n=t.dy||0,r=t.dz||0,a=(t.rx||0)*Math.PI/648e3,s=(t.ry||0)*Math.PI/648e3,l=(t.rz||0)*Math.PI/648e3,h=(t.ds||0)/1e6,c=(1+h)*(i.x+l*i.y-s*i.z)+o,d=(1+h)*(-l*i.x+i.y+a*i.z)+n,g=(1+h)*(s*i.x-a*i.y+i.z)+r;return this._ecefToGeographic({x:c,y:d,z:g},e.heightReference)}_invertHelmertParams(e){return{dx:-(e.dx||0),dy:-(e.dy||0),dz:-(e.dz||0),rx:-(e.rx||0),ry:-(e.ry||0),rz:-(e.rz||0),ds:-(e.ds||0)}}_geographicToECEF(e){const t=.00669437999014,i=void 0!==e.lat?e.lat:e.y,o=void 0!==e.lng?e.lng:e.x,n=void 0!==e.elevation?e.elevation:void 0!==e.z?e.z:0;if(void 0===i||void 0===o)throw new Error("Invalid coordinate: missing latitude or longitude");const r=i*Math.PI/180,a=o*Math.PI/180,s=n,l=Math.sin(r),h=Math.cos(r),c=Math.sin(a),d=Math.cos(a),g=6378137/Math.sqrt(1-t*l*l);return{x:(g+s)*h*d,y:(g+s)*h*c,z:(g*(1-t)+s)*l,lat:i,lng:o,elevation:n,originalFormat:"geographic"}}_ecefToGeographic(e,t){const i=6378137,o=.00669437999014,n=i*Math.sqrt(1-o),r=e.x,a=e.y,s=e.z;if(void 0===r||void 0===a||void 0===s)throw new Error("Invalid ECEF coordinate: missing x, y, or z component");const h=Math.sqrt(r*r+a*a),c=Math.atan2(s*i,h*n),d=Math.sin(c),g=Math.cos(c),u=Math.atan2(s+o*n*d*d*d,h-o*i*g*g*g),p=Math.atan2(a,r),m=Math.sin(u),f=i/Math.sqrt(1-o*m*m),w=h/Math.cos(u)-f,v=180*u/Math.PI,y=180*p/Math.PI;return new l(v,y,w,t)}_utmToGeographic(e,t){throw new Error("UTM to Geographic conversion not fully implemented in SimpleWGS84Transformer")}_geographicToUtm(e,t){throw new Error("Geographic to UTM conversion not fully implemented in SimpleWGS84Transformer")}_statePlaneToGeographic(e){throw new Error("State Plane to Geographic conversion not fully implemented in SimpleWGS84Transformer")}_geographicToStatePlane(e){throw new Error("Geographic to State Plane conversion not fully implemented in SimpleWGS84Transformer")}}class a{static _instances=new Map;static _defaultType="simple";static setDefaultType(e){if(!["simple","proj4js"].includes(e))throw new Error(`Invalid transformer type: ${e}. Must be 'simple' or 'proj4js'`);this._defaultType=e}static getTransformer(e=null){const t=e||this._defaultType;if(this._instances.has(t))return this._instances.get(t);let i;switch(t){case"simple":i=new r;break;case"proj4js":throw this._checkForProj4js(),new Error('Proj4js transformer not yet implemented. Use "simple" for now.');default:throw new Error(`Unknown transformer type: ${t}`)}return this._instances.set(t,i),i}static _checkForProj4js(){return"undefined"!=typeof proj4||(console.warn("Proj4js transformer requested, but proj4js is not loaded. Make sure to include proj4.js in your project for full projection support."),!1)}static clearCache(){for(const e of this._instances.values())e.clearCache();this._instances.clear()}static isAvailable(e){switch(e){case"simple":return!0;case"proj4js":return this._checkForProj4js();default:return!1}}static getAllSupportedProjections(){const e={};return e.simple=(new r).getSupportedProjections(),this._checkForProj4js()&&(e.proj4js=["Many EPSG codes supported when proj4js is loaded"]),e}}var s=Object.freeze({__proto__:null,TransformerFactory:a});class l{constructor(e,t,i=0,o="ellipsoidal",n="WGS84"){try{"string"==typeof e&&(e=parseFloat(e)),"string"==typeof t&&(t=parseFloat(t)),"string"==typeof i&&(i=parseFloat(i)),(null==e||isNaN(e))&&(console.warn("Invalid latitude provided, defaulting to 0"),e=0),(null==t||isNaN(t))&&(console.warn("Invalid longitude provided, defaulting to 0"),t=0),(e<-90||e>90)&&(console.warn(`Latitude ${e} out of bounds, clamping to valid range`),e=Math.max(-90,Math.min(90,e))),(t<-180||t>180)&&(console.warn(`Longitude ${t} out of bounds, clamping to valid range`),t=Math.max(-180,Math.min(180,t)));const r=null==i||isNaN(i)?0:i;["ellipsoidal","orthometric"].includes(o)||(console.warn(`Invalid height reference: ${o}, using default 'ellipsoidal'`),o="ellipsoidal"),this.lat=e,this.lng=t,this.elevation=r,this.heightReference=o,this.projection=n||"WGS84",this.transformer=a.getTransformer()}catch(e){console.error("Error in Coordinate constructor:",e),this.lat=0,this.lng=0,this.elevation=0,this.heightReference="ellipsoidal",this.projection="WGS84",this.transformer=a.getTransformer()}}static fromObject(e){try{if(!e||"object"!=typeof e)return console.warn("Invalid object passed to Coordinate.fromObject",e),new l(0,0,0);let t=void 0!==e.lat?e.lat:void 0!==e.latitude?e.latitude:void 0!==e.y?e.y:0,i=void 0!==e.lng?e.lng:void 0!==e.longitude?e.longitude:void 0!==e.x?e.x:0;const o=void 0!==e.elevation?e.elevation:void 0!==e.altitude?e.altitude:void 0!==e.alt?e.alt:void 0!==e.z?e.z:0;if("function"==typeof e.lat&&"function"==typeof e.lng)try{t=e.lat(),i=e.lng()}catch(e){console.warn("Error extracting lat/lng from Google Maps LatLng object",e)}return new l(t,i,o,e.heightReference||"ellipsoidal",e.projection||"WGS84")}catch(e){return console.error("Error in Coordinate.fromObject:",e),new l(0,0,0)}}toProjection(e){return this.projection===e?this.clone():this.transformer.transform(this,this.projection,e)}toHeightReference(e){if(this.heightReference===e)return this.clone();if("orthometric"===e&&"ellipsoidal"===this.heightReference)return this.transformer.convertEllipsoidalToOrthometric(this);if("ellipsoidal"===e&&"orthometric"===this.heightReference)return this.transformer.convertOrthometricToEllipsoidal(this);throw new Error(`Unsupported height reference conversion: ${this.heightReference} to ${e}`)}distanceTo(e){let t=e;e.projection!==this.projection&&(t=e.toProjection(this.projection)),t.heightReference!==this.heightReference&&(t=t.toHeightReference(this.heightReference));const i=this.lat*Math.PI/180,o=t.lat*Math.PI/180,n=(t.lat-this.lat)*Math.PI/180,r=(t.lng-this.lng)*Math.PI/180,a=Math.sin(n/2)*Math.sin(n/2)+Math.cos(i)*Math.cos(o)*Math.sin(r/2)*Math.sin(r/2),s=6371e3*(2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a))),l=t.elevation-this.elevation;return Math.sqrt(s*s+l*l)}bearingTo(e){const t=e.projection!==this.projection?e.toProjection(this.projection):e,i=this.lat*Math.PI/180,o=t.lat*Math.PI/180,n=this.lng*Math.PI/180,r=t.lng*Math.PI/180,a=Math.sin(r-n)*Math.cos(o),s=Math.cos(i)*Math.sin(o)-Math.sin(i)*Math.cos(o)*Math.cos(r-n);let l=180*Math.atan2(a,s)/Math.PI;return l=(l+360)%360,l}midpointTo(e){let t=e;e.projection!==this.projection&&(t=e.toProjection(this.projection)),t.heightReference!==this.heightReference&&(t=t.toHeightReference(this.heightReference));const i=this.lat*Math.PI/180,o=this.lng*Math.PI/180,n=t.lat*Math.PI/180,r=t.lng*Math.PI/180,a=Math.cos(n)*Math.cos(r-o),s=Math.cos(n)*Math.sin(r-o),h=Math.atan2(Math.sin(i)+Math.sin(n),Math.sqrt((Math.cos(i)+a)*(Math.cos(i)+a)+s*s)),c=o+Math.atan2(s,Math.cos(i)+a),d=(this.elevation+t.elevation)/2;return new l(180*h/Math.PI,180*c/Math.PI,d,this.heightReference,this.projection)}clone(){return new l(this.lat,this.lng,this.elevation,this.heightReference,this.projection)}toObject(){return{lat:this.lat,lng:this.lng,elevation:this.elevation,heightReference:this.heightReference,projection:this.projection}}toGeoJSON(){const e="WGS84"!==this.projection?this.toProjection("WGS84"):this;return{type:"Point",coordinates:[e.lng,e.lat,e.elevation]}}toString(){return`${this.lat.toFixed(7)},${this.lng.toFixed(7)},${this.elevation.toFixed(2)} (${this.projection}, ${this.heightReference})`}toCompactString(){return`${this.lat.toFixed(5)},${this.lng.toFixed(5)}`}setZ(e){const t=null!=e?e:0;if(!Number.isFinite(t))throw new Error(`Invalid elevation: ${e}. Must be a number.`);return this.elevation=t,this}}var h=Object.freeze({__proto__:null,Coordinate:l});const c={standardizeCoordinate(e){if(!e||"object"!=typeof e)return console.warn("Invalid coordinate object provided to standardizeCoordinate"),null;const t=void 0!==e.lat?e.lat:void 0!==e.latitude?e.latitude:void 0!==e.y?e.y:null,i=void 0!==e.lng?e.lng:void 0!==e.longitude?e.longitude:void 0!==e.x?e.x:null,o=void 0!==e.elevation?e.elevation:void 0!==e.altitude?e.altitude:void 0!==e.alt?e.alt:void 0!==e.z?e.z:0;return null===t||null===i?(console.warn("Cannot standardize coordinate without lat/lng or x/y properties"),e):{lat:t,lng:i,elevation:o,latitude:t,longitude:i,x:i,y:t,z:o,...e}},toCoordinate(e){return e instanceof l?e:l.fromObject(this.standardizeCoordinate(e))},extractStandardValues(e){const t=this.standardizeCoordinate(e);return{lat:t.lat,lng:t.lng,elevation:t.elevation}},cloneWithStandardProperties(e){const t=this.standardizeCoordinate(e);return{lat:t.lat,lng:t.lng,elevation:t.elevation}}};class d{static calculateElevationGain(e){if(!e||e.length<2)return 0;let t=0;for(let i=1;i<e.length;i++){const o=e[i-1],n=e[i];if(void 0===o.elevation||null===o.elevation||void 0===n.elevation||null===n.elevation)continue;const r=n.elevation-o.elevation;r>0&&(t+=r)}return t}static calculateElevationLoss(e){if(!e||e.length<2)return 0;let t=0;for(let i=1;i<e.length;i++){const o=e[i-1],n=e[i];if(void 0===o.elevation||null===o.elevation||void 0===n.elevation||null===n.elevation)continue;const r=n.elevation-o.elevation;r<0&&(t+=Math.abs(r))}return t}static _getCoordinateClass(){return{Coordinate:l}}static _EARTH_RADIUS_M=6371e3;static _WGS84_SEMI_MAJOR_AXIS=6378137;static _WGS84_SEMI_MINOR_AXIS=6356752.314245;static _WGS84_FLATTENING=1/298.257223563;nearestPointOnSegment(e,t,i){return d.nearestPointOnSegment(e,t,i)}static calculateDistance(e,t,i={}){if(!e||!t||"object"!=typeof e||"object"!=typeof t)return console.error("Invalid coordinate format for distance calculation"),0;const o=!1!==i.includeElevation,n=e=>void 0!==e.lat?e.lat:void 0!==e.latitude?e.latitude:null,r=e=>void 0!==e.lng?e.lng:void 0!==e.longitude?e.longitude:null,a=n(e),s=r(e),h=n(t),c=r(t);if(null===a||null===s||null===h||null===c)return console.error("Coordinates missing lat/lng properties for distance calculation"),0;const d={lat:a,lng:s,elevation:void 0!==e.elevation?e.elevation:0},g={lat:h,lng:c,elevation:void 0!==t.elevation?t.elevation:0};if(o&&e instanceof l&&t instanceof l&&"function"==typeof e.distanceTo)return e.distanceTo(t);if(o){const e=this._calculateApproximateDistance(d,g),t=(void 0!==g.elevation?g.elevation:0)-(void 0!==d.elevation?d.elevation:0);return Math.sqrt(e*e+t*t)}return this._calculateApproximateDistance(d,g)}static calculateArea(e,t={}){const i=!1!==t.includeElevation;if(e.length<3)return 0;const o=e[0],n=e[e.length-1],r=o.lat===n.lat&&o.lng===n.lng?e:[...e,e[0]];return this._isSelfIntersecting(r)?this._calculateAreaWithTriangulation(r,t):i?this._calculate3DArea(r):this._calculate2DSphericalArea(r)}static calculatePerimeter(e,t={}){const i=!1!==t.includeElevation;if(e.length<2)return 0;let o=0;for(let t=0;t<e.length-1;t++)o+=this.calculateDistance(e[t],e[t+1],{includeElevation:i});if(e.length>=3){const t=e[0],n=e[e.length-1];t.lat===n.lat&&t.lng===n.lng||(o+=this.calculateDistance(e[e.length-1],e[0],{includeElevation:i}))}return o}static calculatePathLength(e,t={}){return this.calculatePerimeter(e,t)}static calculatePerpendicularOffset(e,t,i,o,n={}){if(e.length<2||t<0||t>=e.length-1)throw new Error("Invalid coordinates or point index for perpendicular offset");const r=!1!==n.enable3D,a=e[t],s=e[t+1],h=Math.max(0,Math.min(1,i)),c=new l(a.lat+h*(s.lat-a.lat),a.lng+h*(s.lng-a.lng),r?a.elevation+h*(s.elevation-a.elevation):null,a.heightReference,a.projection),d=a.bearingTo(s),g=(d+90)%360,u=this._calculateDestinationPoint(c,o,g);return r&&null!==c.elevation&&void 0!==c.elevation&&(u.elevation=c.elevation),{nearestPoint:c,offsetPoint:u,pointIndex:t,segmentPosition:h,segmentBearing:d,perpendicularBearing:g}}static calculateBearing(e,t){return e.bearingTo(t)}static createArc(e,t,i=0,o=360,n=32){const r=[],a=(o-i)/n;for(let o=0;o<=n;o++){const n=(i+o*a)*Math.PI/180,s=this._calculateDestinationPoint(e,t,n);r.push(s)}return r}static createCircle(e,t,i=32){return this.createArc(e,t,0,360,i)}static createRectangle(e,t,i,o=0){const n=o*Math.PI/180,r=t/2,a=i/2,s=[Math.atan2(-a,-r)+n,Math.atan2(-a,r)+n,Math.atan2(a,r)+n,Math.atan2(a,-r)+n],l=[Math.sqrt(r*r+a*a),Math.sqrt(r*r+a*a),Math.sqrt(r*r+a*a),Math.sqrt(r*r+a*a)],h=[];for(let t=0;t<4;t++){const i=(180*s[t]/Math.PI+360)%360;h.push(this._calculateDestinationPoint(e,l[t],i))}return h.push(h[0]),h}static isPointInPolygon(e,t){let i=!1;const o=t[0].lat===t[t.length-1].lat&&t[0].lng===t[t.length-1].lng?t:[...t,t[0]],n=e.projection,r=o.map((e=>e.projection!==n?e.toProjection(n):e));for(let t=0,o=r.length-1;t<r.length;o=t++){const n=r[t].lng,a=r[t].lat,s=r[o].lng,l=r[o].lat;a>e.lat!=l>e.lat&&e.lng<(s-n)*(e.lat-a)/(l-a)+n&&(i=!i)}return i}static pointInPolygon(e,t){return this.isPointInPolygon(e,t)}static calculateCentroid(e){if(e.length<3)throw new Error("Cannot calculate centroid: need at least 3 coordinates");let t=0,i=0,o=0;for(const n of e)t+=n.lat,i+=n.lng,o+=n.elevation;return new l(t/e.length,i/e.length,o/e.length,e[0].heightReference,e[0].projection)}static calculatePolygonCentroid(e,t=[]){if(!e||e.length<3)return console.warn("Cannot calculate polygon centroid: need at least 3 coordinates for exterior ring"),e&&e.length>0?e[0].clone():null;if(!t||0===t.length)return this.calculateCentroid(e);const i=this.calculateCentroid(e),o=t.filter((e=>e&&e.length>=3));if(0===o.length)return i;const n=this.calculateArea(e);if(0===n)return i;let r=n,a=i.lat*n,s=i.lng*n,h=i.elevation*n;for(const e of o){const t=this.calculateCentroid(e),i=this.calculateArea(e);r-=i,a-=t.lat*i,s-=t.lng*i,h-=t.elevation*i}return r<=0?i:new l(a/r,s/r,h/r,e[0].heightReference,e[0].projection)}static calculatePathCenter(e){if(0===e.length)throw new Error("Cannot calculate path center: no coordinates provided");if(1===e.length)return e[0].clone();if(2===e.length){const t=(e[0].lat+e[1].lat)/2,i=(e[0].lng+e[1].lng)/2,o=(e[0].elevation+e[1].elevation)/2;return new l(t,i,o,e[0].heightReference,e[0].projection)}const t=this.calculatePathLength(e)/2;let i=0;for(let o=0;o<e.length-1;o++){const n=this.calculateDistance(e[o],e[o+1],{includeElevation:!0});if(i+n>=t){const r=(t-i)/n,a=e[o].bearingTo(e[o+1]),s=this._calculateDestinationPoint(e[o],n*r,a);return s.elevation=e[o].elevation+(e[o+1].elevation-e[o].elevation)*r,s}i+=n}let o=0,n=0,r=0;for(const t of e)o+=t.lat,n+=t.lng,r+=t.elevation;return new l(o/e.length,n/e.length,r/e.length,e[0].heightReference,e[0].projection)}static createOffsetLine(e,t,i={}){if(e.length<2)throw new Error("Cannot create offset: need at least 2 coordinates");const o=i.closed||!1,n=[];for(let i=0;i<e.length-1;i++){const o=e[i],r=e[i+1],a=(o.bearingTo(r)+90)%360,s=this._calculateDestinationPoint(o,t,a);if(n.push(s),i===e.length-2){const e=this._calculateDestinationPoint(r,t,a);n.push(e)}}return o&&n.length>2&&n.push(n[0]),n}static nearestPointOnSegment(e,t,i){const o=this._findClosestPointOnLineSegment(i,e,t);return{point:o.point,distance:o.distance,fraction:o.fraction,segmentPosition:o.fraction}}static destinationCoordinate(e,t,i){return this._calculateDestinationPoint(e,t,i)}static _calculateDestinationPoint(e,t,i){const o=c.standardizeCoordinate(e);if(!o)return console.error("Invalid starting coordinate for destination calculation:",e),null;const n=this._EARTH_RADIUS_M,r=i*Math.PI/180,a=o.lat*Math.PI/180,s=o.lng*Math.PI/180,h=t/n,d=Math.sin(h),g=Math.cos(h),u=Math.sin(a),p=Math.cos(a),m=u*g+p*d*Math.cos(r),f=Math.asin(m),w=Math.sin(r)*d*p,v=g-u*m,y=s+Math.atan2(w,v),k=e.heightReference||e instanceof l?e.heightReference:"ellipsoidal",D=e.projection||e instanceof l?e.projection:"WGS84";return new l(180*f/Math.PI,(180*y/Math.PI+540)%360-180,o.elevation,k,D)}static _findClosestPointOnLineSegment(e,t,i){const o=c.toCoordinate(e),n=c.toCoordinate(t),r=c.toCoordinate(i),a=o.lng-n.lng,s=o.lat-n.lat,h=r.lng-n.lng,d=r.lat-n.lat,g=a*h+s*d,u=h*h+d*d,p=u>0?Math.max(0,Math.min(1,g/u)):0,m=n.lng+p*h,f=n.lat+p*d,w=n.elevation+p*(r.elevation-n.elevation),v=new l(f,m,w,n.heightReference,n.projection);return{point:v,distance:o.distanceTo(v),fraction:p}}static _lineSegmentsIntersect(e,t,i,o){const n={x:e.lng,y:e.lat},r={x:t.lng,y:t.lat},a={x:i.lng,y:i.lat},s={x:o.lng,y:o.lat},l=this._direction(a,s,n),h=this._direction(a,s,r),c=this._direction(n,r,a),d=this._direction(n,r,s);return(l>0&&h<0||l<0&&h>0)&&(c>0&&d<0||c<0&&d>0)||0===l&&this._onSegment(a,s,n)||0===h&&this._onSegment(a,s,r)||0===c&&this._onSegment(n,r,a)||0===d&&this._onSegment(n,r,s)}static _direction(e,t,i){return(i.x-e.x)*(t.y-e.y)-(t.x-e.x)*(i.y-e.y)}static _onSegment(e,t,i){return i.x<=Math.max(e.x,t.x)&&i.x>=Math.min(e.x,t.x)&&i.y<=Math.max(e.y,t.y)&&i.y>=Math.min(e.y,t.y)}static _isSelfIntersecting(e){for(let t=0;t<e.length-1;t++)for(let i=t+2;i<e.length-1;i++){if(0===t&&i===e.length-2)continue;const o=e[t],n=e[t+1],r=e[i],a=e[i+1];if(this._lineSegmentsIntersect(o,n,r,a))return!0}return!1}static hasSelfIntersections(e){return!(!e||e.length<4)&&this._isSelfIntersecting(e)}static _calculate2DSphericalArea(e){let t=0;for(let i=1;i<e.length-1;i++)t+=this._calculateSphericalTriangleArea(e[0],e[i],e[i+1]);return Math.abs(t)}static _calculateSphericalTriangleArea(e,t,i){const o=this._EARTH_RADIUS_M,n=e.lat*Math.PI/180,r=e.lng*Math.PI/180,a=t.lat*Math.PI/180,s=t.lng*Math.PI/180,l=i.lat*Math.PI/180,h=i.lng*Math.PI/180;return(Math.acos(Math.sin(a)*Math.sin(l)+Math.cos(a)*Math.cos(l)*Math.cos(s-h))+Math.acos(Math.sin(n)*Math.sin(l)+Math.cos(n)*Math.cos(l)*Math.cos(r-h))+Math.acos(Math.sin(n)*Math.sin(a)+Math.cos(n)*Math.cos(a)*Math.cos(r-s))-Math.PI)*o*o}static _calculateAreaWithTriangulation(e,t){return console.warn("Self-intersecting polygon detected. Area calculation may be inaccurate."),this._calculate2DSphericalArea(e)}static _calculate3DArea(e){if(e.length<3)return 0;const t=e.map((e=>this._geographicToCartesian(e))),i=this._calculateBestFitPlaneNormal(t),o=t.map((e=>this._projectPointOntoPlane(e,i,t[0])));let n=0;for(let e=0;e<o.length-1;e++){const t=o[e],i=o[e+1],r=this._crossProduct(t,i);n+=.5*this._vectorLength(r)}return n}static _calculateBestFitPlaneNormal(e){if(e.length<3)return{x:0,y:0,z:1};const t={x:e[1].x-e[0].x,y:e[1].y-e[0].y,z:e[1].z-e[0].z},i={x:e[2].x-e[0].x,y:e[2].y-e[0].y,z:e[2].z-e[0].z},o=this._crossProduct(t,i),n=this._vectorLength(o);return{x:o.x/n,y:o.y/n,z:o.z/n}}static _geographicToCartesian(e){const t=this._WGS84_SEMI_MAJOR_AXIS,i=.00669437999014,o=c.standardizeCoordinate(e);if(!o||null===o.lat||null===o.lng)return console.error("Invalid coordinate format for conversion:",e),{x:0,y:0,z:0,originalFormat:"cartesian"};const n=o.lat*Math.PI/180,r=o.lng*Math.PI/180,a=o.elevation,s=Math.sin(n),l=Math.cos(n),h=Math.sin(r),d=Math.cos(r),g=t/Math.sqrt(1-i*s*s);return{x:(g+a)*l*d,y:(g+a)*l*h,z:(g*(1-i)+a)*s,lat:o.lat,lng:o.lng,elevation:o.elevation,originalFormat:"geographic"}}static _projectPointOntoPlane(e,t,i){const o={x:e.x-i.x,y:e.y-i.y,z:e.z-i.z},n=this._dotProduct(o,t);return{x:e.x-n*t.x,y:e.y-n*t.y,z:e.z-n*t.z}}static _dotProduct(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}static _crossProduct(e,t){return{x:e.y*t.z-e.z*t.y,y:e.z*t.x-e.x*t.z,z:e.x*t.y-e.y*t.x}}static _vectorLength(e){return Math.sqrt(e.x*e.x+e.y*e.y+e.z*e.z)}static _calculateApproximateDistance(e,t){const i=this._EARTH_RADIUS_M,o=e.lat*Math.PI/180,n=t.lat*Math.PI/180,r=n-o,a=(t.lng-e.lng)*Math.PI/180,s=Math.sin(r/2)*Math.sin(r/2)+Math.cos(o)*Math.cos(n)*Math.sin(a/2)*Math.sin(a/2);return i*(2*Math.atan2(Math.sqrt(s),Math.sqrt(1-s)))}}async function g(e={}){const{transformerType:t="simple",geoidModel:i="default"}=e;if(e.transformerType)try{const{TransformerFactory:e}=await Promise.resolve().then((function(){return s}));e.setDefaultType(t)}catch(e){return console.error(`Failed to set transformer type: ${e.message}`),!1}if("default"!==i)try{const{GeoidModel:e}=await Promise.resolve().then((function(){return n}));await e.loadModel(i)}catch(e){return console.error(`Failed to load geoid model: ${e.message}`),!1}return!0}class u extends t{constructor(e={}){if(super(),this.constructor===u)throw new Error("Abstract class 'FeatureBase' cannot be instantiated directly.");this.id=e.id||`feature_${Date.now()}_${Math.floor(1e4*Math.random())}`,this.name=e.name||`Feature ${this.id.substr(-4)}`,this.type="feature",this.style=e.style||{},this.properties=e.properties||{},this.metadata=e.metadata||{},this.selected=!1,this.visible=!1!==e.visible,this.editable=!1!==e.editable,this.interactive=!1!==e.interactive,this.rendered=null,this.timestamp=e.timestamp||Date.now(),this.sourceData=e.sourceData||null}getType(){return this.type}getBounds(){throw new Error("Method 'getBounds()' must be implemented.")}getCenter(){throw new Error("Method 'getCenter()' must be implemented.")}getElevationRange(){throw new Error("Method 'getElevationRange()' must be implemented.")}contains(e,t={}){throw new Error("Method 'contains()' must be implemented.")}nearest(e){throw new Error("Method 'nearest()' must be implemented.")}toGeoJSON(e={}){throw new Error("Method 'toGeoJSON()' must be implemented.")}fromGeoJSON(e,t={}){throw new Error("Method 'fromGeoJSON()' must be implemented.")}clone(){throw new Error("Method 'clone()' must be implemented.")}setStyle(e,t={}){this.style={...this.style,...e},this.emit("style-changed",{feature:this,style:this.style,options:t})}getStyle(){return{...this.style}}setProperties(e){this.properties={...this.properties,...e},this.emit("properties-changed",{feature:this,properties:this.properties})}getProperties(){return{...this.properties}}getProperty(e){return this.properties[e]}setProperty(e,t){this.properties[e]=t,this.emit("property-changed",{feature:this,name:e,value:t})}setName(e){this.name=e,this.emit("name-changed",{feature:this,name:e})}getName(){return this.name}select(e={}){this.selected||(this.selected=!0,this.emit("selected",{feature:this,options:e}))}deselect(e={}){this.selected&&(this.selected=!1,this.emit("deselected",{feature:this,options:e}))}toggleSelection(e={}){return this.selected?this.deselect(e):this.select(e),this.selected}show(){this.visible||(this.visible=!0,this.emit("visibility-changed",{feature:this,visible:!0}))}hide(){this.visible&&(this.visible=!1,this.emit("visibility-changed",{feature:this,visible:!1}))}toggleVisibility(){return this.visible=!this.visible,this.emit("visibility-changed",{feature:this,visible:this.visible}),this.visible}enableEditing(){this.editable||(this.editable=!0,this.emit("editable-changed",{feature:this,editable:!0}))}disableEditing(){this.editable&&(this.editable=!1,this.emit("editable-changed",{feature:this,editable:!1}))}setRendered(e){this.rendered=e}getRendered(){return this.rendered}isRendered(){return null!==this.rendered}}class p extends u{constructor(e,t={}){if(super(t),this.type="point",e instanceof l)this.coordinate=e;else{if("object"!=typeof e)throw console.error("Invalid coordinate type:",typeof e),new Error("Point feature requires a valid coordinate");if(void 0!==e.latitude&&void 0!==e.longitude){const t=void 0!==e.elevation?e.elevation:void 0!==e.alt?e.alt:null;this.coordinate={lat:e.latitude,lng:e.longitude,elevation:t,toString:function(){return`${this.lat}, ${this.lng}, ${this.elevation||0}`}}}else if(void 0!==e.lat&&void 0!==e.lng){const t=void 0!==e.elevation?e.elevation:void 0!==e.alt?e.alt:null;e.toString||(e.toString=function(){return`${this.lat}, ${this.lng}, ${this.elevation||0}`}),null!=t&&(e.elevation=t),this.coordinate=e}else{if(!(Array.isArray(e)&&e.length>=2))throw console.error("Invalid coordinate format:",e),new Error("Invalid coordinate format");{const t=e[1],i=e[0],o=e.length>2?e[2]:null;this.coordinate={lat:t,lng:i,elevation:o,toString:function(){return`${this.lat}, ${this.lng}, ${this.elevation||0}`}}}}}if(!t.name){const e=this.coordinate.lat||this.coordinate.latitude,t=this.coordinate.lng||this.coordinate.longitude;this.name=`Point ${e.toFixed(5)}, ${t.toFixed(5)}`}const i=this.coordinate.elevation;null!=i&&(this.properties.elevation=i)}getCoordinate(){return this.coordinate}setCoordinate(e){if(!e||!(e instanceof l||"object"==typeof e&&(void 0!==e.lat||void 0!==e.latitude)))throw console.error("Invalid coordinate format:",e),new Error("Coordinate must be a valid coordinate-like object");{this.coordinate=e;const t=void 0!==e.elevation?e.elevation:void 0!==e.alt?e.alt:null;null!=t?this.properties.elevation=t:delete this.properties.elevation,this.emit("geometry-changed",{feature:this,coordinate:this.coordinate})}}getBounds(){return{northEast:this.coordinate.clone(),southWest:this.coordinate.clone(),north:this.coordinate.lat,east:this.coordinate.lng,south:this.coordinate.lat,west:this.coordinate.lng}}getCenter(){return this.coordinate}getElevationRange(){const e=this.coordinate.elevation||0;return{min:e,max:e,range:0}}contains(e,t={}){if(!e||"object"!=typeof e||void 0===e.lat&&void 0===e.latitude)return console.error("Invalid coordinate format:",e),!1;const i=t.tolerance||0;if(0===i){const t=this.coordinate.lat||this.coordinate.latitude,i=this.coordinate.lng||this.coordinate.longitude,o=e.lat||e.latitude,n=e.lng||e.longitude;return t===o&&i===n}try{return d.calculateDistance(this.coordinate,e,{includeElevation:t.includeElevation})<=i}catch(e){return console.error("Error calculating distance for contains check:",e),!1}}nearest(e){if(!e||"object"!=typeof e||void 0===e.lat&&void 0===e.latitude)throw console.error("Invalid coordinate format:",e),new Error("Coordinate must be a valid coordinate-like object");try{const t=d.calculateDistance(this.coordinate,e,{includeElevation:!0});return{coordinate:this.coordinate,distance:t}}catch(e){return console.error("Error calculating nearest point:",e),{coordinate:this.coordinate,distance:1/0}}}toGeoJSON(e={}){const t=!1!==e.includeElevation,i=!1!==e.includeProperties,o={type:"Feature",geometry:{type:"Point",coordinates:[this.coordinate.lng,this.coordinate.lat]},id:this.id};return t&&null!==this.coordinate.elevation&&void 0!==this.coordinate.elevation&&o.geometry.coordinates.push(this.coordinate.elevation),i&&(o.properties={name:this.name,...this.properties}),o}fromGeoJSON(e,t={}){if(!e||"Feature"!==e.type||!e.geometry||"Point"!==e.geometry.type||!Array.isArray(e.geometry.coordinates))return!1;const i=e.geometry.coordinates;if(i.length<2)return!1;const o=i[0],n=i[1],r=i.length>2?i[2]:null;return this.coordinate=new l(n,o,r),e.properties&&(e.properties.name&&(this.name=e.properties.name,delete e.properties.name),this.properties={...e.properties}),e.id&&(this.id=e.id),null!=r&&(this.properties.elevation=r),this.emit("geometry-changed",{feature:this,coordinate:this.coordinate}),!0}clone(){return new p(this.coordinate.clone(),{id:`clone_${this.id}`,name:`${this.name} (copy)`,style:{...this.style},properties:{...this.properties},metadata:{...this.metadata},visible:this.visible,editable:this.editable,interactive:this.interactive})}distanceTo(e,t={}){const i=e instanceof p?e.getCoordinate():e;if(!(i instanceof l))throw new Error("Point must be a PointFeature or Coordinate");return d.calculateDistance(this.coordinate,i,{includeElevation:!1!==t.includeElevation})}bearingTo(e){const t=e instanceof p?e.getCoordinate():e;if(!(t instanceof l))throw new Error("Point must be a PointFeature or Coordinate");return d.calculateBearing(this.coordinate,t)}moveByDistanceAndBearing(e,t,i={}){const o=!1!==i.preserveElevation,n=o?this.coordinate.elevation:null,r=d.destinationCoordinate(this.coordinate,e,t);return o&&null!=n&&(r.elevation=n),this.setCoordinate(r),this}moveTo(e){return this.setCoordinate(e),this}}var m=Object.freeze({__proto__:null,PointFeature:p});class f extends u{constructor(e=[],t={}){super(t),this.type="line",this.closed=t.closed||!1,this.coordinates=this._validateCoordinates(e),this._updateProperties(),t.name||(this.name=this.closed?`Closed Line (${this.coordinates.length} vertices)`:`Line (${this.coordinates.length} vertices)`)}_validateCoordinates(e){if(!Array.isArray(e))throw new Error("Coordinates must be an array");return e.map((e=>{if(e instanceof l)return e;if("object"==typeof e){if(void 0!==e.latitude&&void 0!==e.longitude){const t=void 0!==e.elevation?e.elevation:void 0!==e.alt?e.alt:null;return new l(e.latitude,e.longitude,t)}if(void 0!==e.lat&&void 0!==e.lng){const t=void 0!==e.elevation?e.elevation:void 0!==e.alt?e.alt:null;return new l(e.lat,e.lng,t)}if(Array.isArray(e)&&e.length>=2)return new l(e[1],e[0],e[2]||null)}throw new Error("Invalid coordinate format in array")}))}_updateProperties(){if(this.coordinates.length<2)return void(this.properties.length=0);this.properties.length=d.calculatePathLength(this.coordinates,{includeElevation:!0});const e=this.coordinates.map((e=>e.elevation)).filter((e=>null!=e));e.length>0&&(this.properties.minElevation=Math.min(...e),this.properties.maxElevation=Math.max(...e),this.properties.elevationGain=d.calculateElevationGain(this.coordinates),this.properties.elevationLoss=d.calculateElevationLoss(this.coordinates))}getCoordinates(){return[...this.coordinates]}setCoordinates(e){this.coordinates=this._validateCoordinates(e),this._updateProperties(),this.emit("geometry-changed",{feature:this,coordinates:this.coordinates})}addCoordinate(e,t=null){if(!(e instanceof l))throw new Error("Coordinate must be an instance of Coordinate class");null===t?this.coordinates.push(e):this.coordinates.splice(t,0,e),this._updateProperties(),this.emit("geometry-changed",{feature:this,coordinates:this.coordinates,action:"add",coordinate:e,index:null===t?this.coordinates.length-1:t})}removeCoordinate(e){if(e<0||e>=this.coordinates.length)return null;const t=this.coordinates.splice(e,1)[0];return this._updateProperties(),this.emit("geometry-changed",{feature:this,coordinates:this.coordinates,action:"remove",coordinate:t,index:e}),t}updateCoordinate(e,t){if(e<0||e>=this.coordinates.length)return!1;if(!(t instanceof l))throw new Error("Coordinate must be an instance of Coordinate class");const i=this.coordinates[e];return this.coordinates[e]=t,this._updateProperties(),this.emit("geometry-changed",{feature:this,coordinates:this.coordinates,action:"update",oldCoordinate:i,newCoordinate:t,index:e}),!0}getVertexCount(){return this.coordinates.length}getVertex(e){return e<0||e>=this.coordinates.length?null:this.coordinates[e]}toggleClosed(){return this.closed=!this.closed,this._updateProperties(),this.emit("closed-changed",{feature:this,closed:this.closed}),this.closed}setClosed(e){this.closed!==e&&(this.closed=e,this._updateProperties(),this.emit("closed-changed",{feature:this,closed:this.closed}))}isClosed(){return this.closed}getBounds(){if(0===this.coordinates.length)return null;let e=-90,t=90,i=-180,o=180;for(const n of this.coordinates)e=Math.max(e,n.lat),t=Math.min(t,n.lat),i=Math.max(i,n.lng),o=Math.min(o,n.lng);return{north:e,south:t,east:i,west:o,northEast:new l(e,i),southWest:new l(t,o)}}getCenter(){return 0===this.coordinates.length?null:1===this.coordinates.length?this.coordinates[0]:d.calculatePathCenter(this.coordinates)}getElevationRange(){if(0===this.coordinates.length)return{min:0,max:0,range:0};const e=this.coordinates.map((e=>e.elevation)).filter((e=>null!=e));if(0===e.length)return{min:0,max:0,range:0};const t=Math.min(...e),i=Math.max(...e);return{min:t,max:i,range:i-t}}contains(e,t={}){if(this.coordinates.length<2)return!1;if(!(e instanceof l))throw new Error("Coordinate must be an instance of Coordinate class");const i=t.tolerance||0;return this.nearest(e).distance<=i}nearest(e){if(this.coordinates.length<2){if(1===this.coordinates.length){const t=d.calculateDistance(this.coordinates[0],e,{includeElevation:!0});return{coordinate:this.coordinates[0].clone(),distance:t,segmentIndex:0,segmentFraction:0}}return{coordinate:null,distance:1/0,segmentIndex:-1,segmentFraction:0}}if(!(e instanceof l))throw new Error("Coordinate must be an instance of Coordinate class");return d.calculateNearestPointOnPath(this.coordinates,e,{closed:this.closed})}toGeoJSON(e={}){const t=!1!==e.includeElevation,i=!1!==e.includeProperties,o=this.closed?"Polygon":"LineString";let n;if("LineString"===o)n=this.coordinates.map((e=>{const i=[e.lng,e.lat];return t&&null!==e.elevation&&void 0!==e.elevation&&i.push(e.elevation),i}));else{const e=[...this.coordinates];e.length>0&&(e[0].lat!==e[e.length-1].lat||e[0].lng!==e[e.length-1].lng)&&e.push(e[0]),n=[e.map((e=>{const i=[e.lng,e.lat];return t&&null!==e.elevation&&void 0!==e.elevation&&i.push(e.elevation),i}))]}const r={type:"Feature",geometry:{type:o,coordinates:n},id:this.id};return i&&(r.properties={name:this.name,...this.properties}),r}fromGeoJSON(e,t={}){if(!e||"Feature"!==e.type||!e.geometry)return!1;const i=e.geometry.type;let o=[],n=!1;if("LineString"===i){if(!Array.isArray(e.geometry.coordinates))return!1;o=e.geometry.coordinates.map((e=>{if(!Array.isArray(e)||e.length<2)throw new Error("Invalid GeoJSON LineString coordinates");return new l(e[1],e[0],e.length>2?e[2]:null)}));const t=o[0],i=o[o.length-1];t&&i&&t.lat===i.lat&&t.lng===i.lng&&(n=!0)}else{if("Polygon"!==i)return!1;{if(!Array.isArray(e.geometry.coordinates)||!Array.isArray(e.geometry.coordinates[0]))return!1;o=e.geometry.coordinates[0].map((e=>{if(!Array.isArray(e)||e.length<2)throw new Error("Invalid GeoJSON Polygon coordinates");return new l(e[1],e[0],e.length>2?e[2]:null)}));const t=o[0],i=o[o.length-1];t&&i&&t.latitude===i.latitude&&t.longitude===i.longitude&&o.pop(),n=!0}}return this.coordinates=o,this.closed=n,e.properties&&(e.properties.name&&(this.name=e.properties.name,delete e.properties.name),this.properties={...e.properties}),e.id&&(this.id=e.id),this._updateProperties(),this.emit("geometry-changed",{feature:this,coordinates:this.coordinates}),!0}clone(){const e=this.coordinates.map((e=>e.clone()));return new f(e,{id:`clone_${this.id}`,name:`${this.name} (copy)`,style:{...this.style},properties:{...this.properties},metadata:{...this.metadata},visible:this.visible,editable:this.editable,interactive:this.interactive,closed:this.closed})}calculateLength(e={}){return this.coordinates.length<2?0:d.calculatePathLength(this.coordinates,{includeElevation:!1!==e.includeElevation,closed:this.closed})}calculateArea(e={}){return!this.closed||this.coordinates.length<3?0:d.calculateArea(this.coordinates,e)}createElevationProfile(){return this.coordinates.length<2?[]:d.createElevationProfile(this.coordinates)}calculateElevationChange(){return this.coordinates.length<2?{gain:0,loss:0}:{gain:d.calculateElevationGain(this.coordinates),loss:d.calculateElevationLoss(this.coordinates)}}createOffsetLine(e,t={}){if(this.coordinates.length<2)return this.clone();const i=d.createOffsetLine(this.coordinates,e,{closed:this.closed,...t});return new f(i,{name:`${this.name} (offset ${e}m)`,style:{...this.style},closed:this.closed})}simplify(e){if(this.coordinates.length<3||e<=0)return this;const t=d.simplifyPath(this.coordinates,e);return this.setCoordinates(t),this}createRegularPoints(e,t={}){return this.coordinates.length<2||e<=0?[]:d.createRegularPointsAlongPath(this.coordinates,e,{closed:this.closed,...t})}getPointAtPercentage(e){if(this.coordinates.length<2)return null;e<0&&(e=0),e>100&&(e=100);const t=e/100*this.calculateLength();return this.getPointAtDistance(t)}getPointAtDistance(e){return this.coordinates.length<2?null:d.getPointAtDistance(this.coordinates,e,{closed:this.closed})}splitAtVertex(e){if(e<=0||e>=this.coordinates.length-1)return[this.clone()];return[new f(this.coordinates.slice(0,e+1),{name:`${this.name} (part 1)`,style:{...this.style},closed:!1}),new f(this.coordinates.slice(e),{name:`${this.name} (part 2)`,style:{...this.style},closed:!1})]}reverse(){return this.coordinates.reverse(),this.emit("geometry-changed",{feature:this,coordinates:this.coordinates}),this}}class w extends u{constructor(e=[],t={}){if(super(t),this.type="polygon",this.exteriorRing=new f(e,{closed:!0}),this.interiorRings=[],t.holes&&Array.isArray(t.holes))for(const e of t.holes)this.interiorRings.push(new f(e,{closed:!0}));this._updateProperties(),t.name||(this.name=`Polygon (${this.exteriorRing.getVertexCount()} vertices)`),this._setupEventForwarding()}_setupEventForwarding(){this.exteriorRing.on("geometry-changed",(e=>{this._updateProperties(),this.emit("geometry-changed",{feature:this,ring:"exterior",ringIndex:-1,...e})}));for(let e=0;e<this.interiorRings.length;e++){this.interiorRings[e].on("geometry-changed",(t=>{this._updateProperties(),this.emit("geometry-changed",{feature:this,ring:"interior",ringIndex:e,...t})}))}}_updateProperties(){const e=this.exteriorRing.getCoordinates();if(e.length<3)return this.properties.area=0,void(this.properties.perimeter=0);this.properties.area=this.calculateArea(),this.properties.perimeter=this.exteriorRing.calculateLength();const t=e.map((e=>e.elevation)).filter((e=>null!=e));t.length>0&&(this.properties.minElevation=Math.min(...t),this.properties.maxElevation=Math.max(...t),this.properties.averageElevation=t.reduce(((e,t)=>e+t),0)/t.length);try{const e=this.calculateCentroid();e&&(this.properties.centroid={lat:e.lat,lng:e.lng})}catch(e){console.warn(`Could not calculate centroid: ${e.message}`)}}getCoordinates(){return this.exteriorRing.getCoordinates()}setCoordinates(e){this.exteriorRing.setCoordinates(e)}getHoles(){return this.interiorRings.map((e=>e.getCoordinates()))}getRings(){return[this.exteriorRing.getCoordinates()].concat(this.getHoles())}setRings(e){if(!e||!Array.isArray(e)||0===e.length)throw new Error("Invalid rings: must provide a non-empty array of coordinate arrays");this.exteriorRing.setCoordinates(e[0]),this.interiorRings=[];for(let t=1;t<e.length;t++)this.addHole(e[t]);this._updateProperties()}getHole(e){return e<0||e>=this.interiorRings.length?null:this.interiorRings[e].getCoordinates()}addHole(e){const t=new f(e,{closed:!0}),i=this.interiorRings.length;return t.on("geometry-changed",(e=>{this._updateProperties(),this.emit("geometry-changed",{feature:this,ring:"interior",ringIndex:i,...e})})),this.interiorRings.push(t),this._updateProperties(),this.emit("hole-added",{feature:this,holeIndex:i,coordinates:t.getCoordinates()}),i}removeHole(e){if(e<0||e>=this.interiorRings.length)return!1;const t=this.interiorRings.splice(e,1)[0];return this._updateProperties(),this.emit("hole-removed",{feature:this,holeIndex:e,coordinates:t.getCoordinates()}),!0}updateHole(e,t){return!(e<0||e>=this.interiorRings.length)&&(this.interiorRings[e].setCoordinates(t),!0)}getHoleCount(){return this.interiorRings.length}addVertex(e,t=null){this.exteriorRing.addCoordinate(e,t)}removeVertex(e){return this.exteriorRing.removeCoordinate(e)}updateVertex(e,t){return this.exteriorRing.updateCoordinate(e,t)}getVertexCount(){return this.exteriorRing.getVertexCount()}getVertex(e){return this.exteriorRing.getVertex(e)}getBounds(){return this.exteriorRing.getBounds()}getCenter(){return this.calculateCentroid()}calculateCentroid(){return d.calculatePolygonCentroid(this.exteriorRing.getCoordinates(),this.getHoles())}getElevationRange(){const e=this.exteriorRing.getElevationRange();if(0===this.interiorRings.length)return e;let t=e.min,i=e.max;for(const e of this.interiorRings){const o=e.getElevationRange();o.min<t&&(t=o.min),o.max>i&&(i=o.max)}return{min:t,max:i,range:i-t}}contains(e,t={}){if(!(e instanceof l))throw new Error("Coordinate must be an instance of Coordinate class");const i=this.exteriorRing.getCoordinates();if(i.length<3)return!1;if(!d.pointInPolygon(e,i))return!1;for(const t of this.interiorRings)if(d.pointInPolygon(e,t.getCoordinates()))return!1;return!0}nearest(e){if(!(e instanceof l))throw new Error("Coordinate must be an instance of Coordinate class");if(this.contains(e))return{coordinate:e.clone(),distance:0,isInterior:!0};const t=this.exteriorRing.nearest(e);let i=t.distance,o=t.coordinate;for(const t of this.interiorRings){const n=t.nearest(e);n.distance<i&&(i=n.distance,o=n.coordinate)}return{coordinate:o,distance:i,isInterior:!1}}toGeoJSON(e={}){const t=!1!==e.includeElevation,i=!1!==e.includeProperties,o=[...this.exteriorRing.getCoordinates()];o.length>0&&(o[0].lat!==o[o.length-1].lat||o[0].lng!==o[o.length-1].lng)&&o.push(o[0]);const n={type:"Feature",geometry:{type:"Polygon",coordinates:[o.map((e=>{const i=[e.lng,e.lat];return t&&null!==e.elevation&&void 0!==e.elevation&&i.push(e.elevation),i})),...this.interiorRings.map((e=>{let i=e.getCoordinates();return i.length>0&&(i[0].lat!==i[i.length-1].lat||i[0].lng!==i[i.length-1].lng)&&(i=[...i,i[0]]),i.map((e=>{const i=[e.lng,e.lat];return t&&null!==e.elevation&&void 0!==e.elevation&&i.push(e.elevation),i}))}))]},id:this.id};return i&&(n.properties={name:this.name,...this.properties}),n}fromGeoJSON(e,t={}){if(!e||"Feature"!==e.type||!e.geometry||"Polygon"!==e.geometry.type||!Array.isArray(e.geometry.coordinates))return!1;const i=e.geometry.coordinates;if(0===i.length||!Array.isArray(i[0]))return!1;const o=i[0].map((e=>{if(!Array.isArray(e)||e.length<2)throw new Error("Invalid GeoJSON Polygon coordinates");return new l(e[1],e[0],e.length>2?e[2]:null)}));o.length>0&&o[0].equals(o[o.length-1])&&o.pop(),this.exteriorRing.setCoordinates(o),this.interiorRings=[];for(let e=1;e<i.length;e++){const t=i[e].map((e=>{if(!Array.isArray(e)||e.length<2)throw new Error("Invalid GeoJSON Polygon hole coordinates");return new l(e[1],e[0],e.length>2?e[2]:null)}));t.length>0&&t[0].equals(t[t.length-1])&&t.pop(),this.addHole(t)}return e.properties&&(e.properties.name&&(this.name=e.properties.name,delete e.properties.name),this.properties={...e.properties}),e.id&&(this.id=e.id),this._updateProperties(),this.emit("geometry-changed",{feature:this}),!0}clone(){const e=this.exteriorRing.getCoordinates().map((e=>e.clone())),t=this.interiorRings.map((e=>e.getCoordinates().map((e=>e.clone()))));return new w(e,{id:`clone_${this.id}`,name:`${this.name} (copy)`,style:{...this.style},properties:{...this.properties},metadata:{...this.metadata},visible:this.visible,editable:this.editable,interactive:this.interactive,holes:t})}calculateArea(e={}){const t=!1!==e.includeHoles,i=this.exteriorRing.getCoordinates();if(i.length<3)return 0;let o=d.calculateArea(i);if(t&&this.interiorRings.length>0)for(const e of this.interiorRings){const t=e.getCoordinates();if(t.length<3)continue;o-=d.calculateArea(t)}return o}calculatePerimeter(e={}){const t=!1!==e.includeHoles;let i=this.exteriorRing.calculateLength();if(t&&this.interiorRings.length>0)for(const e of this.interiorRings)i+=e.calculateLength();return i}simplify(e){if(e<=0)return this.clone();const t=d.simplifyPath(this.exteriorRing.getCoordinates(),e),i=this.interiorRings.map((t=>d.simplifyPath(t.getCoordinates(),e)));return new w(t,{name:`${this.name} (simplified)`,style:{...this.style},holes:i})}buffer(e,t={}){const i=this.exteriorRing.getCoordinates();if(i.length<3)return this.clone();const o=d.bufferPolygon(i,e,t);return new w(o,{name:`${this.name} (buffer ${e}m)`,style:{...this.style}})}isValid(){const e=this.exteriorRing.getCoordinates();if(e.length<3)return!1;if(d.hasSelfIntersections(e))return!1;for(const t of this.interiorRings){const i=t.getCoordinates();if(i.length<3)continue;if(d.hasSelfIntersections(i))return!1;const o=d.calculatePathCenter(i);if(!d.pointInPolygon(o,e))return!1;if(d.doPathsIntersect(e,i))return!1;for(const e of this.interiorRings){if(t===e)continue;const o=e.getCoordinates();if(d.doPathsIntersect(i,o))return!1}}return!0}calculate3DSurfaceArea(){return d.calculate3DPolygonSurfaceArea(this.exteriorRing.getCoordinates(),this.getHoles())}calculateVolume(e={}){let t;if(void 0!==e.baseElevation)t=e.baseElevation;else{t=this.getElevationRange().min}return d.calculatePolygonVolume(this.exteriorRing.getCoordinates(),this.getHoles(),t)}}class v extends t{constructor(e=[],t={}){super(),this.id=t.id||`collection_${Date.now()}_${Math.floor(1e4*Math.random())}`,this.name=t.name||`Collection ${this.id.substr(-4)}`,this.features=new Map,Array.isArray(e)&&e.forEach((e=>this.addFeature(e)))}addFeature(e){if(!(e instanceof u))throw new Error("Feature must be an instance of FeatureBase");return this.features.set(e.id,e),e.on("geometry-changed",(e=>{this.emit("feature-geometry-changed",{...e,collection:this})})),e.on("properties-changed",(e=>{this.emit("feature-properties-changed",{...e,collection:this})})),e.on("style-changed",(e=>{this.emit("feature-style-changed",{...e,collection:this})})),e.on("selected",(e=>{this.emit("feature-selected",{...e,collection:this})})),e.on("deselected",(e=>{this.emit("feature-deselected",{...e,collection:this})})),e.on("visibility-changed",(e=>{this.emit("feature-visibility-changed",{...e,collection:this})})),this.emit("feature-added",{feature:e,collection:this}),e.id}removeFeature(e){const t=e instanceof u?e.id:e;if(!this.features.has(t))return!1;const i=this.features.get(t);return this.features.delete(t),i.removeAllListeners(),this.emit("feature-removed",{feature:i,collection:this}),!0}getFeature(e){return this.features.get(e)}hasFeature(e){const t=e instanceof u?e.id:e;return this.features.has(t)}getAllFeatures(){return Array.from(this.features.values())}getFeaturesByType(e){return this.getAllFeatures().filter((t=>t.type===e))}findFeatures(e){return this.getAllFeatures().filter(e)}getFeatureCount(){return this.features.size}getFeatureCountsByType(){const e={};return this.getAllFeatures().forEach((t=>{e[t.type]=(e[t.type]||0)+1})),e}clear(){this.getAllFeatures().forEach((e=>{this.removeFeature(e)})),this.emit("collection-cleared",{collection:this})}selectAll(e={}){this.getAllFeatures().forEach((t=>{t.selected||t.select(e)}))}deselectAll(e={}){this.getAllFeatures().forEach((t=>{t.selected&&t.deselect(e)}))}getSelectedFeatures(){return this.getAllFeatures().filter((e=>e.selected))}setAllVisible(e){this.getAllFeatures().forEach((t=>{t.visible!==e&&(e?t.show():t.hide())}))}getVisibleFeatures(){return this.getAllFeatures().filter((e=>e.visible))}toGeoJSON(e={}){console.log("Exporting FeatureCollection to GeoJSON, feature count:",this.features.size);return{type:"FeatureCollection",features:this.getAllFeatures().filter((t=>e.includeHidden||t.visible)).map((t=>{console.log(`Processing feature for export: ${t.id}, type: ${t.type}`),"line"!==t.type&&"polygon"!==t.type||console.log(`  Coordinates count: ${t.getCoordinates().length}`);const i=t.toGeoJSON(e);return i.geometry?"LineString"===i.geometry.type&&Array.isArray(i.geometry.coordinates)?console.log(`  LineString exported with ${i.geometry.coordinates.length} coordinates`):"Polygon"===i.geometry.type&&Array.isArray(i.geometry.coordinates)&&i.geometry.coordinates.length>0&&console.log(`  Polygon exported with ${i.geometry.coordinates[0].length} coordinates in exterior ring`):console.warn(`  Warning: No geometry in exported feature ${t.id}`),i}))}}fromGeoJSON(e,t={}){if(!e)return 0;let i=[];"FeatureCollection"===e.type&&Array.isArray(e.features)?i=e.features:"Feature"===e.type&&(i=[e]);let o=0;for(const e of i)if(e&&e.geometry&&e.geometry.type)try{let i;switch(e.geometry.type){case"Point":i=new p(e.geometry.coordinates,{id:e.id});break;case"LineString":i=new f(e.geometry.coordinates.map((e=>new l(e[1],e[0],e.length>2?e[2]:null))),{id:e.id});break;case"Polygon":if(e.geometry.coordinates&&e.geometry.coordinates.length>0){const t=e.geometry.coordinates[0].map((e=>new l(e[1],e[0],e.length>2?e[2]:null))),o=[];for(let t=1;t<e.geometry.coordinates.length;t++)o.push(e.geometry.coordinates[t].map((e=>new l(e[1],e[0],e.length>2?e[2]:null))));i=new w(t,{id:e.id,holes:o})}else i=new w([],{id:e.id});break;default:console.warn(`Unsupported GeoJSON geometry type: ${e.geometry.type}`);continue}"LineString"===e.geometry.type||"Polygon"===e.geometry.type?(e.properties&&(e.properties.name&&(i.name=e.properties.name),i.properties={...e.properties}),this.addFeature(i),o++):i.fromGeoJSON(e,t)&&(this.addFeature(i),o++)}catch(e){console.error("Error importing GeoJSON feature:",e)}return o>0&&this.emit("features-imported",{count:o,collection:this}),o}getBounds(){const e=this.getAllFeatures();if(0===e.length)return null;const t=e[0].getBounds();if(!t)return null;let i=t.north,o=t.south,n=t.east,r=t.west;for(let t=1;t<e.length;t++){const a=e[t].getBounds();a&&(a.north>i&&(i=a.north),a.south<o&&(o=a.south),a.east>n&&(n=a.east),a.west<r&&(r=a.west))}return{north:i,south:o,east:n,west:r,northEast:new l(i,n),southWest:new l(o,r)}}applyStyleToAll(e,t={}){this.getAllFeatures().forEach((i=>{i.setStyle(e,t)}))}findFeaturesAt(e,t={}){return this.getAllFeatures().filter((i=>i.visible&&i.contains(e,t)))}getFeaturesAtPosition(e,t={}){const i=t.tolerance||10,o=t.screenPosition,n=t.mapInterface;return o&&n?this.getAllFeatures().filter((t=>{if(!t.visible)return!1;if("point"===t.type){const e=t.getCoordinate();if(!e)return!1;try{const t=n.coordinateToPixel(e);if(!t)return!1;return Math.sqrt(Math.pow(t[0]-o[0],2)+Math.pow(t[1]-o[1],2))<=i}catch(e){return console.warn("Error calculating screen distance:",e),!1}}return t.contains(e,{tolerance:i})})):this.findFeaturesAt(e,{tolerance:i})}findNearestFeature(e,t={}){let i=this.getAllFeatures().filter((e=>e.visible));if(t.featureType&&(i=i.filter((e=>e.type===t.featureType))),0===i.length)return null;let o=null,n=1/0;return i.forEach((i=>{const r=i.nearest(e);r&&r.distance<n&&(!t.maxDistance||r.distance<=t.maxDistance)&&(o=i,n=r.distance)})),o?{feature:o,distance:n}:null}updateFeature(e){if(!(e instanceof u))throw new Error("Feature must be an instance of FeatureBase");return!!this.features.has(e.id)&&(this.features.set(e.id,e),this.emit("feature-updated",{feature:e,collection:this}),!0)}}class y extends t{constructor(e={}){if(super(),!e.manager)throw new Error("Manager instance is required for tool initialization");if(!e.mapInterface)throw new Error("Map interface is required for tool initialization");this.manager=e.manager,this.mapInterface=e.mapInterface,this.geometryEngine=e.geometryEngine||this.manager.geometryEngine,this.isActive=!1,this.options=e,this.workingData={},this._setupEventListeners()}_setupEventListeners(){}activate(e={}){this.isActive||(this.activationOptions=Object.assign({},e),this.options=Object.assign({},this.options,e),console.log("ToolBase.activate: Updating options",e),console.log("ToolBase.activate: Combined options are now",this.options),this.isActive=!0,this._activate(),this.emit("activated",this.activationOptions))}_activate(){throw new Error("_activate() must be implemented by derived classes")}deactivate(){this.isActive&&(this.isActive=!1,this._deactivate(),this.emit("deactivated"))}_deactivate(){throw new Error("_deactivate() must be implemented by derived classes")}reset(){this._reset(),this.emit("reset")}_reset(){}updateOptions(e={}){this.options=Object.assign(this.options,e),this._optionsUpdated(),this.emit("optionsUpdated",this.options)}_optionsUpdated(){}destroy(){this.isActive&&this.deactivate(),this._destroy(),this.removeAllListeners(),this.manager=null,this.mapInterface=null,this.geometryEngine=null}_destroy(){}}class k extends y{constructor(e={}){super(e),this.options=Object.assign({mode:"distance",units:"meters",areaUnits:"square-meters",volumeUnits:"cubic-meters",enable3D:!0,continuousMeasure:!1,showSegmentLengths:!0,showTotalLength:!0,lineSymbol:this.manager.settings.defaultLineSymbol,pointSymbol:this.manager.settings.defaultPointSymbol,labelStyle:{font:"12px Arial",fillColor:"black",strokeColor:"white",strokeWidth:3}},e),this.workingData={activeMeasurement:null,measurements:[],points:[],mousePosition:null,hoverCoordinate:null,measurementLabels:[],segmentLabels:[]},this.geometryEngine=d,this._handleMapClick=this._handleMapClick.bind(this),this._handleMapMouseMove=this._handleMapMouseMove.bind(this),this._handleMapDoubleClick=this._handleMapDoubleClick.bind(this),this._handleMapRightClick=this._handleMapRightClick.bind(this),this._handleKeyDown=this._handleKeyDown.bind(this)}_setupEventListeners(){}_activate(){this._activateMeasurementMode(this.options.mode),this.mapInterface.addEventListener("click",this._handleMapClick),this.mapInterface.addEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.addEventListener("dblclick",this._handleMapDoubleClick),this.mapInterface.addEventListener("contextmenu",this._handleMapRightClick),document.addEventListener("keydown",this._handleKeyDown),this._createNewMeasurement()}_deactivate(){this.mapInterface.removeEventListener("click",this._handleMapClick),this.mapInterface.removeEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.removeEventListener("dblclick",this._handleMapDoubleClick),this.mapInterface.removeEventListener("contextmenu",this._handleMapRightClick),document.removeEventListener("keydown",this._handleKeyDown),this._clearTemporaryMeasurements()}_reset(){this._clearActiveMeasurement(),this._createNewMeasurement()}_activateMeasurementMode(e){["distance","area","volume"].includes(e)||(console.error(`Invalid measurement mode: ${e}`),e="distance"),this.options.mode=e,this.isActive&&this._reset(),this.emit("mode-changed",{mode:e})}_createNewMeasurement(){switch(this._clearActiveMeasurement(),this.options.mode){case"distance":this.workingData.activeMeasurement=new f([],{id:`measurement-${Date.now()}`,properties:{type:"measurement",measurementType:"distance",temporary:!0},style:this.options.lineSymbol});break;case"area":case"volume":this.workingData.activeMeasurement=new w([[]],{id:`measurement-${Date.now()}`,properties:{type:"measurement",measurementType:this.options.mode,temporary:!0},style:Object.assign({},this.manager.settings.defaultPolygonSymbol,{outlineColor:this.options.lineSymbol.color,outlineWidth:this.options.lineSymbol.width})})}this.manager.workingFeatures.addFeature(this.workingData.activeMeasurement),this.workingData.points=[],this.workingData.measurementLabels=[],this.workingData.segmentLabels=[]}_clearActiveMeasurement(){this.workingData.activeMeasurement&&(this.manager.workingFeatures.removeFeature(this.workingData.activeMeasurement),this.workingData.activeMeasurement=null),this.workingData.points.forEach((e=>{this.manager.workingFeatures.removeFeature(e)})),this.workingData.points=[],this._clearMeasurementLabels()}_clearTemporaryMeasurements(){this._clearActiveMeasurement(),this.workingData.measurements.forEach((e=>{this.manager.workingFeatures.removeFeature(e)})),this.workingData.measurements=[]}_clearMeasurementLabels(){this.workingData.measurementLabels.forEach((e=>{this.mapInterface.removeLabel(e)})),this.workingData.segmentLabels.forEach((e=>{this.mapInterface.removeLabel(e)})),this.workingData.measurementLabels=[],this.workingData.segmentLabels=[]}_handleMapClick(e){const t=e.coordinate;t&&this.workingData.activeMeasurement&&(this._addPointToMeasurement(t),this._updateMeasurementDisplay())}_handleMapMouseMove(e){if(this.workingData.mousePosition=e.coordinate,this.workingData.hoverCoordinate=e.coordinate,this.workingData.activeMeasurement&&this.workingData.points.length>0&&this._updateMeasurementPreview(),this.options.continuousMeasure&&this.workingData.activeMeasurement&&this.workingData.points.length>0){const t=this.workingData.points[this.workingData.points.length-1].getCoordinate();this.geometryEngine.calculateDistance(t,e.coordinate,{includeElevation:this.options.enable3D})>5&&(this._addPointToMeasurement(e.coordinate),this._updateMeasurementDisplay())}}_handleMapDoubleClick(e){e.originalEvent&&e.originalEvent.preventDefault(),this._completeMeasurement()}_handleMapRightClick(e){e.originalEvent&&e.originalEvent.preventDefault(),this.workingData.points.length>0?this._completeMeasurement():this._reset()}_handleKeyDown(e){"Escape"===e.key&&(this.workingData.points.length>0?this._removeLastPoint():this._reset()),"Enter"===e.key&&this._completeMeasurement()}_addPointToMeasurement(e){const t=new p(e,{id:`measurement-point-${Date.now()}-${this.workingData.points.length}`,properties:{type:"measurement-point",measurementId:this.workingData.activeMeasurement.id,index:this.workingData.points.length,temporary:!0},style:this.options.pointSymbol});this.options.enable3D&&this.manager.applyElevationData(t),this.manager.workingFeatures.addFeature(t),this.workingData.points.push(t),this._updateMeasurementGeometry()}_removeLastPoint(){if(0===this.workingData.points.length)return;const e=this.workingData.points.pop();this.manager.workingFeatures.removeFeature(e),this._updateMeasurementGeometry(),this._updateMeasurementDisplay()}_updateMeasurementGeometry(){if(!this.workingData.activeMeasurement)return;const e=this.workingData.points.map((e=>e.getCoordinate()));switch(this.options.mode){case"distance":this.workingData.activeMeasurement.setCoordinates(e);break;case"area":case"volume":if(e.length>=3){const t=[...e];this.workingData.activeMeasurement.setRings([t])}else this.workingData.activeMeasurement.setRings([e])}}_updateMeasurementPreview(){if(!this.workingData.activeMeasurement||!this.workingData.mousePosition)return;const e=[...this.workingData.points.map((e=>e.getCoordinate())),this.workingData.mousePosition];switch(this.options.mode){case"distance":this.workingData.activeMeasurement.setCoordinates(e);break;case"area":case"volume":this.workingData.activeMeasurement.setRings([e])}this._updateMeasurementDisplay(!0)}_updateMeasurementDisplay(e=!1){if(this._clearMeasurementLabels(),!this.workingData.activeMeasurement)return;let t=0,i="",o=[];switch(this.options.mode){case"distance":const n=this.workingData.points.map((e=>e.getCoordinate()));e&&this.workingData.mousePosition&&n.push(this.workingData.mousePosition),n.length>=2&&(t=this._calculateDistance(n),i=this.options.units,this.options.showSegmentLengths&&(o=this._calculateSegmentDistances(n)));break;case"area":const r=this.workingData.points.map((e=>e.getCoordinate()));if(e&&this.workingData.mousePosition&&r.push(this.workingData.mousePosition),r.length>=3&&(t=this._calculateArea(r),i=this.options.areaUnits,this.options.showSegmentLengths)){const e=[...r,r[0]];o=this._calculateSegmentDistances(e)}break;case"volume":const a=this.workingData.points.map((e=>e.getCoordinate()));if(e&&this.workingData.mousePosition&&a.push(this.workingData.mousePosition),a.length>=3&&this.options.enable3D&&(t=this._calculateVolume(a),i=this.options.volumeUnits,this.options.showSegmentLengths)){const e=[...a,a[0]];o=this._calculateSegmentDistances(e)}}if(t>0){const n=this._formatMeasurementValue(t,i);if(this.emit("measurement-updated",{type:this.options.mode,value:t,unit:i,formattedValue:n,segments:o.length,vertices:this.workingData.points.length,preview:e}),this.options.showTotalLength){const e=this._calculateLabelPosition(),t=this.mapInterface.createLabel({position:e,text:n,style:this.options.labelStyle});this.workingData.measurementLabels.push(t)}this.options.showSegmentLengths&&o.length>0&&o.forEach(((e,t)=>{if(e.value<=0)return;const o=this._formatMeasurementValue(e.value,i),n=this.mapInterface.createLabel({position:e.midpoint,text:o,style:Object.assign({},this.options.labelStyle,{font:"10px Arial"})});this.workingData.segmentLabels.push(n)}))}}_calculateLabelPosition(){switch(this.options.mode){case"distance":if(this.workingData.points.length>0){return this.workingData.points[this.workingData.points.length-1].getCoordinate()}break;case"area":case"volume":if(this.workingData.activeMeasurement)return this.workingData.activeMeasurement.getCentroid()}return this.workingData.points.length>0?this.workingData.points[0].getCoordinate():null}_completeMeasurement(){const e="distance"===this.options.mode?2:3;if(!this.workingData.activeMeasurement||this.workingData.points.length<e)return void this._reset();const t=this.workingData.activeMeasurement;this._updateMeasurementGeometry();let i=0,o="";switch(this.options.mode){case"distance":const e=t.getCoordinates();i=this._calculateDistance(e),o=this.options.units;break;case"area":const n=t.getRings();n.length>0&&(i=this._calculateArea(n[0]),o=this.options.areaUnits);break;case"volume":const r=t.getRings();r.length>0&&(i=this._calculateVolume(r[0]),o=this.options.volumeUnits)}const n=this._formatMeasurementValue(i,o);t.setProperty("measurementValue",i),t.setProperty("measurementUnit",o),t.setProperty("measurementFormatted",n),t.setProperty("temporary",!1),this.workingData.points.forEach((e=>{e.setProperty("temporary",!1)})),this.workingData.measurements.push(t),this._createNewMeasurement(),this.emit("measurement-completed",{feature:t,value:i,unit:o,formattedValue:n,mode:this.options.mode})}_calculateDistance(e){if(e.length<2)return 0;let t=0;for(let i=0;i<e.length-1;i++){t+=this.geometryEngine.calculateDistance(e[i],e[i+1],{includeElevation:this.options.enable3D})}return this._convertDistance(t,"meters",this.options.units)}_calculateSegmentDistances(e){if(e.length<2)return[];const t=[];for(let i=0;i<e.length-1;i++){const o=e[i],n=e[i+1],r=this.geometryEngine.calculateDistance(o,n,{includeElevation:this.options.enable3D}),a={lat:(o.lat+n.lat)/2,lng:(o.lng+n.lng)/2,elevation:void 0!==o.elevation&&void 0!==n.elevation?(o.elevation+n.elevation)/2:0},s=this._convertDistance(r,"meters",this.options.units);t.push({value:s,midpoint:a})}return t}_calculateArea(e){if(e.length<3)return 0;const t=[...e],i=t[0],o=t[t.length-1];i.lat===o.lat&&i.lng===o.lng||t.push(t[0]);const n=this.geometryEngine.calculateArea(t,{includeElevation:this.options.enable3D});return this._convertArea(n,"square-meters",this.options.areaUnits)}_calculateVolume(e){if(e.length<3||!this.options.enable3D)return 0;const t=[...e],i=t[0],o=t[t.length-1];i.lat===o.lat&&i.lng===o.lng||t.push(t[0]);const n=this.geometryEngine.calculateVolume?this.geometryEngine.calculateVolume(t):this._calculateVolumeDirectly(t);return this._convertVolume(n,"cubic-meters",this.options.volumeUnits)}_calculateVolumeDirectly(e){const t=this._calculateArea(e);let i=0,o=0;for(const t of e)void 0!==t.elevation&&null!==t.elevation&&(i+=t.elevation,o++);if(o>0){return t*(i/o)}return 0}_convertDistance(e,t,i){if(t===i)return e;let o=e;if("meters"!==t)switch(t){case"feet":o=.3048*e;break;case"kilometers":o=1e3*e;break;case"miles":o=1609.344*e}switch(i){case"meters":default:return o;case"feet":return o/.3048;case"kilometers":return o/1e3;case"miles":return o/1609.344}}_convertArea(e,t,i){if(t===i)return e;let o=e;if("square-meters"!==t)switch(t){case"square-feet":o=.092903*e;break;case"hectares":o=1e4*e;break;case"acres":o=4046.856*e}switch(i){case"square-meters":default:return o;case"square-feet":return o/.092903;case"hectares":return o/1e4;case"acres":return o/4046.856}}_convertVolume(e,t,i){if(t===i)return e;let o=e;if("cubic-meters"!==t&&"cubic-feet"===t)o=.0283168*e;switch(i){case"cubic-meters":default:return o;case"cubic-feet":return o/.0283168}}_formatMeasurementValue(e,t){let i,o;switch(t){case"meters":i=e<10?e.toFixed(2):Math.round(e).toString(),o="m";break;case"feet":i=e<10?e.toFixed(2):Math.round(e).toString(),o="ft";break;case"kilometers":i=e.toFixed(3),o="km";break;case"miles":i=e.toFixed(3),o="mi";break;case"square-meters":i=e<10?e.toFixed(2):Math.round(e).toString(),o="m";break;case"square-feet":i=e<10?e.toFixed(2):Math.round(e).toString(),o="ft";break;case"hectares":i=e.toFixed(4),o="ha";break;case"acres":i=e.toFixed(4),o="ac";break;case"cubic-meters":i=e<10?e.toFixed(2):Math.round(e).toString(),o="m";break;case"cubic-feet":i=e<10?e.toFixed(2):Math.round(e).toString(),o="ft";break;default:i=e.toString(),o=t}return`${i} ${o}`}setMode(e){return["distance","area","volume"].includes(e)?(this.options.mode=e,this.isActive&&this._reset(),this.emit("mode-changed",{mode:e}),!0):(console.error(`Invalid measurement mode: ${e}`),!1)}setUnits(e={}){return e.distance&&!["meters","feet","kilometers","miles"].includes(e.distance)?(console.error(`Invalid distance unit: ${e.distance}`),!1):e.area&&!["square-meters","square-feet","hectares","acres"].includes(e.area)?(console.error(`Invalid area unit: ${e.area}`),!1):e.volume&&!["cubic-meters","cubic-feet"].includes(e.volume)?(console.error(`Invalid volume unit: ${e.volume}`),!1):(e.distance&&(this.options.units=e.distance),e.area&&(this.options.areaUnits=e.area),e.volume&&(this.options.volumeUnits=e.volume),this.isActive&&this.workingData.activeMeasurement&&this._updateMeasurementDisplay(),this.emit("units-changed",{distance:this.options.units,area:this.options.areaUnits,volume:this.options.volumeUnits}),!0)}setEnable3D(e){return this.options.enable3D=!!e,this.isActive&&this.workingData.activeMeasurement&&this._updateMeasurementDisplay(),this.emit("enable-3d-changed",{enable3D:this.options.enable3D}),this.options.enable3D}completeMeasurement(){return this._completeMeasurement(),this.workingData.measurements.length>0?this.workingData.measurements[this.workingData.measurements.length-1]:null}getMeasurements(){return this.workingData.measurements}clearAllMeasurements(){this._clearTemporaryMeasurements(),this._reset(),this.emit("measurements-cleared")}}class D extends y{constructor(e={}){super(e),this.options=Object.assign({mode:"point",units:"meters",enable3D:!0,defaultDistance:5,defaultBearing:0,distanceSnap:1,bearingSnap:5,sourceSymbol:{type:"circle",size:8,color:"#3388FF"},targetSymbol:{type:"circle",size:8,color:"#FF5733"},lineSymbol:{width:2,color:"#FF5733",dashArray:"5,5"},previewSymbol:{type:"circle",size:8,color:"rgba(255, 87, 51, 0.5)",outlineWidth:1,outlineColor:"#FF5733"}},e),this.workingData={sourceFeature:null,targetFeature:null,previewFeature:null,offsetLine:null,offsetDistance:this.options.defaultDistance,offsetBearing:this.options.defaultBearing,mousePosition:null,selectedPoint:null,snapEnabled:!0},this._handleMapClick=this._handleMapClick.bind(this),this._handleMapMouseMove=this._handleMapMouseMove.bind(this),this._handleMapDoubleClick=this._handleMapDoubleClick.bind(this),this._handleKeyDown=this._handleKeyDown.bind(this),this._handleFeatureSelected=this._handleFeatureSelected.bind(this)}_setupEventListeners(){this.manager.on("featureSelected",this._handleFeatureSelected)}_activate(){this.mapInterface.addEventListener("click",this._handleMapClick),this.mapInterface.addEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.addEventListener("dblclick",this._handleMapDoubleClick),document.addEventListener("keydown",this._handleKeyDown),this._setOffsetMode(this.options.mode),this.workingData.offsetDistance=this.options.defaultDistance,this.workingData.offsetBearing=this.options.defaultBearing,this.emit("activated",{mode:this.options.mode,offsetDistance:this.workingData.offsetDistance,offsetBearing:this.workingData.offsetBearing})}_deactivate(){this.mapInterface.removeEventListener("click",this._handleMapClick),this.mapInterface.removeEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.removeEventListener("dblclick",this._handleMapDoubleClick),document.removeEventListener("keydown",this._handleKeyDown),this._clearPreviewFeatures(),this.workingData={sourceFeature:null,targetFeature:null,previewFeature:null,offsetLine:null,offsetDistance:this.options.defaultDistance,offsetBearing:this.options.defaultBearing,mousePosition:null,selectedPoint:null,snapEnabled:!0}}_reset(){this._clearPreviewFeatures();const e=this.workingData.offsetDistance,t=this.workingData.offsetBearing,i=this.options.mode;this.workingData={sourceFeature:null,targetFeature:null,previewFeature:null,offsetLine:null,offsetDistance:e,offsetBearing:t,mousePosition:null,selectedPoint:null,snapEnabled:!0},this.emit("reset",{mode:i,offsetDistance:e,offsetBearing:t})}_setOffsetMode(e){["point","line","perpendicular"].includes(e)||(console.error(`Invalid offset mode: ${e}`),e="point"),this.options.mode=e,this._reset(),this.emit("modeChanged",{mode:e})}_clearPreviewFeatures(){this.workingData.previewFeature&&(this.manager.workingFeatures.removeFeature(this.workingData.previewFeature),this.workingData.previewFeature=null),this.workingData.offsetLine&&(this.manager.workingFeatures.removeFeature(this.workingData.offsetLine),this.workingData.offsetLine=null)}_handleMapClick(e){switch(this.options.mode){case"point":this.workingData.sourceFeature?this._createOffsetPoint():this.workingData.selectedPoint?(this.workingData.sourceFeature=this.workingData.selectedPoint,this._updatePointOffsetPreview()):this._createSourcePoint(e.coordinate);break;case"line":case"perpendicular":if(this.workingData.sourceFeature)this.workingData.sourceFeature&&"line"===this.workingData.sourceFeature.type&&(this.workingData.sourceFeature.isTemporary?this._addPointToSourceLine(e.coordinate):this._createOffsetFromLine());else{const t=this.manager.getSelectedFeatures().find((e=>"line"===e.type));t?(this.workingData.sourceFeature=t,this._updateLineOffsetPreview()):this._startCreatingSourceLine(e.coordinate)}}}_handleMapMouseMove(e){if(this.workingData.mousePosition=e.coordinate,this.workingData.sourceFeature)switch(this.options.mode){case"point":this._updatePointOffsetPreview();break;case"line":case"perpendicular":this.workingData.sourceFeature.isTemporary?this._updateTemporarySourceLine():this._updateLineOffsetPreview()}}_handleMapDoubleClick(e){e.originalEvent&&e.originalEvent.preventDefault(),["line","perpendicular"].includes(this.options.mode)&&this.workingData.sourceFeature&&this.workingData.sourceFeature.isTemporary&&this._completeSourceLine()}_handleKeyDown(e){if("Escape"===e.key&&(["line","perpendicular"].includes(this.options.mode)&&this.workingData.sourceFeature&&this.workingData.sourceFeature.isTemporary?this._cancelSourceLine():this._reset()),"Enter"===e.key&&(["line","perpendicular"].includes(this.options.mode)&&this.workingData.sourceFeature&&this.workingData.sourceFeature.isTemporary?this._completeSourceLine():this.workingData.sourceFeature&&("point"===this.options.mode?this._createOffsetPoint():this._createOffsetFromLine())),e.key>="1"&&e.key<="9"){const t=parseInt(e.key)*(e.shiftKey?10:1);this.setOffsetDistance(t)}"ArrowLeft"===e.key?(this.adjustOffsetBearing(-15),e.preventDefault()):"ArrowRight"===e.key?(this.adjustOffsetBearing(15),e.preventDefault()):"ArrowUp"===e.key?(this.adjustOffsetDistance(1),e.preventDefault()):"ArrowDown"===e.key&&(this.adjustOffsetDistance(-1),e.preventDefault())}_handleFeatureSelected(e){this.isActive&&("point"===e.type&&"point"===this.options.mode&&(this.workingData.selectedPoint=e,this.workingData.sourceFeature||(this.workingData.sourceFeature=e,this._updatePointOffsetPreview())),"line"===e.type&&["line","perpendicular"].includes(this.options.mode)&&(this.workingData.sourceFeature||(this.workingData.sourceFeature=e,this._updateLineOffsetPreview())))}_createSourcePoint(e){const t=new p(e,{id:`offset-source-${Date.now()}`,properties:{type:"offset-source",temporary:!1},style:this.options.sourceSymbol});this.options.enable3D&&this.manager.applyElevationData(t),this.manager.features.addFeature(t),this.workingData.sourceFeature=t,this._updatePointOffsetPreview(),this.emit("sourcePointCreated",t)}_updatePointOffsetPreview(){if(this._clearPreviewFeatures(),!this.workingData.sourceFeature||"point"!==this.workingData.sourceFeature.type)return;const e=this.workingData.sourceFeature.getCoordinate();let t=this.workingData.offsetBearing;if(this.workingData.mousePosition){const i=e.bearingTo(new l(this.workingData.mousePosition));t=this.workingData.snapEnabled?Math.round(i/this.options.bearingSnap)*this.options.bearingSnap:i,this.workingData.offsetBearing=t}const i=d.destinationCoordinate(e,this.workingData.offsetDistance,t);this.workingData.previewFeature=new p(i,{id:`offset-preview-${Date.now()}`,properties:{type:"offset-preview",temporary:!0},style:this.options.previewSymbol}),this.workingData.offsetLine=new f([e,i],{id:`offset-line-${Date.now()}`,properties:{type:"offset-line",temporary:!0},style:this.options.lineSymbol}),this.manager.workingFeatures.addFeature(this.workingData.previewFeature),this.manager.workingFeatures.addFeature(this.workingData.offsetLine),this.emit("previewUpdated",{distance:this.workingData.offsetDistance,bearing:this.workingData.offsetBearing,sourceCoordinate:e,targetCoordinate:i})}_createOffsetPoint(){if(!this.workingData.sourceFeature||!this.workingData.previewFeature)return;const e=this.workingData.previewFeature.getCoordinate(),t=new p(e,{id:`offset-target-${Date.now()}`,properties:{type:"offset-target",offsetDistance:this.workingData.offsetDistance,offsetBearing:this.workingData.offsetBearing,sourceFeatureId:this.workingData.sourceFeature.id,temporary:!1},style:this.options.targetSymbol});this.manager.features.addFeature(t),this.workingData.targetFeature=t,this._clearPreviewFeatures(),this.workingData.sourceFeature=null,this.emit("offsetPointCreated",{sourceFeature:this.workingData.sourceFeature,targetFeature:t,distance:this.workingData.offsetDistance,bearing:this.workingData.offsetBearing}),this._reset()}_startCreatingSourceLine(e){const t=new f([e],{id:`offset-source-line-${Date.now()}`,properties:{type:"offset-source",temporary:!0},style:this.options.sourceSymbol});this.options.enable3D&&this.manager.applyElevationData(t),this.manager.workingFeatures.addFeature(t),this.workingData.sourceFeature=t,this.emit("sourceLineStarted",t)}_addPointToSourceLine(e){if(!this.workingData.sourceFeature||"line"!==this.workingData.sourceFeature.type)return;const t=this.workingData.sourceFeature.getCoordinates();t.push(e),this.workingData.sourceFeature.setCoordinates(t),this.options.enable3D&&this.manager.applyElevationData(this.workingData.sourceFeature),2===t.length&&this._updateLineOffsetPreview(),this.emit("sourceLinePointAdded",{line:this.workingData.sourceFeature,coordinate:e,pointIndex:t.length-1})}_updateTemporarySourceLine(){if(!this.workingData.sourceFeature||"line"!==this.workingData.sourceFeature.type||!this.workingData.sourceFeature.isTemporary||!this.workingData.mousePosition)return;const e=this.workingData.sourceFeature.getCoordinates();if(0===e.length)return;const t=[...e.slice(0,-1),this.workingData.mousePosition];this.workingData.sourceFeature.setCoordinates(t),t.length>=2&&this._updateLineOffsetPreview()}_completeSourceLine(){if(!this.workingData.sourceFeature||"line"!==this.workingData.sourceFeature.type||!this.workingData.sourceFeature.isTemporary)return;const e=this.workingData.sourceFeature.getCoordinates();if(e.length<2)return void this._cancelSourceLine();const t=new f(e,{id:`offset-source-line-${Date.now()}`,properties:{type:"offset-source",temporary:!1},style:this.options.sourceSymbol});this.options.enable3D&&this.manager.applyElevationData(t),this.manager.features.addFeature(t),this.manager.workingFeatures.removeFeature(this.workingData.sourceFeature),this.workingData.sourceFeature=t,this._updateLineOffsetPreview(),this.emit("sourceLineCompleted",t)}_cancelSourceLine(){this.workingData.sourceFeature&&this.workingData.sourceFeature.isTemporary&&(this.manager.workingFeatures.removeFeature(this.workingData.sourceFeature),this.workingData.sourceFeature=null,this._clearPreviewFeatures(),this.emit("sourceLineCancelled"))}_updateLineOffsetPreview(){if(this._clearPreviewFeatures(),!this.workingData.sourceFeature||"line"!==this.workingData.sourceFeature.type)return;const e=this.workingData.sourceFeature.getCoordinates();if(e.length<2)return;let t;if("line"===this.options.mode)t=this.geometryEngine.createOffsetLine(e,this.workingData.offsetDistance,{enable3D:this.options.enable3D}),this.workingData.previewFeature=new f(t,{id:`offset-preview-${Date.now()}`,properties:{type:"offset-preview",temporary:!0},style:Object.assign({},this.options.lineSymbol,{dashArray:"5,5"})});else if("perpendicular"===this.options.mode&&this.workingData.mousePosition){const t=this.workingData.sourceFeature.nearest(this.workingData.mousePosition);if(t){const i=this.geometryEngine.calculatePerpendicularOffset(e,t.pointIndex,t.segmentPosition,this.workingData.offsetDistance,{enable3D:this.options.enable3D});this.workingData.previewFeature=new p(i.offsetPoint,{id:`offset-preview-${Date.now()}`,properties:{type:"offset-preview",temporary:!0},style:this.options.previewSymbol}),this.workingData.offsetLine=new f([t.nearestPoint,i.offsetPoint],{id:`offset-line-${Date.now()}`,properties:{type:"offset-line",temporary:!0},style:this.options.lineSymbol}),this.workingData.perpendicularInfo={pointIndex:t.pointIndex,segmentPosition:t.segmentPosition,nearestPoint:t.nearestPoint,offsetPoint:i.offsetPoint}}}this.workingData.previewFeature&&this.manager.workingFeatures.addFeature(this.workingData.previewFeature),this.workingData.offsetLine&&this.manager.workingFeatures.addFeature(this.workingData.offsetLine),this.emit("previewUpdated",{distance:this.workingData.offsetDistance,sourceFeature:this.workingData.sourceFeature,previewFeature:this.workingData.previewFeature})}_createOffsetFromLine(){if(!this.workingData.sourceFeature||!this.workingData.previewFeature)return;let e;if("line"===this.options.mode){const t=this.workingData.previewFeature.getCoordinates();e=new f(t,{id:`offset-target-${Date.now()}`,properties:{type:"offset-target",offsetDistance:this.workingData.offsetDistance,sourceFeatureId:this.workingData.sourceFeature.id,temporary:!1},style:Object.assign({},this.options.lineSymbol,{dashArray:null})})}else if("perpendicular"===this.options.mode){const t=this.workingData.previewFeature.getCoordinate();e=new p(t,{id:`offset-target-${Date.now()}`,properties:{type:"offset-target",offsetDistance:this.workingData.offsetDistance,sourceFeatureId:this.workingData.sourceFeature.id,pointIndex:this.workingData.perpendicularInfo.pointIndex,segmentPosition:this.workingData.perpendicularInfo.segmentPosition,temporary:!1},style:this.options.targetSymbol})}e&&(this.manager.features.addFeature(e),this.workingData.targetFeature=e,this.emit("offsetFeatureCreated",{sourceFeature:this.workingData.sourceFeature,targetFeature:e,distance:this.workingData.offsetDistance,mode:this.options.mode})),this._clearPreviewFeatures(),this.workingData.sourceFeature=null,this._reset()}setOffsetDistance(e){return isNaN(e)||e<=0?(console.error("Invalid offset distance. Must be a positive number."),this.workingData.offsetDistance):(this.workingData.offsetDistance=e,this.workingData.sourceFeature&&("point"===this.options.mode?this._updatePointOffsetPreview():this._updateLineOffsetPreview()),this.emit("offsetDistanceChanged",{distance:this.workingData.offsetDistance}),this.workingData.offsetDistance)}setOffsetBearing(e){return isNaN(e)?(console.error("Invalid offset bearing. Must be a number."),this.workingData.offsetBearing):(e=(e%360+360)%360,this.workingData.offsetBearing=e,this.workingData.sourceFeature&&"point"===this.options.mode&&this._updatePointOffsetPreview(),this.emit("offsetBearingChanged",{bearing:this.workingData.offsetBearing}),this.workingData.offsetBearing)}adjustOffsetDistance(e){const t=Math.max(1,Math.round((this.workingData.offsetDistance+e)/this.options.distanceSnap)*this.options.distanceSnap);return this.setOffsetDistance(t)}adjustOffsetBearing(e){const t=Math.round((this.workingData.offsetBearing+e)/this.options.bearingSnap)*this.options.bearingSnap;return this.setOffsetBearing(t)}toggleSnap(e){return this.workingData.snapEnabled="boolean"==typeof e?e:!this.workingData.snapEnabled,this.emit("snapToggled",{snapEnabled:this.workingData.snapEnabled}),this.workingData.snapEnabled}setMode(e){return["point","line","perpendicular"].includes(e)?(this._setOffsetMode(e),!0):(console.error(`Invalid offset mode: ${e}`),!1)}getSettings(){return{mode:this.options.mode,distance:this.workingData.offsetDistance,bearing:this.workingData.offsetBearing,enable3D:this.options.enable3D,snapEnabled:this.workingData.snapEnabled}}}class M extends y{constructor(e={}){super(e),this.options=Object.assign({mode:"point",enable3D:!0,continuousDrawing:!1,freehandSamplingInterval:5,pointSymbol:Object.assign({size:32,color:"#FF5733",outlineWidth:2,outlineColor:"white",useDualMarker:!0},this.manager.settings.defaultPointSymbol||{}),lineSymbol:this.manager.settings.defaultLineSymbol,previewLineSymbol:{color:"#3388FF",width:2,opacity:.8,dashArray:[5,5]},polygonSymbol:this.manager.settings.defaultPolygonSymbol,previewPolygonSymbol:{fillColor:"rgba(51, 136, 255, 0.1)",outlineColor:"#3388FF",outlineWidth:2,dashArray:[5,5]},vertexSymbol:{type:"circle",size:8,color:"#3388FF",outlineWidth:2,outlineColor:"white",useDualMarker:!1},activeVertexSymbol:{type:"circle",size:10,color:"#3388FF",outlineWidth:2,outlineColor:"white",useDualMarker:!1}},e),this.workingData={activeFeature:null,vertices:[],mousePosition:null,isDragging:!1,lastFreehandPoint:null},this._handleMapClick=this._handleMapClick.bind(this),this._handleMapMouseMove=this._handleMapMouseMove.bind(this),this._handleMapDoubleClick=this._handleMapDoubleClick.bind(this),this._handleMapRightClick=this._handleMapRightClick.bind(this),this._handleKeyDown=this._handleKeyDown.bind(this),this._handleMapMouseDown=this._handleMapMouseDown.bind(this),this._handleMapMouseUp=this._handleMapMouseUp.bind(this)}_setupEventListeners(){}_activate(){console.log(`Activating DrawingTool in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`),this.workingData&&"object"==typeof this.workingData||(this.workingData={activeFeature:null,vertices:[],mousePosition:null,isDragging:!1,lastFreehandPoint:null});try{this.mapInterface.addEventListener("click",this._handleMapClick),this.mapInterface.addEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.addEventListener("dblclick",this._handleMapDoubleClick),this.mapInterface.addEventListener("contextmenu",this._handleMapRightClick),this.mapInterface.addEventListener("mousedown",this._handleMapMouseDown),this.mapInterface.addEventListener("mouseup",this._handleMapMouseUp),document.addEventListener("keydown",this._handleKeyDown),this._startNewDrawing(),this.emit("activated",{mode:this.options.mode,continuousDrawing:this.options.continuousDrawing})}catch(e){console.error("Error activating DrawingTool:",e)}}_deactivate(){this.mapInterface.removeEventListener("click",this._handleMapClick),this.mapInterface.removeEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.removeEventListener("dblclick",this._handleMapDoubleClick),this.mapInterface.removeEventListener("contextmenu",this._handleMapRightClick),this.mapInterface.removeEventListener("mousedown",this._handleMapMouseDown),this.mapInterface.removeEventListener("mouseup",this._handleMapMouseUp),document.removeEventListener("keydown",this._handleKeyDown),this._clearActiveDrawing(),this.workingData={activeFeature:null,vertices:[],mousePosition:null,isDragging:!1,lastFreehandPoint:null}}_reset(){this.workingData?this.workingData.activeFeature&&this._completeDrawing():this.workingData={activeFeature:null,vertices:[],mousePosition:null,isDragging:!1,lastFreehandPoint:null},this._startNewDrawing()}_startNewDrawing(){switch(this._clearActiveDrawing(),this.options.mode){case"point":break;case"line":this.workingData.activeFeature=new f([],{id:`drawing-${Date.now()}`,properties:{type:"drawing",drawingType:"line",temporary:!0,isPreview:!0},style:this.options.previewLineSymbol||this.options.lineSymbol});break;case"polygon":try{const e=[new l(0,0,0),new l(0,1e-6,0),new l(1e-6,0,0),new l(0,0,0)];this.workingData.activeFeature=new w(e,{id:`drawing-${Date.now()}`,properties:{type:"drawing",drawingType:"polygon",temporary:!0,isPreview:!0},style:this.options.previewPolygonSymbol||this.options.polygonSymbol})}catch(e){console.error("Error creating polygon feature:",e),this.workingData.activeFeature=new f([],{id:`drawing-${Date.now()}`,properties:{type:"drawing",drawingType:"line",temporary:!0,isPreview:!0},style:this.options.previewLineSymbol||this.options.lineSymbol}),console.warn("Fallback to LineFeature for drawing")}break;case"freehand":this.workingData.activeFeature=new f([],{id:`drawing-${Date.now()}`,properties:{type:"drawing",drawingType:"freehand",temporary:!0,isPreview:!0},style:this.options.previewLineSymbol||this.options.lineSymbol})}this.workingData.activeFeature&&this.manager.workingFeatures.addFeature(this.workingData.activeFeature),this.workingData.vertices=[],this.workingData.lastFreehandPoint=null}_clearActiveDrawing(){this.workingData?(this.workingData.activeFeature&&(this.manager.workingFeatures.removeFeature(this.workingData.activeFeature),this.workingData.activeFeature=null),Array.isArray(this.workingData.vertices)?(this.workingData.vertices.forEach((e=>{this.manager.workingFeatures.removeFeature(e)})),this.workingData.vertices=[]):this.workingData.vertices=[]):this.workingData={activeFeature:null,vertices:[],mousePosition:null,isDragging:!1,lastFreehandPoint:null}}_handleMapClick(e){if(console.log("======== MAP CLICK EVENT ========"),console.log(`DrawingTool._handleMapClick called in ${this.options.mode} mode`),console.log("Click event object:",{type:e.type,hasCoordinate:!!e.coordinate,hasLatLng:!!e.latLng,hasOriginalEvent:!!e.originalEvent,hasPixel:!!e.pixel,pixel:e.pixel?`[${e.pixel[0]}, ${e.pixel[1]}]`:"N/A"}),"freehand"===this.options.mode)return void console.log("Skipping click in freehand mode");let t;if(this.manager.snappingManager&&this.manager.snappingManager.getSnapPoint()){t=this.manager.snappingManager.getSnapPoint().coordinate}else if(e.coordinate)t=e.coordinate;else{if(!e.originalEvent||!e.latLng)return void console.error(" ERROR: Invalid click event, no coordinate found",e);t={lat:e.latLng.lat(),lng:e.latLng.lng(),elevation:0}}try{switch(this.options.mode){case"point":this._createPoint(t);break;case"line":case"polygon":this._addVertex(t)}}catch(e){console.error(` ERROR handling map click in ${this.options.mode} mode:`,e),setTimeout((()=>{this._startNewDrawing()}),10)}}_handleMapMouseMove(e){try{let t;if(this.manager.snappingManager&&this.manager.snappingManager.getSnapPoint()){t=this.manager.snappingManager.getSnapPoint().coordinate}else if(e.coordinate instanceof l)t=e.coordinate;else if(e.coordinate&&"number"==typeof e.coordinate.lat&&"number"==typeof e.coordinate.lng)t=new l(e.coordinate.lat,e.coordinate.lng,void 0!==e.coordinate.elevation?e.coordinate.elevation:0);else if(e.latLng&&"function"==typeof e.latLng.lat&&"function"==typeof e.latLng.lng)t=new l(e.latLng.lat(),e.latLng.lng(),0);else{const i=this.mapInterface;if(e.originalEvent&&i&&"function"==typeof i.getCoordinateFromPixel){const o={x:e.originalEvent.clientX,y:e.originalEvent.clientY};t=i.getCoordinateFromPixel(o)}}if(!t||"number"!=typeof t.lat||"number"!=typeof t.lng)return void console.error("Could not extract valid coordinate from mouse move event");this.workingData.mousePosition=t,"line"!==this.options.mode&&"polygon"!==this.options.mode||console.debug(`Mouse position: ${t.lat.toFixed(6)}, ${t.lng.toFixed(6)}`),"freehand"===this.options.mode&&this.workingData.isDragging&&this._handleFreehandDrawing(t),("line"===this.options.mode||"polygon"===this.options.mode)&&this.workingData.activeFeature&&this.workingData.vertices.length>0&&this._updatePreview()}catch(e){console.error("Error handling mouse move event:",e)}}_handleMapDoubleClick(e){let t;if(e.originalEvent&&"function"==typeof e.originalEvent.preventDefault&&e.originalEvent.preventDefault(),console.log(`Double click detected in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`),this.manager.snappingManager&&this.manager.snappingManager.getSnapPoint()){t=this.manager.snappingManager.getSnapPoint().coordinate,console.log("Using snapped coordinate for final vertex:",t)}else e.coordinate&&(t=e.coordinate);!t||"line"!==this.options.mode&&"polygon"!==this.options.mode||(console.log("Adding final vertex at double-click location"),this._addVertex(t)),"line"===this.options.mode&&this.workingData.vertices.length>=2||"polygon"===this.options.mode&&this.workingData.vertices.length>=3?(console.log(`Completing ${this.options.mode} with ${this.workingData.vertices.length} vertices`),this._completeDrawing()):console.log(`Not enough vertices to complete ${this.options.mode} drawing`)}_handleMapRightClick(e){e.originalEvent&&"function"==typeof e.originalEvent.preventDefault&&e.originalEvent.preventDefault(),console.log(`Right click detected in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`),"line"===this.options.mode&&this.workingData.vertices.length>=1||"polygon"===this.options.mode&&this.workingData.vertices.length>=2?(console.log(`Completing ${this.options.mode} with ${this.workingData.vertices.length} vertices via right-click`),"line"===this.options.mode&&this.workingData.vertices.length>=2||"polygon"===this.options.mode&&this.workingData.vertices.length>=3?this._completeDrawing():(console.log(`Not enough vertices to complete ${this.options.mode}, canceling drawing`),this._startNewDrawing())):(console.log(`Canceling drawing and starting new ${this.options.mode} feature`),this._startNewDrawing())}_handleMapMouseDown(e){if("freehand"===this.options.mode&&e.originalEvent&&"number"==typeof e.originalEvent.button&&0===e.originalEvent.button){let t;if(this.workingData.isDragging=!0,this.manager.snappingManager&&this.manager.snappingManager.getSnapPoint()){t=this.manager.snappingManager.getSnapPoint().coordinate,console.log("Using snapped coordinate for freehand start:",t)}else e.coordinate&&(t=e.coordinate);t&&this._addFreehandPoint(t)}}_handleMapMouseUp(e){if("freehand"===this.options.mode&&this.workingData.isDragging&&(this.workingData.isDragging=!1,this.workingData.activeFeature)){this.workingData.activeFeature.getCoordinates().length>=2?this._completeDrawing():this._startNewDrawing()}}_handleKeyDown(e){if("Escape"===e.key&&(console.log("Escape key pressed, canceling current drawing"),this._startNewDrawing()),"Enter"===e.key){if(console.log(`Enter key pressed in ${this.options.mode} mode, continuousDrawing=${this.options.continuousDrawing}`),("line"===this.options.mode||"polygon"===this.options.mode)&&this.workingData.vertices.length>0){let e=this.workingData.mousePosition;if(this.manager.snappingManager&&this.manager.snappingManager.getSnapPoint()){e=this.manager.snappingManager.getSnapPoint().coordinate,console.log("Using snapped coordinate for final vertex (Enter key):",e)}e&&(console.log("Adding final vertex at current position"),this._addVertex(e))}"line"===this.options.mode&&this.workingData.vertices.length>=2||"polygon"===this.options.mode&&this.workingData.vertices.length>=3?(console.log(`Completing ${this.options.mode} with ${this.workingData.vertices.length} vertices via Enter key`),this._completeDrawing()):console.log(`Not enough vertices to complete ${this.options.mode} drawing`)}"Backspace"!==e.key&&"Delete"!==e.key||(console.log("Backspace/Delete key pressed, removing last vertex"),this._removeLastVertex())}_createPoint(e){try{let t;if(e instanceof l)t=e;else{if(!e||"number"!=typeof e.lat||"number"!=typeof e.lng)throw console.error("Invalid coordinate provided:",e),new Error("Invalid coordinate");t=new l(e.lat,e.lng,void 0!==e.elevation?e.elevation:0)}const i={...this.options.pointSymbol,useDualMarker:!0},o=`point-${Date.now()}`,n=new p(t,{id:o,properties:{type:"drawing",drawingType:"point",temporary:!1},style:i});return console.log("---------- POINT CREATION ----------"),console.log(`Created point with ID: ${o}`),console.log(`At exact coordinate: ${t.lat.toFixed(8)}, ${t.lng.toFixed(8)}`),console.log(`Using style: ${JSON.stringify(i)}`),console.log("------------------------------------"),this.options.enable3D&&this.manager.applyElevationData(n),this.manager.features.addFeature(n),this.emit("pointCreated",n),this.options.continuousDrawing?console.log("Continuous drawing enabled, keeping tool active - NO deactivation will occur"):(console.log("Continuous drawing disabled, tool will be deactivated"),setTimeout((()=>{console.log("Now deactivating tool (continuousDrawing=false)"),this.manager.deactivateActiveTool()}),50)),n}catch(e){return console.error("Error creating point feature:",e),null}}_addVertex(e){try{if(!this.workingData.activeFeature&&(console.log("No active feature found when trying to add vertex"),this._startNewDrawing(),!this.workingData.activeFeature))return void console.error("Failed to create new feature for drawing");let t;if(e instanceof l)t=e;else{if(!e||"number"!=typeof e.lat||"number"!=typeof e.lng)throw console.error("Invalid coordinate provided:",e),new Error("Invalid coordinate");t=new l(e.lat,e.lng,void 0!==e.elevation?e.elevation:0)}console.log(`Adding vertex at ${t.lat}, ${t.lng} to ${this.options.mode} feature`);const i={...this.options.vertexSymbol,size:this.options.vertexSymbol.size||8,color:this.options.vertexSymbol.color||"#3388FF",outlineWidth:this.options.vertexSymbol.outlineWidth||2,outlineColor:this.options.vertexSymbol.outlineColor||"white"},o=new p(t,{id:`vertex-${Date.now()}-${this.workingData.vertices.length}`,properties:{type:"vertex",drawingId:this.workingData.activeFeature.id,vertexIndex:this.workingData.vertices.length,temporary:!0},style:i});if(this.options.enable3D&&this.manager.applyElevationData(o),this.manager.workingFeatures.addFeature(o),this.workingData.vertices.push(o),"line"===this.options.mode){const e=this.workingData.vertices.map((e=>e.getCoordinate()));console.log(`Setting line coordinates with ${e.length} vertices`),this.workingData.activeFeature.setCoordinates(e),this.workingData.activeFeature.properties.lastUpdate=Date.now(),this.manager.workingFeatures.updateFeature(this.workingData.activeFeature)}else if("polygon"===this.options.mode){const e=this.workingData.vertices.map((e=>e.getCoordinate()));console.log(`Setting polygon coordinates with ${e.length} vertices`);try{"function"==typeof this.workingData.activeFeature.setRings?this.workingData.activeFeature.setRings([e]):"function"==typeof this.workingData.activeFeature.setCoordinates?(console.log("Falling back to setCoordinates for polygon"),this.workingData.activeFeature.setCoordinates(e)):console.error("Polygon feature has neither setRings nor setCoordinates methods")}catch(e){console.error("Error updating polygon coordinates:",e)}this.workingData.activeFeature.properties.lastUpdate=Date.now(),this.manager.workingFeatures.updateFeature(this.workingData.activeFeature)}this._updatePreview(),this.emit("vertexAdded",{feature:this.workingData.activeFeature,coordinate:t,vertexIndex:this.workingData.vertices.length-1}),setTimeout((()=>{const e=this.manager.workingFeatures.getFeatureCount();console.log(`Working features count after adding vertex: ${e}`);const t=this.manager.workingFeatures.getFeaturesByType("line"),i=this.manager.workingFeatures.getFeaturesByType("point");console.log(`Working features by type - Lines: ${t.length}, Points: ${i.length}`)}),10)}catch(e){console.error("Error adding vertex:",e),console.log("Attempting to recover by restarting the drawing"),setTimeout((()=>{this._startNewDrawing()}),10)}}_addFreehandPoint(e){if(!this.workingData.activeFeature)return;if(this.workingData.lastFreehandPoint){if(this.geometryEngine.calculateDistance(this.workingData.lastFreehandPoint,e)<this.options.freehandSamplingInterval)return}let t;if(e instanceof l)t=e;else{if(!e||"number"!=typeof e.lat||"number"!=typeof e.lng)return void console.error("Invalid coordinate for freehand drawing:",e);t=new l(e.lat,e.lng,void 0!==e.elevation?e.elevation:0)}const i=this.workingData.activeFeature.getCoordinates();i.push(t),this.workingData.activeFeature.setCoordinates(i),this.workingData.lastFreehandPoint=t,this.options.enable3D&&i.length%5==0&&this.manager.applyElevationData(this.workingData.activeFeature)}_handleFreehandDrawing(e){let t=e;if(this.manager.snappingManager&&this.manager.snappingManager.getSnapPoint()){t=this.manager.snappingManager.getSnapPoint().coordinate}this._addFreehandPoint(t)}_updatePreview(){if(!this.workingData.activeFeature||!this.workingData.mousePosition)return;const e=this.workingData.vertices.map((e=>e.getCoordinate())),t=this.workingData.mousePosition;if("line"===this.options.mode&&e.length>0){const i=[...e,t];console.log(`Updating line preview with ${i.length} points, last point: ${t.lat}, ${t.lng}`),this.workingData.activeFeature.setCoordinates(i),this.workingData.activeFeature.properties.lastPreviewUpdate=Date.now(),this.manager.workingFeatures.updateFeature(this.workingData.activeFeature)}else if("polygon"===this.options.mode&&e.length>1){let i=[...e,t];e.length>0&&(i=[...i,e[0]]),console.log(`Updating polygon preview with ${i.length} points, explicitly closed, last point: ${t.lat}, ${t.lng}`),this.workingData.activeFeature.setRings([i]),this.workingData.activeFeature.properties.lastPreviewUpdate=Date.now(),this.manager.workingFeatures.updateFeature(this.workingData.activeFeature)}}_removeLastVertex(){if(0===this.workingData.vertices.length)return;const e=this.workingData.vertices.pop();if(this.manager.workingFeatures.removeFeature(e),"line"===this.options.mode){const e=this.workingData.vertices.map((e=>e.getCoordinate()));this.workingData.activeFeature.setCoordinates(e)}else if("polygon"===this.options.mode){let e=this.workingData.vertices.map((e=>e.getCoordinate()));e.length>0&&(e=[...e,e[0]]),this.workingData.activeFeature.setRings([e])}this._updatePreview(),this.emit("vertexRemoved",{feature:this.workingData.activeFeature,vertexCount:this.workingData.vertices.length})}_completeDrawing(){if(!this.workingData.activeFeature)return void console.log("No active feature to complete");let e;switch(this.options.mode){case"line":if(this.workingData.vertices.length<2)return console.log("Not enough vertices for a line (need at least 2)"),void this._startNewDrawing();const t=this.workingData.vertices.map((e=>e.getCoordinate()));console.log(`Creating final line feature with ${t.length} vertices`);try{this.workingData.activeFeature.properties.temporary=!1,this.workingData.activeFeature.properties.isPreview=!1,this.workingData.activeFeature.setCoordinates(t),this.workingData.activeFeature.style=this.options.lineSymbol;const i=t[0],o=t[t.length-1],n=i.lat.toFixed(5),r=i.lng.toFixed(5),a=o.lat.toFixed(5),s=o.lng.toFixed(5);this.workingData.activeFeature.setName(`Line from (${n}, ${r}) to (${a}, ${s})`),e=this.workingData.activeFeature,this.manager.workingFeatures.removeFeature(e)}catch(e){return console.error("Error finalizing line feature:",e),void this._startNewDrawing()}break;case"polygon":if(this.workingData.vertices.length<3)return console.log("Not enough vertices for a polygon (need at least 3)"),void this._startNewDrawing();let i=this.workingData.vertices.map((e=>e.getCoordinate()));i.length>0&&(i=[...i,i[0]]),console.log(`Creating final polygon feature with ${i.length} vertices (including closing vertex)`);try{e=new w(i,{id:`polygon-${Date.now()}`,properties:{type:"drawing",drawingType:"polygon",temporary:!1,isPreview:!1},style:this.options.polygonSymbol});try{const t=e.getCenter();if(t){const i=t.lat.toFixed(5),o=t.lng.toFixed(5);e.setName(`Polygon at (${i}, ${o})`)}else e.setName(`Polygon with ${i.length} vertices`)}catch(t){e.setName(`Polygon with ${i.length} vertices`)}this.manager.workingFeatures.removeFeature(this.workingData.activeFeature),this.workingData.vertices.forEach((e=>{this.manager.workingFeatures.removeFeature(e)}))}catch(e){return console.error("Error finalizing polygon feature:",e),void this._startNewDrawing()}break;case"freehand":const o=this.workingData.activeFeature.getCoordinates();if(o.length<2)return console.log("Not enough points for a freehand line (need at least 2)"),void this._startNewDrawing();console.log(`Creating final freehand feature with ${o.length} vertices`);try{this.workingData.activeFeature.properties.temporary=!1,this.workingData.activeFeature.properties.isPreview=!1,this.workingData.activeFeature.style=this.options.lineSymbol;const t=o[0],i=o[o.length-1],n=t.lat.toFixed(5),r=t.lng.toFixed(5),a=i.lat.toFixed(5),s=i.lng.toFixed(5);this.workingData.activeFeature.setName(`Freehand line from (${n}, ${r}) to (${a}, ${s})`),e=this.workingData.activeFeature,this.manager.workingFeatures.removeFeature(e)}catch(e){return console.error("Error finalizing freehand feature:",e),void this._startNewDrawing()}}if(e){this.options.enable3D&&this.manager.applyElevationData(e),e.properties.temporary=!1;const t="freehand"===this.options.mode?"line":this.options.mode;e.id=`${t}-${Date.now()}`,console.log(`Adding completed ${this.options.mode} feature to collection with ID ${e.id}`),console.log("Feature details:",{type:e.type,id:e.id,coordinates:e.getCoordinates?e.getCoordinates():null,name:e.name,properties:e.properties}),this.manager.features.addFeature(e),setTimeout((()=>{const e=this.manager.features.getFeatureCount(),t=this.manager.features.getFeaturesByType("line");console.log(`Total features after adding: ${e}, Line features: ${t.length}`)}),100),this.emit("drawingCompleted",e),this.options.continuousDrawing?(console.log("Continuous drawing enabled, starting new drawing"),setTimeout((()=>{this._startNewDrawing(),console.log("New drawing started in continuous mode")}),10)):(console.log("Continuous drawing disabled, scheduling tool deactivation"),setTimeout((()=>{console.log("Now deactivating tool after completing drawing (continuousDrawing=false)"),this.manager.deactivateActiveTool()}),50))}else console.error("Failed to create final feature"),this._startNewDrawing()}setMode(e){return["point","line","polygon","freehand"].includes(e)?this.options.mode===e?this.tryCompleteCurrentDrawing():(this.workingData.activeFeature&&("line"===this.options.mode&&this.workingData.vertices.length>=2||"polygon"===this.options.mode&&this.workingData.vertices.length>=3||"freehand"===this.options.mode&&this.workingData.activeFeature.getCoordinates().length>=2?this._completeDrawing():this._clearActiveDrawing()),this.options.mode=e,this._startNewDrawing(),this.emit("modeChanged",{mode:e}),!0):(console.error(`Invalid drawing mode: ${e}`),!1)}tryCompleteCurrentDrawing(){if(this.workingData.activeFeature){if("line"===this.options.mode&&this.workingData.vertices.length>=2||"polygon"===this.options.mode&&this.workingData.vertices.length>=3||"freehand"===this.options.mode&&this.workingData.activeFeature.getCoordinates().length>=2)return console.log(`Completing ${this.options.mode} drawing with ${this.workingData.vertices.length} vertices via tool button click`),this._completeDrawing(),!0;console.log(`Not enough vertices to complete ${this.options.mode} drawing`),this._startNewDrawing()}else this._startNewDrawing();return!1}setContinuousDrawing(e){return this.options.continuousDrawing=!!e,this.emit("continuousDrawingChanged",{continuousDrawing:this.options.continuousDrawing}),this.options.continuousDrawing}setEnable3D(e){return this.options.enable3D=!!e,this.emit("enable3DChanged",{enable3D:this.options.enable3D}),this.options.enable3D}setFreehandSamplingInterval(e){return isNaN(e)||e<=0?(console.error("Invalid sampling interval. Must be a positive number."),this.options.freehandSamplingInterval):(this.options.freehandSamplingInterval=e,this.emit("freehandSamplingIntervalChanged",{interval:this.options.freehandSamplingInterval}),this.options.freehandSamplingInterval)}getSettings(){return{mode:this.options.mode,enable3D:this.options.enable3D,continuousDrawing:this.options.continuousDrawing,freehandSamplingInterval:this.options.freehandSamplingInterval}}}class F extends y{constructor(e={}){super(e),this.options=Object.assign({enable3D:!0,vertexDistanceTolerance:10,allowVertexAddition:!0,allowVertexDeletion:!0,snapToTerrain:!0,dragDistanceThreshold:3,vertexSymbol:{type:"circle",size:8,color:"#3388FF",outlineWidth:1,outlineColor:"white"},selectedVertexSymbol:{type:"circle",size:10,color:"#FF5733",outlineWidth:2,outlineColor:"white"},insertionVertexSymbol:{type:"circle",size:6,color:"rgba(51, 136, 255, 0.5)",outlineWidth:1,outlineColor:"#3388FF"},lineSymbol:Object.assign({},this.manager.settings.defaultLineSymbol,{width:4,color:"#3388FF"}),polygonSymbol:Object.assign({},this.manager.settings.defaultPolygonSymbol,{outlineWidth:3,outlineColor:"#3388FF"})},e),this.workingData={targetFeature:null,originalFeature:null,vertices:[],insertionVertices:[],selectedVertex:null,isDragging:!1,dragStartPosition:null,mousePosition:null,operationMode:"none",operationComplete:!1,draggedDistance:0,snapTargets:[]},this._handleMapClick=this._handleMapClick.bind(this),this._handleMapMouseMove=this._handleMapMouseMove.bind(this),this._handleMapDoubleClick=this._handleMapDoubleClick.bind(this),this._handleMapRightClick=this._handleMapRightClick.bind(this),this._handleKeyDown=this._handleKeyDown.bind(this),this._handleMapMouseDown=this._handleMapMouseDown.bind(this),this._handleMapMouseUp=this._handleMapMouseUp.bind(this),this._handleFeatureSelected=this._handleFeatureSelected.bind(this)}_setupEventListeners(){this.manager.on("featureSelected",this._handleFeatureSelected),this.manager.features.on("featureUpdated",(e=>{this.workingData.targetFeature&&this.workingData.targetFeature.id===e.id&&this._updateVertexControls()}))}_activate(){this.mapInterface.addEventListener("click",this._handleMapClick),this.mapInterface.addEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.addEventListener("dblclick",this._handleMapDoubleClick),this.mapInterface.addEventListener("contextmenu",this._handleMapRightClick),this.mapInterface.addEventListener("mousedown",this._handleMapMouseDown),this.mapInterface.addEventListener("mouseup",this._handleMapMouseUp),document.addEventListener("keydown",this._handleKeyDown),this.workingData.operationMode="none";const e=this.manager.getSelectedFeatures();1===e.length&&this._startEditingFeature(e[0]),this.emit("activated",{enable3D:this.options.enable3D,targetFeature:this.workingData.targetFeature})}_deactivate(){this.mapInterface.removeEventListener("click",this._handleMapClick),this.mapInterface.removeEventListener("mousemove",this._handleMapMouseMove),this.mapInterface.removeEventListener("dblclick",this._handleMapDoubleClick),this.mapInterface.removeEventListener("contextmenu",this._handleMapRightClick),this.mapInterface.removeEventListener("mousedown",this._handleMapMouseDown),this.mapInterface.removeEventListener("mouseup",this._handleMapMouseUp),document.removeEventListener("keydown",this._handleKeyDown),this._completeEditing(),this._clearVertexControls(),this.workingData.targetFeature=null,this.workingData.originalFeature=null,this.workingData.operationMode="none"}_reset(){this._completeEditing(),this.workingData.operationMode="none",this.workingData.selectedVertex=null,this.workingData.isDragging=!1,this.workingData.operationComplete=!1,this.workingData.targetFeature&&this._updateVertexControls()}_handleMapClick(e){if(this.workingData.isDragging)return;const t=e.coordinate,i=e.pixel;if(this.workingData.targetFeature){if("none"===this.workingData.operationMode){const e=this._findVertexAtPosition(i);if(e)return void this._selectVertex(e);if(this.options.allowVertexAddition){const e=this._findInsertionVertexAtPosition(i);if(e)return void this._addVertexAtInsertion(e)}if(this._isPositionOnFeature(t,i))return this.workingData.operationMode="move",this.workingData.dragStartPosition=t,void this.emit("featureMoveStarted",{feature:this.workingData.targetFeature,coordinate:t});this._stopEditingFeature()}}else this._selectFeatureAtPosition(t,i)}_handleMapMouseMove(e){this.workingData.mousePosition=e.coordinate;const t=e.pixel;if(this.workingData.isDragging)this._handleDrag(e.coordinate,t);else{if(this.workingData.targetFeature){const i=this._findVertexAtPosition(t);if(i)return this._highlightVertex(i),void this.mapInterface.setCursor("pointer");if(this.options.allowVertexAddition){const e=this._findInsertionVertexAtPosition(t);if(e)return this._highlightInsertionVertex(e),void this.mapInterface.setCursor("pointer")}if(this._isPositionOnFeature(e.coordinate,t))return void this.mapInterface.setCursor("move")}this.mapInterface.setCursor("default")}}_handleMapDoubleClick(e){e.originalEvent&&e.originalEvent.preventDefault()}_handleMapRightClick(e){e.originalEvent&&e.originalEvent.preventDefault(),this.workingData.selectedVertex&&this.options.allowVertexDeletion?this._deleteSelectedVertex():this.workingData.targetFeature&&this._isPositionOnFeature(e.coordinate,e.pixel)?this._completeEditing():this._stopEditingFeature()}_handleMapMouseDown(e){if(0===e.originalEvent.button&&this.workingData.targetFeature){const t=e.pixel,i=e.coordinate,o=this._findVertexAtPosition(t);if(o)return this._selectVertex(o),this.workingData.isDragging=!0,this.workingData.dragStartPosition=i,this.workingData.operationMode="moveVertex",this.workingData.draggedDistance=0,void this.emit("vertexMoveStarted",{feature:this.workingData.targetFeature,vertexIndex:o.vertexIndex,coordinate:i});if(this.options.allowVertexAddition){if(this._findInsertionVertexAtPosition(t))return}this._isPositionOnFeature(i,t)&&(this.workingData.isDragging=!0,this.workingData.dragStartPosition=i,this.workingData.operationMode="move",this.workingData.draggedDistance=0,this.emit("featureMoveStarted",{feature:this.workingData.targetFeature,coordinate:i}))}}_handleMapMouseUp(e){this.workingData.isDragging&&(this.workingData.isDragging=!1,this.workingData.draggedDistance<this.options.dragDistanceThreshold?("moveVertex"===this.workingData.operationMode||"move"===this.workingData.operationMode)&&(this.workingData.dragStartPosition=null):("moveVertex"===this.workingData.operationMode?this.emit("vertexMoveCompleted",{feature:this.workingData.targetFeature,vertexIndex:this.workingData.selectedVertex.vertexIndex,coordinate:e.coordinate}):"move"===this.workingData.operationMode&&this.emit("featureMoveCompleted",{feature:this.workingData.targetFeature,coordinate:e.coordinate}),this.workingData.operationMode="none",this.workingData.dragStartPosition=null))}_handleKeyDown(e){"Escape"===e.key&&(this.workingData.isDragging?this._cancelDrag():this.workingData.selectedVertex?this._deselectVertex():this.workingData.targetFeature&&this._cancelEditing()),("Delete"===e.key||"Backspace"===e.key)&&this.workingData.selectedVertex&&this.options.allowVertexDeletion&&this._deleteSelectedVertex(),"Enter"===e.key&&this.workingData.targetFeature&&this._completeEditing()}_handleFeatureSelected(e){this.isActive&&(this.workingData.targetFeature&&this.workingData.targetFeature.id!==e.id&&this._completeEditing(),this._startEditingFeature(e))}_startEditingFeature(e){["point","line","polygon"].includes(e.type)?(this.workingData.originalFeature={id:e.id,type:e.type,data:e.toGeoJSON()},this.workingData.targetFeature=e,this._createVertexControls(),this.workingData.operationMode="none",this.workingData.selectedVertex=null,this.workingData.isDragging=!1,this._applyEditingStyle(),this.emit("editingStarted",{feature:e,featureType:e.type})):console.warn("Cannot edit feature of type:",e.type)}_stopEditingFeature(){if(!this.workingData.targetFeature)return;this._clearVertexControls(),this._restoreOriginalStyle();const e=this.workingData.targetFeature;this.workingData.targetFeature=null,this.workingData.originalFeature=null,this.workingData.selectedVertex=null,this.workingData.operationMode="none",this.emit("editingStopped",{feature:e})}_applyEditingStyle(){if(this.workingData.targetFeature)switch(this.workingData.originalStyle=this.workingData.targetFeature.getStyle(),this.workingData.targetFeature.type){case"point":break;case"line":this.workingData.targetFeature.setStyle(this.options.lineSymbol);break;case"polygon":this.workingData.targetFeature.setStyle(this.options.polygonSymbol)}}_restoreOriginalStyle(){this.workingData.targetFeature&&this.workingData.originalStyle&&(this.workingData.targetFeature.setStyle(this.workingData.originalStyle),this.workingData.originalStyle=null)}_createVertexControls(){if(!this.workingData.targetFeature)return;this._clearVertexControls();let e=[];switch(this.workingData.targetFeature.type){case"point":const t=this.workingData.targetFeature.getCoordinate();e.push(this._createVertexFeature(t,0));break;case"line":const i=this.workingData.targetFeature.getCoordinates();e=i.map(((e,t)=>this._createVertexFeature(e,t))),this.options.allowVertexAddition&&this._createInsertionVertices(i);break;case"polygon":const o=this.workingData.targetFeature.getRings();let n=0;o.forEach(((t,i)=>{const o=t.slice(0,-1).map(((e,t)=>{const o=this._createVertexFeature(e,n,{ringIndex:i,pointIndex:t});return n++,o}));e=e.concat(o),this.options.allowVertexAddition&&this._createInsertionVertices(t,i)}))}this.workingData.vertices=e,e.forEach((e=>{this.manager.workingFeatures.addFeature(e)})),this.workingData.insertionVertices.forEach((e=>{this.manager.workingFeatures.addFeature(e)}))}_updateVertexControls(){this._createVertexControls()}_clearVertexControls(){this.workingData.vertices.forEach((e=>{this.manager.workingFeatures.removeFeature(e)})),this.workingData.insertionVertices.forEach((e=>{this.manager.workingFeatures.removeFeature(e)})),this.workingData.vertices=[],this.workingData.insertionVertices=[],this.workingData.selectedVertex=null}_createVertexFeature(e,t,i={}){return new p(e,{id:`vertex-${this.workingData.targetFeature.id}-${t}`,properties:Object.assign({type:"vertex",featureId:this.workingData.targetFeature.id,vertexIndex:t,isSelected:!1,temporary:!0},i),style:this.options.vertexSymbol})}_createInsertionVertices(e,t=0){if(e.length<2)return;const i=[],o="polygon"===this.workingData.targetFeature.type?e.length:e.length-1;for(let n=0;n<o;n++){const o=e[n],r=e[(n+1)%e.length],a=this.geometryEngine.interpolate(o,r,.5),s=new p(a,{id:`insertion-${this.workingData.targetFeature.id}-${t}-${n}`,properties:{type:"insertionVertex",featureId:this.workingData.targetFeature.id,segmentIndex:n,ringIndex:t,startVertex:n,endVertex:(n+1)%e.length,temporary:!0},style:this.options.insertionVertexSymbol});i.push(s)}this.workingData.insertionVertices=this.workingData.insertionVertices.concat(i)}_findVertexAtPosition(e){if(!this.workingData.targetFeature||0===this.workingData.vertices.length)return null;let t=null,i=1/0;for(const o of this.workingData.vertices)try{const n=this.mapInterface.coordinateToPixel(o.getCoordinate());if(!n||n.length<2){console.warn("Invalid screen position for vertex:",o.id);continue}const r=Math.sqrt(Math.pow(n[0]-e[0],2)+Math.pow(n[1]-e[1],2));r<=this.options.vertexDistanceTolerance&&r<i&&(t=o,i=r)}catch(e){console.warn("Error calculating vertex screen position:",e)}return t}_findInsertionVertexAtPosition(e){if(!this.workingData.targetFeature||0===this.workingData.insertionVertices.length)return null;let t=null,i=1/0;for(const o of this.workingData.insertionVertices)try{const n=this.mapInterface.coordinateToPixel(o.getCoordinate());if(!n||n.length<2){console.warn("Invalid screen position for insertion vertex:",o.id);continue}const r=Math.sqrt(Math.pow(n[0]-e[0],2)+Math.pow(n[1]-e[1],2));r<=this.options.vertexDistanceTolerance&&r<i&&(t=o,i=r)}catch(e){console.warn("Error calculating insertion vertex screen position:",e)}return t}_isPositionOnFeature(e,t){if(!this.workingData.targetFeature)return!1;switch(this.workingData.targetFeature.type){case"point":return!!this._findVertexAtPosition(t);case"line":const i=this.workingData.targetFeature.getCoordinates();if(i.length<2)return!1;for(let o=0;o<i.length-1;o++){const n=this.geometryEngine.nearestPointOnSegment(i[o],i[o+1],e);if(n)try{const e=this.mapInterface.coordinateToPixel(n.point);if(!e||e.length<2){console.warn("Invalid screen position for nearest point on segment");continue}if(Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2))<=this.options.vertexDistanceTolerance)return!0}catch(e){console.warn("Error calculating screen distance for line segment:",e)}}return!1;case"polygon":return this.workingData.targetFeature.containsPoint(e)}return!1}_selectFeatureAtPosition(e,t){const i=this.manager.features.getFeaturesAtPosition(e,{tolerance:this.options.vertexDistanceTolerance,screenPosition:t,mapInterface:this.mapInterface}).filter((e=>["point","line","polygon"].includes(e.type)));i.length>0&&(this.manager.selectFeature(i[0]),this._startEditingFeature(i[0]))}_selectVertex(e){this._deselectVertex(),this.workingData.selectedVertex=e,e.setStyle(this.options.selectedVertexSymbol),e.setProperty("isSelected",!0),this.emit("vertexSelected",{feature:this.workingData.targetFeature,vertexIndex:e.getProperty("vertexIndex")})}_deselectVertex(){this.workingData.selectedVertex&&(this.workingData.selectedVertex.setStyle(this.options.vertexSymbol),this.workingData.selectedVertex.setProperty("isSelected",!1),this.emit("vertexDeselected",{feature:this.workingData.targetFeature,vertexIndex:this.workingData.selectedVertex.getProperty("vertexIndex")}),this.workingData.selectedVertex=null)}_highlightVertex(e){if(this.workingData.selectedVertex&&this.workingData.selectedVertex.id===e.id)return;const t=e.getStyle();e.setStyle(Object.assign({},t,{size:1.2*t.size})),this.workingData.vertices.forEach((t=>{t.id===e.id||t.getProperty("isSelected")||t.setStyle(this.options.vertexSymbol)}))}_highlightInsertionVertex(e){const t=e.getStyle();e.setStyle(Object.assign({},t,{size:1.5*t.size,color:"rgba(255, 87, 51, 0.5)"})),this.workingData.insertionVertices.forEach((t=>{t.id!==e.id&&t.setStyle(this.options.insertionVertexSymbol)}))}_addVertexAtInsertion(e){if(!this.workingData.targetFeature||!e)return;const t=e.getProperty("startVertex"),i=e.getProperty("endVertex"),o=e.getProperty("ringIndex")||0,n=e.getCoordinate();switch(this.workingData.targetFeature.type){case"line":const e=this.workingData.targetFeature.getCoordinates();e.splice(i,0,n),this.workingData.targetFeature.setCoordinates(e);break;case"polygon":const t=this.workingData.targetFeature.getRings();if(o>=0&&o<t.length){const e=t[o];0===i?(e.splice(e.length-1,0,n),e[e.length-1]=e[0]):e.splice(i,0,n),this.workingData.targetFeature.setRings(t)}}this._updateVertexControls(),this.emit("vertexAdded",{feature:this.workingData.targetFeature,coordinate:n,beforeIndex:t,afterIndex:i})}_deleteSelectedVertex(){if(!this.workingData.targetFeature||!this.workingData.selectedVertex)return;const e=this.workingData.selectedVertex.getProperty("vertexIndex"),t=this.workingData.selectedVertex.getProperty("ringIndex")||0;switch(this.workingData.targetFeature.type){case"point":return void console.warn("Cannot delete the vertex of a point feature");case"line":const i=this.workingData.targetFeature.getCoordinates();if(i.length<=2)return void console.warn("Cannot delete vertex: Line must have at least 2 vertices");i.splice(e,1),this.workingData.targetFeature.setCoordinates(i);break;case"polygon":const o=this.workingData.targetFeature.getRings();if(t>=0&&t<o.length){const e=o[t];if(e.length<=4)return void console.warn("Cannot delete vertex: Polygon must have at least 3 vertices");const i=this.workingData.selectedVertex.getProperty("pointIndex");e.splice(i,1),0===i&&(e[e.length-1]=e[0]),this.workingData.targetFeature.setRings(o)}}this.workingData.selectedVertex=null,this._updateVertexControls(),this.emit("vertexDeleted",{feature:this.workingData.targetFeature,vertexIndex:e})}_handleDrag(e,t){if(!this.workingData.isDragging||!this.workingData.dragStartPosition)return;const i=this.mapInterface.coordinateToPixel(this.workingData.dragStartPosition),o=Math.sqrt(Math.pow(i[0]-t[0],2)+Math.pow(i[1]-t[1],2));switch(this.workingData.draggedDistance=o,this.workingData.operationMode){case"moveVertex":this._moveSelectedVertex(e);break;case"move":this._moveFeature(e)}}_moveSelectedVertex(e){if(!this.workingData.targetFeature||!this.workingData.selectedVertex)return;const t=this.workingData.selectedVertex.getProperty("vertexIndex"),i=this.workingData.selectedVertex.getProperty("ringIndex")||0;switch(this.workingData.selectedVertex.setCoordinate(e),this.options.enable3D&&this.options.snapToTerrain&&(this.manager.applyElevationData(this.workingData.selectedVertex),e=this.workingData.selectedVertex.getCoordinate()),this.workingData.targetFeature.type){case"point":this.workingData.targetFeature.setCoordinate(e);break;case"line":const o=this.workingData.targetFeature.getCoordinates();o[t]=e,this.workingData.targetFeature.setCoordinates(o);break;case"polygon":const n=this.workingData.targetFeature.getRings();if(i>=0&&i<n.length){const t=n[i],o=this.workingData.selectedVertex.getProperty("pointIndex");t[o]=e,0===o&&(t[t.length-1]=e),this.workingData.targetFeature.setRings(n)}}this._updateVertexControls(),this.emit("vertexMoved",{feature:this.workingData.targetFeature,vertexIndex:t,coordinate:e})}_moveFeature(e){if(!this.workingData.targetFeature||!this.workingData.dragStartPosition)return;const t=void 0!==this.workingData.dragStartPosition.lat?this.workingData.dragStartPosition.lat:this.workingData.dragStartPosition.y,i=void 0!==this.workingData.dragStartPosition.lng?this.workingData.dragStartPosition.lng:this.workingData.dragStartPosition.x,o=void 0!==this.workingData.dragStartPosition.elevation?this.workingData.dragStartPosition.elevation:void 0!==this.workingData.dragStartPosition.z?this.workingData.dragStartPosition.z:0,n=void 0!==e.lat?e.lat:e.y,r=void 0!==e.lng?e.lng:e.x,a=void 0!==e.elevation?e.elevation:void 0!==e.z?e.z:0,s={lat:n-t,lng:r-i,elevation:this.options.enable3D?a-o:0};switch(this.workingData.targetFeature.type){case"point":const e=this.workingData.targetFeature.getCoordinate(),t=void 0!==e.lat?e.lat:e.y,i=void 0!==e.lng?e.lng:e.x,o=void 0!==e.elevation?e.elevation:void 0!==e.z?e.z:0,n={lat:t+s.lat,lng:i+s.lng,elevation:o+s.elevation};this.workingData.targetFeature.setCoordinate(n);break;case"line":const r=this.workingData.targetFeature.getCoordinates().map((e=>{const t=void 0!==e.lat?e.lat:e.y,i=void 0!==e.lng?e.lng:e.x,o=void 0!==e.elevation?e.elevation:void 0!==e.z?e.z:0;return{lat:t+s.lat,lng:i+s.lng,elevation:o+s.elevation}}));this.workingData.targetFeature.setCoordinates(r);break;case"polygon":const a=this.workingData.targetFeature.getRings().map((e=>e.map((e=>{const t=void 0!==e.lat?e.lat:e.y,i=void 0!==e.lng?e.lng:e.x,o=void 0!==e.elevation?e.elevation:void 0!==e.z?e.z:0;return{lat:t+s.lat,lng:i+s.lng,elevation:o+s.elevation}}))));this.workingData.targetFeature.setRings(a)}this.workingData.dragStartPosition=e,this._updateVertexControls(),this.emit("featureMoved",{feature:this.workingData.targetFeature,offset:s})}_cancelDrag(){this.workingData.isDragging&&(this.workingData.isDragging=!1,this.workingData.dragStartPosition=null,this.workingData.originalFeature&&this.workingData.targetFeature&&this.workingData.targetFeature.fromGeoJSON(this.workingData.originalFeature.data),this._updateVertexControls(),this.emit("dragCancelled",{feature:this.workingData.targetFeature}),this.workingData.operationMode="none")}_completeEditing(){if(!this.workingData.targetFeature)return;this.workingData.isDragging&&(this.workingData.isDragging=!1,this.workingData.dragStartPosition=null),this.manager.features.updateFeature(this.workingData.targetFeature),this._restoreOriginalStyle();const e=this.workingData.targetFeature;this.workingData.operationComplete=!0,this._clearVertexControls(),this.workingData.targetFeature=null,this.workingData.originalFeature=null,this.workingData.selectedVertex=null,this.workingData.operationMode="none",this.emit("editingCompleted",{feature:e})}_cancelEditing(){if(!this.workingData.targetFeature||!this.workingData.originalFeature)return;this.workingData.targetFeature.fromGeoJSON(this.workingData.originalFeature.data),this._restoreOriginalStyle();const e=this.workingData.targetFeature;this._clearVertexControls(),this.workingData.targetFeature=null,this.workingData.originalFeature=null,this.workingData.selectedVertex=null,this.workingData.operationMode="none",this.emit("editingCancelled",{feature:e})}setEnable3D(e){return this.options.enable3D=!!e,this.workingData.targetFeature&&this._updateVertexControls(),this.emit("enable3DChanged",{enable3D:this.options.enable3D}),this.options.enable3D}setAllowVertexAddition(e){return this.options.allowVertexAddition=!!e,this.workingData.targetFeature&&this._updateVertexControls(),this.emit("allowVertexAdditionChanged",{allowVertexAddition:this.options.allowVertexAddition}),this.options.allowVertexAddition}setAllowVertexDeletion(e){return this.options.allowVertexDeletion=!!e,this.emit("allowVertexDeletionChanged",{allowVertexDeletion:this.options.allowVertexDeletion}),this.options.allowVertexDeletion}setSnapToTerrain(e){return this.options.snapToTerrain=!!e,this.emit("snapToTerrainChanged",{snapToTerrain:this.options.snapToTerrain}),this.options.snapToTerrain}getSettings(){return{enable3D:this.options.enable3D,allowVertexAddition:this.options.allowVertexAddition,allowVertexDeletion:this.options.allowVertexDeletion,snapToTerrain:this.options.snapToTerrain,vertexDistanceTolerance:this.options.vertexDistanceTolerance}}}class _ extends t{constructor(e={}){if(super(),!e.manager)throw new Error("Manager instance is required for snapping manager initialization");if(!e.mapInterface)throw new Error("Map interface is required for snapping manager initialization");this.manager=e.manager,this.mapInterface=e.mapInterface,this.geometryEngine=e.geometryEngine||this.manager.geometryEngine,this.options=Object.assign({tolerance:10,enable3D:!0,snapToVertex:!0,snapToEdge:!0,snapToGrid:!1,gridSize:10,highlightSnap:!0,includeTemporaryFeatures:!0,vertexSnapSymbol:{type:"circle",size:12,color:"rgba(255, 87, 51, 0.6)",outlineWidth:2,outlineColor:"#FF5733"},edgeSnapSymbol:{type:"circle",size:10,color:"rgba(51, 136, 255, 0.6)",outlineWidth:1,outlineColor:"#3388FF"},gridSnapSymbol:{type:"circle",size:8,color:"rgba(0, 200, 0, 0.5)",outlineWidth:1,outlineColor:"#00C800"}},e),this.state={isActive:!1,currentSnap:null,snapIndicator:null,snapSourceFeature:null,snapTargets:[],lastMousePosition:null},this._handleMapMouseMove=this._handleMapMouseMove.bind(this)}activate(e={}){this.state.isActive||(e&&(this.options=Object.assign(this.options,e)),this.mapInterface.addEventListener("mousemove",this._handleMapMouseMove),this.state.isActive=!0,this.emit("activated",this.options))}deactivate(){this.state.isActive&&(this.mapInterface.removeEventListener("mousemove",this._handleMapMouseMove),this._clearSnap(),this.state.isActive=!1,this.emit("deactivated"))}setSnapTargets(e){const t=Array.isArray(e)?e:[e];this.state.snapTargets=t,this.emit("snapTargetsChanged",t)}clearSnapTargets(){this.state.snapTargets=[],this.emit("snapTargetsCleared")}setSnapSourceFeature(e){this.state.snapSourceFeature=e}_handleMapMouseMove(e){if(!e.coordinate||!e.pixel)return;this.state.lastMousePosition={coordinate:e.coordinate,pixel:e.pixel};const t=this._findSnapPoint(e.coordinate,e.pixel);t?this._updateSnap(t):this._clearSnap()}_findSnapPoint(e,t){if(!this.state.isActive)return null;let i=null;return this.options.snapToVertex&&(i=this._findVertexSnap(e,t),i)||this.options.snapToEdge&&(i=this._findEdgeSnap(e,t),i)||this.options.snapToGrid&&(i=this._findGridSnap(e),i)?i:null}_findVertexSnap(e,t){const i=this._getSnapFeatures();let o=1/0,n=null;for(const e of i){if(this.state.snapSourceFeature&&e.id===this.state.snapSourceFeature.id)continue;let i=[];switch(e.type){case"point":i=[e.getCoordinate()];break;case"line":i=e.getCoordinates();break;case"polygon":e.getRings().forEach((e=>{i=i.concat(e)}));break;default:continue}for(const r of i){const i=this.mapInterface.coordinateToPixel(r);if(!i||!Array.isArray(i)||i.length<2||!t||!Array.isArray(t)||t.length<2)continue;const a=Math.sqrt(Math.pow(i[0]-t[0],2)+Math.pow(i[1]-t[1],2));a<=this.options.tolerance&&a<o&&(o=a,n={type:"vertex",feature:e,coordinate:r,distance:a,isSnapped:!0})}}return n}_findEdgeSnap(e,t){const i=this._getSnapFeatures();let o=1/0,n=null;for(const r of i){if(this.state.snapSourceFeature&&r.id===this.state.snapSourceFeature.id)continue;if("point"===r.type)continue;const i=[];switch(r.type){case"line":const e=r.getCoordinates();for(let t=0;t<e.length-1;t++)i.push({start:e[t],end:e[t+1],feature:r});break;case"polygon":r.getRings().forEach((e=>{for(let t=0;t<e.length-1;t++)i.push({start:e[t],end:e[t+1],feature:r})}));break;default:continue}for(const r of i){const i=this.geometryEngine.nearestPointOnSegment(r.start,r.end,e);if(i){const e=this.mapInterface.coordinateToPixel(i.point),a=Math.sqrt(Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2));a<=this.options.tolerance&&a<o&&(o=a,n={type:"edge",feature:r.feature,coordinate:i.point,segmentStart:r.start,segmentEnd:r.end,segmentPosition:i.segmentPosition,distance:a,isSnapped:!0})}}}return n}_findGridSnap(e){if(!this.options.snapToGrid)return null;const t=this.options.gridSize,i=void 0!==e.lat?e.lat:e.y,o=void 0!==e.lng?e.lng:e.x,n=void 0!==e.elevation?e.elevation:void 0!==e.z?e.z:0;if(void 0===i||void 0===o)return console.error("Invalid coordinate format for grid snapping:",e),null;const r=t*(1/111e3),a=t*(1/(111e3*Math.cos(i*Math.PI/180)));return{type:"grid",coordinate:{lat:Math.round(i/r)*r,lng:Math.round(o/a)*a,elevation:n},gridSize:t,isSnapped:!0}}_getSnapFeatures(){if(this.state.snapTargets.length>0)return this.state.snapTargets;const e=this.manager.features.getAllFeatures();if(this.options.includeTemporaryFeatures){const t=this.manager.workingFeatures.getAllFeatures().filter((e=>{const t=e.getProperty("type");return!("vertex"===t||"insertionVertex"===t||"snap-indicator"===t)}));return e.concat(t)}return e}_updateSnap(e){this._clearSnap(),this.state.currentSnap=e,this.options.highlightSnap&&this._createSnapIndicator(e),this.emit("snap",e)}_clearSnap(){if(this.state.snapIndicator&&(this.manager.workingFeatures.removeFeature(this.state.snapIndicator),this.state.snapIndicator=null),this.state.currentSnap){const e=this.state.currentSnap.isSnapped;this.state.currentSnap=null,e&&this.emit("unsnap")}}_createSnapIndicator(e){let t;switch(e.type){case"vertex":default:t=this.options.vertexSnapSymbol;break;case"edge":t=this.options.edgeSnapSymbol;break;case"grid":t=this.options.gridSnapSymbol}const i=new p(e.coordinate,{id:`snap-indicator-${Date.now()}`,properties:{type:"snap-indicator",snapType:e.type,temporary:!0},style:t});this.manager.workingFeatures.addFeature(i),this.state.snapIndicator=i}getSnapPoint(){return this.state.currentSnap}snapPointAt(e,t){return!t&&this.mapInterface&&(t=this.mapInterface.coordinateToPixel(e)),this._findSnapPoint(e,t)}setSnapToVertex(e){return this.options.snapToVertex=!!e,this.emit("snapSettingsChanged",{snapToVertex:this.options.snapToVertex}),this.options.snapToVertex}setSnapToEdge(e){return this.options.snapToEdge=!!e,this.emit("snapSettingsChanged",{snapToEdge:this.options.snapToEdge}),this.options.snapToEdge}setSnapToGrid(e){return this.options.snapToGrid=!!e,this.emit("snapSettingsChanged",{snapToGrid:this.options.snapToGrid}),this.options.snapToGrid}setGridSize(e){return isNaN(e)||e<=0?(console.error("Invalid grid size. Must be a positive number."),this.options.gridSize):(this.options.gridSize=e,this.emit("snapSettingsChanged",{gridSize:this.options.gridSize}),this.options.gridSize)}setTolerance(e){return isNaN(e)||e<=0?(console.error("Invalid tolerance. Must be a positive number."),this.options.tolerance):(this.options.tolerance=e,this.emit("snapSettingsChanged",{tolerance:this.options.tolerance}),this.options.tolerance)}getSettings(){return{isActive:this.state.isActive,tolerance:this.options.tolerance,enable3D:this.options.enable3D,snapToVertex:this.options.snapToVertex,snapToEdge:this.options.snapToEdge,snapToGrid:this.options.snapToGrid,gridSize:this.options.gridSize,highlightSnap:this.options.highlightSnap,includeTemporaryFeatures:this.options.includeTemporaryFeatures}}destroy(){this.state.isActive&&this.deactivate(),this.state.snapTargets=[],this.removeAllListeners()}}class b extends t{constructor(e={}){super(),this.mapInterface=e.mapInterface,this.settings=Object.assign({enable3D:!0,autoSave:!1,undoLevels:20,elevationProvider:"mapInterface",snapTolerance:10,defaultPointSymbol:{type:"circle",size:10,color:"#FF5733"},defaultLineSymbol:{width:3,color:"#3388FF"},defaultPolygonSymbol:{fillColor:"rgba(51, 136, 255, 0.2)",outlineColor:"#3388FF",outlineWidth:2}},e.settings||{}),this.features=new v,this.workingFeatures=new v,this.selectedFeatures=new v,this.geometryEngine=new d,this.history={undoStack:[],redoStack:[],maxSize:this.settings.undoLevels},this.activeTool=null,this.activeMode="select",this.isDrawing=!1,this.isEditing=!1,this.isMeasuring=!1,this.metadata={projectName:"",created:new Date,modified:new Date,owner:"",description:"",projection:"EPSG:4326",units:{distance:"meters",area:"square-meters",angle:"degrees"},customProperties:{}},this._setupEventListeners(),this._initializeTools()}_initializeTools(){this.tools={measurement:new k({manager:this,mapInterface:this.mapInterface}),offset:new D({manager:this,mapInterface:this.mapInterface,geometryEngine:this.geometryEngine}),drawing:new M({manager:this,mapInterface:this.mapInterface}),editing:new F({manager:this,mapInterface:this.mapInterface})},this.snappingManager=new _({manager:this,tolerance:this.settings.snapTolerance,mapInterface:this.mapInterface,geometryEngine:this.geometryEngine}),this.snappingManager.activate(),this.emit("tools-initialized",{tools:Object.keys(this.tools),snappingActive:!0})}_setupEventListeners(){this.features.on("feature-added",(({feature:e})=>{this._recordHistoryAction({type:"feature-added",featureId:e.id,featureData:e.toGeoJSON()}),this.emit("feature-added",{feature:e}),this.metadata.modified=new Date})),this.features.on("feature-removed",(({feature:e})=>{this._recordHistoryAction({type:"feature-removed",featureId:e.id,featureData:e.toGeoJSON()}),this.emit("feature-removed",{feature:e}),this.metadata.modified=new Date})),this.features.on("feature-updated",(({feature:e})=>{this._recordHistoryAction({type:"feature-updated",featureId:e.id,featureData:e.toGeoJSON(),previousData:this._lastFeatureState[e.id]}),this.emit("feature-updated",{feature:e}),this.metadata.modified=new Date})),this._lastFeatureState={},this.features.on("feature-geometry-changed",(({feature:e})=>{this._lastFeatureState[e.id]=e.toGeoJSON()}))}activateTool(e,t={}){if(this.activeTool&&this.tools[this.activeTool].deactivate(),!this.tools[e])return console.error(`Tool '${e}' not found`),!1;try{return this.tools[e].activate(t),this.activeTool=e,this.activeMode=e,this.isDrawing="drawing"===e,this.isEditing="editing"===e,this.isMeasuring="measurement"===e,this.emit("tool-activated",{tool:e,options:t}),!0}catch(t){return console.error(`Failed to activate tool '${e}':`,t),!1}}deactivateActiveTool(){if(!this.activeTool)return!0;try{return this.tools[this.activeTool].deactivate(),this.activeTool=null,this.activeMode="select",this.isDrawing=!1,this.isEditing=!1,this.isMeasuring=!1,this.emit("tool-deactivated"),!0}catch(e){return console.error("Failed to deactivate tool:",e),!1}}_recordHistoryAction(e){e.timestamp=Date.now(),this.history.undoStack.push(e),this.history.redoStack=[],this.history.undoStack.length>this.history.maxSize&&this.history.undoStack.shift(),this.emit("historyChanged",{canUndo:this.history.undoStack.length>0,canRedo:this.history.redoStack.length>0})}undo(){if(0===this.history.undoStack.length)return!1;const e=this.history.undoStack.pop();this.history.redoStack.push(e);try{switch(e.type){case"featureAdded":this.features.removeFeature(e.featureId);break;case"featureRemoved":this.features.fromGeoJSON(e.featureData);break;case"featureUpdated":if(e.previousData){const t=this.features.getFeature(e.featureId);t&&(t.fromGeoJSON(e.previousData,{silent:!0}),this.features.updateFeature(t,{silent:!0}))}break;default:console.warn(`Unknown action type for undo: ${e.type}`)}return this.emit("undo-performed",e),this.emit("history-changed",{canUndo:this.history.undoStack.length>0,canRedo:this.history.redoStack.length>0}),this.metadata.modified=new Date,!0}catch(e){return this.history.undoStack.push(this.history.redoStack.pop()),console.error("Error during undo operation:",e),!1}}redo(){if(0===this.history.redoStack.length)return!1;const e=this.history.redoStack.pop();this.history.undoStack.push(e);try{switch(e.type){case"featureAdded":this.features.fromGeoJSON(e.featureData);break;case"featureRemoved":this.features.removeFeature(e.featureId);break;case"featureUpdated":const t=this.features.getFeature(e.featureId);t&&(t.fromGeoJSON(e.featureData,{silent:!0}),this.features.updateFeature(t,{silent:!0}));break;default:console.warn(`Unknown action type for redo: ${e.type}`)}return this.emit("redo-performed",e),this.emit("history-changed",{canUndo:this.history.undoStack.length>0,canRedo:this.history.redoStack.length>0}),this.metadata.modified=new Date,!0}catch(e){return this.history.redoStack.push(this.history.undoStack.pop()),console.error("Error during redo operation:",e),!1}}saveState(e={}){const t={metadata:{...this.metadata},features:this.features.toGeoJSON(),settings:{...this.settings}};return t.metadata.modified=new Date,this.emit("survey-saved",t),t}loadState(e,t={}){if(!e||!e.features)return console.error("Invalid survey data format"),!1;try{return this.features.clear(),this.workingFeatures.clear(),this.selectedFeatures.clear(),e.metadata&&(this.metadata={...e.metadata},this.metadata.created=new Date(this.metadata.created),this.metadata.modified=new Date(this.metadata.modified)),e.settings&&(this.settings=Object.assign(this.settings,e.settings)),this.features.fromGeoJSON(e.features),this.history.undoStack=[],this.history.redoStack=[],this.emit("survey-loaded",e),!0}catch(e){return console.error("Error loading survey data:",e),!1}}getSelectedFeatures(){return this.selectedFeatures.getAllFeatures()}selectFeature(e,t={}){const i="string"==typeof e?this.features.getFeature(e):e;if(!i)return!1;const o=this.selectedFeatures.hasFeature(i.id);return t.toggle&&o?this.deselectFeature(i):(t.addToSelection||this.clearSelection(),o||(this.selectedFeatures.addFeature(i),i.select(),this.emit("feature-selected",{feature:i})),!0)}deselectFeature(e){const t="string"==typeof e?this.features.getFeature(e):e;return!!t&&(!this.selectedFeatures.hasFeature(t.id)||(this.selectedFeatures.removeFeature(t),t.deselect(),this.emit("feature-deselected",{feature:t}),!0))}clearSelection(){const e=this.selectedFeatures.getAllFeatures();this.selectedFeatures.clear(),e.forEach((e=>{e.deselect()})),e.length>0&&this.emit("selection-cleared",{features:e})}async applyElevationData(e){const t=Array.isArray(e)?e:[e];if(0===t.length)return Promise.resolve([]);if(!this.settings.enable3D)return Promise.resolve(t);try{if("mapInterface"===this.settings.elevationProvider&&this.mapInterface&&"function"==typeof this.mapInterface.getElevation){for(const e of t)try{switch(e.type){case"point":const t=e.getCoordinate();if(!t.elevation){const e=await this.mapInterface.getElevation(t);t.setZ(e)}break;case"line":const i=e.getCoordinates();for(const e of i)if(!e.elevation){const t=await this.mapInterface.getElevation(e);e.setZ(t)}e.setCoordinates(i);break;case"polygon":const o=e.getRings();for(const e of o)for(const t of e)if(!t.elevation){const e=await this.mapInterface.getElevation(t);t.setZ(e)}e.setRings(o)}this.features.hasFeature(e.id)&&this.features.updateFeature(e)}catch(t){console.error(`Error applying elevation to feature ${e.id}:`,t)}return this.emit("elevation-data-applied",{features:t}),t}return console.warn("No valid elevation provider available"),t}catch(e){return console.error("Error applying elevation data:",e),t}}connectGnssModule(e,t={}){if(!e)return console.error("Invalid GNSS module provided"),!1;try{return this.gnssModule=e,this.gnssOptions=Object.assign({centerMapOnPosition:!0,trackedPositionMarker:!0,trackedPositionMarkerStyle:{color:"#4285F4",size:12,outlineColor:"#FFFFFF",outlineWidth:2},accuracyCircle:!0,qualityIndicator:!0},t),this._setupGnssEventHandlers(),this.gnssOptions.trackedPositionMarker&&this.mapInterface&&this._createPositionMarker(),this.emit("gnss-connected",{gnssModule:this.gnssModule,options:this.gnssOptions}),!0}catch(e){return console.error("Error connecting GNSS module:",e),!1}}_setupGnssEventHandlers(){this.gnssModule&&this.gnssModule.events&&"function"==typeof this.gnssModule.events.on?(this.gnssModule.events.on("position",(e=>{this._handlePositionUpdate(e)})),this.gnssModule.events.on("connection:connected",(e=>{this.emit("gnss-device-connected",e)})),this.gnssModule.events.on("connection:disconnected",(()=>{this.emit("gnss-device-disconnected")})),this.gnssModule.events.on("connection:error",(e=>{this.emit("gnss-device-error",e)})),this.gnssModule.events.on("ntrip:connected",(e=>{this.emit("gnss-ntrip-connected",e)})),this.gnssModule.events.on("ntrip:disconnected",(()=>{this.emit("gnss-ntrip-disconnected")})),this.gnssModule.events.on("ntrip:error",(e=>{this.emit("gnss-ntrip-error",e)}))):console.warn("GNSS module has no events interface")}_handlePositionUpdate(e){e&&e.latitude&&e.longitude&&(this.currentPosition=e,this.gnssOptions.trackedPositionMarker&&this.positionMarker&&this.mapInterface&&this._updatePositionMarker(e),this.gnssOptions.centerMapOnPosition&&this.mapInterface&&this.mapInterface.setCenter({lat:e.latitude,lng:e.longitude}),this.emit("gnss-position-updated",e))}_createPositionMarker(){this.mapInterface&&(this.positionMarker||(this.mapInterface&&"function"==typeof this.mapInterface.createMarker&&(this.positionMarker=this.mapInterface.createMarker({lat:0,lng:0},{...this.gnssOptions.trackedPositionMarkerStyle,visible:!1,zIndex:1e3})),this.gnssOptions.accuracyCircle&&"function"==typeof this.mapInterface.createCircle&&(this.accuracyCircle=this.mapInterface.createCircle({lat:0,lng:0},0,{fillColor:"rgba(66, 133, 244, 0.2)",strokeColor:"#4285F4",strokeWeight:1,visible:!1,zIndex:999}))))}_updatePositionMarker(e){if(!e||!e.latitude||!e.longitude)return;const t=this._getPositionStyleByQuality(e.quality);this.positionMarker&&(this.positionMarker.setPosition({lat:e.latitude,lng:e.longitude}),"function"==typeof this.positionMarker.setStyle&&this.positionMarker.setStyle(t),"function"==typeof this.positionMarker.setVisible&&this.positionMarker.setVisible(!0)),this.accuracyCircle&&e.accuracy&&(this.accuracyCircle.setCenter({lat:e.latitude,lng:e.longitude}),this.accuracyCircle.setRadius(e.accuracy),"function"==typeof this.accuracyCircle.setVisible&&this.accuracyCircle.setVisible(!0))}_getPositionStyleByQuality(e){const t={...this.gnssOptions.trackedPositionMarkerStyle};switch(e){case 4:t.color="#4CAF50";break;case 5:t.color="#FF9800";break;case 2:t.color="#FFEB3B";break;case 1:t.color="#2196F3";break;default:t.color="#F44336"}return t}async captureGnssPosition(e={}){if(!this.gnssModule||!this.currentPosition)return console.warn("No GNSS position available"),null;const t=this.currentPosition;try{const{PointFeature:i}=await Promise.resolve().then((function(){return m})),{Coordinate:o}=await Promise.resolve().then((function(){return h})),n=new o(t.latitude,t.longitude,t.altitude||0),r=this._getPositionStyleByQuality(t.quality),a=new i(n,Object.assign({name:`GNSS Point ${(new Date).toLocaleTimeString()}`,properties:{source:"gnss",quality:t.quality,satellites:t.satellites,accuracy:t.accuracy,timestamp:t.timestamp||(new Date).toISOString()},style:r},e));return this.features.addFeature(a),this.emit("gnss-position-captured",{feature:a,position:t}),a}catch(e){return console.error("Error capturing GNSS position:",e),null}}disconnectGnssModule(){if(!this.gnssModule)return!0;try{return this.positionMarker&&("function"==typeof this.positionMarker.setMap&&this.positionMarker.setMap(null),this.positionMarker=null),this.accuracyCircle&&("function"==typeof this.accuracyCircle.setMap&&this.accuracyCircle.setMap(null),this.accuracyCircle=null),this.currentPosition=null,this.gnssModule=null,this.emit("gnss-disconnected"),!0}catch(e){return console.error("Error disconnecting GNSS module:",e),!1}}destroy(){this.gnssModule&&this.disconnectGnssModule(),this.deactivateActiveTool(),this.removeAllListeners(),Object.values(this.tools).forEach((e=>{"function"==typeof e.destroy&&e.destroy()})),this.features.clear(),this.workingFeatures.clear(),this.selectedFeatures.clear(),this.history.undoStack=[],this.history.redoStack=[],this.emit("destroyed",{manager:this})}}function P(e,t={}){const{PointFeature:i}=require("./PointFeature.js");return new i(e,t)}function S(e,t={}){const{LineFeature:i}=require("./LineFeature.js");return new i(e,t)}function E(e,t={}){const{PolygonFeature:i}=require("./PolygonFeature.js");return new i(e,t)}function C(e=[],t={}){const{FeatureCollection:i}=require("./FeatureCollection.js");return new i(e,t)}function x(e,t={}){if(!e)return[];if("FeatureCollection"===e.type&&Array.isArray(e.features))return e.features.map((e=>I(e,t))).filter(Boolean);if("Feature"===e.type){const i=I(e,t);return i?[i]:[]}if(e.type&&e.coordinates){const i=I({type:"Feature",geometry:e},t);return i?[i]:[]}return[]}function I(e,t={}){if(!e||!e.geometry||!e.geometry.type)return null;let i;switch(e.geometry.type){case"Point":i=P([],{id:e.id});break;case"LineString":i=S([],{id:e.id});break;case"Polygon":i=E([],{id:e.id});break;default:return console.warn(`Unsupported GeoJSON geometry type: ${e.geometry.type}`),null}return i&&i.fromGeoJSON(e,t),i}class A{constructor(e={}){if(this.constructor===A)throw new Error("Abstract class 'MapInterface' cannot be instantiated directly.");this.options=e}setCursor(e){throw new Error("Method 'setCursor()' must be implemented.")}async initialize(e){throw new Error("Method 'initialize()' must be implemented.")}async setCenter(e){throw new Error("Method 'setCenter()' must be implemented.")}async setZoom(e){throw new Error("Method 'setZoom()' must be implemented.")}async addMarker(e,t={}){throw new Error("Method 'addMarker()' must be implemented.")}async removeMarker(e){throw new Error("Method 'removeMarker()' must be implemented.")}async addPolyline(e,t={}){throw new Error("Method 'addPolyline()' must be implemented.")}async removePolyline(e){throw new Error("Method 'removePolyline()' must be implemented.")}async addPolygon(e,t={}){throw new Error("Method 'addPolygon()' must be implemented.")}async removePolygon(e){throw new Error("Method 'removePolygon()' must be implemented.")}async getBounds(){throw new Error("Method 'getBounds()' must be implemented.")}async fitBounds(e,t={}){throw new Error("Method 'fitBounds()' must be implemented.")}async addEventListener(e,t){throw new Error("Method 'addEventListener()' must be implemented.")}async removeEventListener(e,t){throw new Error("Method 'removeEventListener()' must be implemented.")}async getElevation(e){throw new Error("Method 'getElevation()' must be implemented.")}async getElevationsForPath(e){throw new Error("Method 'getElevationsForPath()' must be implemented.")}coordinateToPixel(e){throw new Error("Method 'coordinateToPixel()' must be implemented.")}pixelToCoordinate(e){throw new Error("Method 'pixelToCoordinate()' must be implemented.")}}class T extends A{constructor(e={}){if(super(e),this.constructor===T)throw new Error("Abstract class 'Map3DInterface' cannot be instantiated directly.")}async setTilt(e){throw new Error("Method 'setTilt()' must be implemented.")}async setHeading(e){throw new Error("Method 'setHeading()' must be implemented.")}async getCameraPosition(){throw new Error("Method 'getCameraPosition()' must be implemented.")}async setCameraPosition(e){throw new Error("Method 'setCameraPosition()' must be implemented.")}async addModel(e,t={}){throw new Error("Method 'addModel()' must be implemented.")}async removeModel(e){throw new Error("Method 'removeModel()' must be implemented.")}async addTerrain(e={}){throw new Error("Method 'addTerrain()' must be implemented.")}async removeTerrain(){throw new Error("Method 'removeTerrain()' must be implemented.")}async setTerrainExaggeration(e){throw new Error("Method 'setTerrainExaggeration()' must be implemented.")}}class ${constructor(e={}){if(this.constructor===$)throw new Error("Abstract class 'ElevationService' cannot be instantiated directly.");this.options=e}async getElevation(e){throw new Error("Method 'getElevation()' must be implemented.")}async getElevationsForPath(e){throw new Error("Method 'getElevationsForPath()' must be implemented.")}async getElevationsForLocations(e){throw new Error("Method 'getElevationsForLocations()' must be implemented.")}}class O extends A{constructor(e={}){super(e),this.map=e.mapInstance||null,this.apiLoaded=null!==this.map||window.google&&window.google.maps,this.apiKey=e.apiKey,this.mapOptions=e.mapOptions||{center:{lat:0,lng:0},zoom:2,mapTypeId:"hybrid",mapTypeControl:!0,fullscreenControl:!0,streetViewControl:!1},this.eventListeners=new Map}setCursor(e){this.map&&(this.map.getDiv().style.cursor=e)}async _loadGoogleMapsAPI(){if(!window.google||!window.google.maps){if(!this.apiKey)throw new Error("Google Maps API key is required for initialization");return new Promise(((e,t)=>{const i=`GoogleMapsCallback_${Date.now()}`;window[i]=()=>{this.apiLoaded=!0,delete window[i],e()};const o=document.createElement("script");o.src=`https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&callback=${i}&libraries=geometry,places`,o.async=!0,o.defer=!0,o.onerror=()=>t(new Error("Failed to load Google Maps API")),document.head.appendChild(o)}))}this.apiLoaded=!0}async initialize(e){if(this.map)return Promise.resolve();await this._loadGoogleMapsAPI();const t="string"==typeof e?document.getElementById(e):e;if(!t)throw new Error(`Map container element not found: ${e}`);return this.map=new google.maps.Map(t,this.mapOptions),new Promise((e=>{google.maps.event.addListenerOnce(this.map,"idle",(()=>{e()}))}))}_toLatLng(e){return new google.maps.LatLng(e.lat,e.lng)}_toCoordinate(e,t=null){const i=null!=t?t:0;return new l(e.lat(),e.lng(),i)}async setCenter(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");return this.map.setCenter(this._toLatLng(e)),Promise.resolve()}async setZoom(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");return this.map.setZoom(e),Promise.resolve()}async addMarker(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i={position:this._toLatLng(e),map:this.map,title:t.title||"",label:t.label||null,icon:t.icon||null,draggable:t.draggable||!1,zIndex:t.zIndex||null,...t.markerOptions},o=new google.maps.Marker(i);return o.elevation=e.elevation,Promise.resolve(o)}async removeMarker(e){return e?(e.setMap(null),Promise.resolve()):Promise.resolve()}async addPolyline(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i={path:e.map((e=>this._toLatLng(e))),map:this.map,strokeColor:t.strokeColor||"#FF0000",strokeOpacity:t.strokeOpacity||1,strokeWeight:t.strokeWeight||3,...t.polylineOptions},o=new google.maps.Polyline(i);return o.originalCoordinates=[...e],Promise.resolve(o)}async removePolyline(e){return e?(e.setMap(null),Promise.resolve()):Promise.resolve()}async addPolygon(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i={paths:e.map((e=>this._toLatLng(e))),map:this.map,strokeColor:t.strokeColor||"#FF0000",strokeOpacity:t.strokeOpacity||.8,strokeWeight:t.strokeWeight||2,fillColor:t.fillColor||"#FF0000",fillOpacity:t.fillOpacity||.35,...t.polygonOptions},o=new google.maps.Polygon(i);return o.originalCoordinates=[...e],Promise.resolve(o)}async removePolygon(e){return e?(e.setMap(null),Promise.resolve()):Promise.resolve()}async getBounds(){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const e=this.map.getBounds();if(!e)return Promise.resolve(null);const t=e.getNorthEast(),i=e.getSouthWest();return Promise.resolve({north:t.lat(),east:t.lng(),south:i.lat(),west:i.lng(),northEast:this._toCoordinate(t),southWest:this._toCoordinate(i)})}async fitBounds(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");let i;if(e.northEast&&e.southWest)i=new google.maps.LatLngBounds(this._toLatLng(e.southWest),this._toLatLng(e.northEast));else if(e.north&&e.south&&e.east&&e.west)i=new google.maps.LatLngBounds(new google.maps.LatLng(e.south,e.west),new google.maps.LatLng(e.north,e.east));else{if(!Array.isArray(e))throw new Error("Invalid bounds format");i=new google.maps.LatLngBounds,e.forEach((e=>{i.extend(this._toLatLng(e))}))}const o={padding:t.padding||0,...t.fitOptions};return this.map.fitBounds(i,o),Promise.resolve()}async addEventListener(e,t){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i="contextmenu"===e?"rightclick":e;let o=0;let n=0;const r=google.maps.event.addListener(this.map,i,(i=>{if("click"===e||"dblclick"===e){const t=Date.now();if(t-n<100)return void console.debug(`Debounced ${e} event, too soon after last click`);if(n=t,i.placeId||i.feature)return void console.debug("Ignoring click on Google Maps POI or feature")}if("mousemove"===e){const e=Date.now();if(e-o<50)return;o=e}const r={preventDefault:function(){i.domEvent&&"function"==typeof i.domEvent.preventDefault&&i.domEvent.preventDefault()},stopPropagation:function(){i.domEvent&&"function"==typeof i.domEvent.stopPropagation&&i.domEvent.stopPropagation()},domEvent:i.domEvent||null,...i},a={type:e,originalEvent:r};if(i.latLng){"click"===e||"dblclick"===e||"contextmenu"===e?(a.coordinate=this._toCoordinate(i.latLng),console.log(`Google Maps ${e} event:`,`${i.latLng.lat().toFixed(6)}, ${i.latLng.lng().toFixed(6)}`,i.domEvent?`DOM event: ${i.domEvent.type}`:"")):a.coordinate={lat:i.latLng.lat(),lng:i.latLng.lng(),elevation:0},a.latLng=i.latLng;try{if(this.map.getProjection()){const t=i.latLng,o=this.map.getProjection().fromLatLngToPoint(t),n=Math.pow(2,this.map.getZoom()),r=new google.maps.Point(o.x*n,o.y*n),s=this.map.getDiv().getBoundingClientRect();a.pixel=[Math.floor(r.x-(s.left+window.scrollX)),Math.floor(r.y-(s.top+window.scrollY))],"click"===e&&console.debug(`Click at pixel: ${a.pixel[0]}, ${a.pixel[1]}`)}}catch(e){console.warn("Error computing pixel coordinates:",e)}}t(a)}));return this.eventListeners.has(e)||this.eventListeners.set(e,new Map),this.eventListeners.get(e).set(t,r),Promise.resolve(r)}async removeEventListener(e,t){if(!t)return Promise.resolve();let i=t;if("function"==typeof t){if(!this.eventListeners.has(e)||!this.eventListeners.get(e).has(t))return console.warn(`No event listener found for ${e}`),Promise.resolve();i=this.eventListeners.get(e).get(t),this.eventListeners.get(e).delete(t)}try{google.maps.event.removeListener(i)}catch(t){console.warn(`Error removing listener for ${e}:`,t)}return Promise.resolve()}async getElevation(e){if(!this.apiLoaded)throw new Error("Google Maps API not loaded. Call initialize() first.");if(null!==e.elevation&&void 0!==e.elevation)return Promise.resolve(e.elevation);const t=new google.maps.ElevationService,i=[this._toLatLng(e)];return new Promise(((e,o)=>{t.getElevationForLocations({locations:i},((t,i)=>{i===google.maps.ElevationStatus.OK&&t&&t.length>0?e(t[0].elevation):o(new Error(`Elevation service failed: ${i}`))}))}))}async getElevationsForPath(e){if(!this.apiLoaded)throw new Error("Google Maps API not loaded. Call initialize() first.");const t=new google.maps.ElevationService,i=e.map((e=>this._toLatLng(e))),o=Math.min(e.length,512);return new Promise(((e,n)=>{t.getElevationAlongPath({path:i,samples:o},((t,i)=>{if(i===google.maps.ElevationStatus.OK&&t&&t.length>0){const i=t.map((e=>e.elevation));e(i)}else n(new Error(`Elevation service failed: ${i}`))}))}))}coordinateToPixel(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const t=this._toLatLng(e),i=this.map.getProjection();if(!i)throw new Error("Map projection not ready.");const o=i.fromLatLngToPoint(t),n=Math.pow(2,this.map.getZoom()),r=new google.maps.Point(o.x*n,o.y*n),a=this.map.getDiv().getBoundingClientRect(),s=new google.maps.Point(a.left+window.scrollX,a.top+window.scrollY);return[Math.floor(r.x-s.x),Math.floor(r.y-s.y)]}pixelToCoordinate(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const t=this.map.getProjection();if(!t)throw new Error("Map projection not ready.");const i=this.map.getDiv().getBoundingClientRect(),o=new google.maps.Point(i.left+window.scrollX,i.top+window.scrollY),n=Math.pow(2,this.map.getZoom()),r=new google.maps.Point((e[0]+o.x)/n,(e[1]+o.y)/n),a=t.fromPointToLatLng(r);return this._toCoordinate(a)}createLabel(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const t=e.position,i=e.text||"",o=e.style||{};this._labels||(this._labels=[]);const n=t.lat&&t.lng?new google.maps.LatLng(t.lat,t.lng):this._toLatLng(t),r=o.font||"12px Arial",a=o.fillColor||"black",s=o.strokeColor||"white",l=o.strokeWidth||3;class h extends google.maps.OverlayView{constructor(e,t,i,o){super(),this.map=e,this.latLng=t,this.text=i,this.style=o,this.div=null,this.setMap(e)}onAdd(){const e=document.createElement("div");e.style.position="absolute",e.style.padding="2px 6px",e.style.borderRadius="3px",e.style.backgroundColor="rgba(255, 255, 255, 0.8)",e.style.font=this.style.font,e.style.color=this.style.fillColor,e.style.textShadow=`${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                       0 ${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                       -${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                       0 -${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}`,e.style.whiteSpace="nowrap",e.style.userSelect="none",e.style.pointerEvents="none",e.innerHTML=this.text,this.div=e;this.getPanes().overlayLayer.appendChild(e)}draw(){if(!this.div)return;const e=this.getProjection().fromLatLngToDivPixel(this.latLng);this.div.style.left=`${e.x}px`,this.div.style.top=`${e.y}px`,this.div.style.transform="translate(-50%, -100%)"}onRemove(){this.div&&(this.div.parentNode.removeChild(this.div),this.div=null)}setPosition(e){this.latLng=e,this.draw()}setText(e){this.text=e,this.div&&(this.div.innerHTML=e)}setStyle(e){this.style={...this.style,...e},this.div&&(this.div.style.font=this.style.font,this.div.style.color=this.style.fillColor,this.div.style.textShadow=`${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                               0 ${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                               -${this.style.strokeWidth}px 0 ${this.style.strokeWidth}px ${this.style.strokeColor}, \n                                               0 -${this.style.strokeWidth}px ${this.style.strokeWidth}px ${this.style.strokeColor}`)}}const c=new h(this.map,n,i,{font:r,fillColor:a,strokeColor:s,strokeWidth:l});return this._labels.push(c),c}removeLabel(e){if(e&&(e.setMap(null),this._labels)){const t=this._labels.indexOf(e);-1!==t&&this._labels.splice(t,1)}}}class z extends A{constructor(e={}){super(e),this.map=null,this.apiLoaded=!1,this.mapOptions=e.mapOptions||{center:[0,0],zoom:2,minZoom:2,maxZoom:18},this.tileLayerUrl=e.tileLayerUrl||"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",this.eventListeners=new Map,this.tileLayerOptions=e.tileLayerOptions||{attribution:'&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'},this.eventListeners=new Map}setCursor(e){this.map&&(this.map.getContainer().style.cursor=e)}async _loadLeafletAPI(){if(window.L)return this.apiLoaded=!0,Promise.resolve();const e=new Promise(((e,t)=>{const i=document.createElement("link");i.rel="stylesheet",i.href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css",i.integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=",i.crossOrigin="",i.onload=e,i.onerror=()=>t(new Error("Failed to load Leaflet CSS")),document.head.appendChild(i)})),t=new Promise(((e,t)=>{const i=document.createElement("script");i.src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js",i.integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=",i.crossOrigin="",i.async=!0,i.onload=()=>{this.apiLoaded=!0,e()},i.onerror=()=>t(new Error("Failed to load Leaflet JS")),document.head.appendChild(i)}));return Promise.all([e,t])}async initialize(e){await this._loadLeafletAPI();const t="string"==typeof e?document.getElementById(e):e;if(!t)throw new Error(`Map container element not found: ${e}`);return this.map=L.map(t,this.mapOptions),L.tileLayer(this.tileLayerUrl,this.tileLayerOptions).addTo(this.map),Promise.resolve()}_toLatLng(e){return L.latLng(e.latitude,e.longitude)}_toCoordinate(e,t=null){return new l(e.lat,e.lng,t)}async setCenter(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");return this.map.setView(this._toLatLng(e),this.map.getZoom()),Promise.resolve()}async setZoom(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");return this.map.setZoom(e),Promise.resolve()}async addMarker(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i={title:t.title||"",alt:t.label||"",draggable:t.draggable||!1,...t.markerOptions};t.icon&&("string"==typeof t.icon?i.icon=L.icon({iconUrl:t.icon,iconSize:t.iconSize||[25,41],iconAnchor:t.iconAnchor||[12,41],popupAnchor:t.popupAnchor||[1,-34]}):t.icon.options&&(i.icon=t.icon));const o=L.marker([e.latitude,e.longitude],i).addTo(this.map);return o.elevation=e.elevation,Promise.resolve(o)}async removeMarker(e){return e?(this.map.removeLayer(e),Promise.resolve()):Promise.resolve()}async addPolyline(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i=e.map((e=>[e.latitude,e.longitude])),o={color:t.strokeColor||"#FF0000",opacity:t.strokeOpacity||1,weight:t.strokeWeight||3,...t.polylineOptions},n=L.polyline(i,o).addTo(this.map);return n.originalCoordinates=[...e],Promise.resolve(n)}async removePolyline(e){return e?(this.map.removeLayer(e),Promise.resolve()):Promise.resolve()}async addPolygon(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i=e.map((e=>[e.latitude,e.longitude])),o={color:t.strokeColor||"#FF0000",opacity:t.strokeOpacity||.8,weight:t.strokeWeight||2,fillColor:t.fillColor||"#FF0000",fillOpacity:t.fillOpacity||.35,...t.polygonOptions},n=L.polygon(i,o).addTo(this.map);return n.originalCoordinates=[...e],Promise.resolve(n)}async removePolygon(e){return e?(this.map.removeLayer(e),Promise.resolve()):Promise.resolve()}async getBounds(){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const e=this.map.getBounds(),t=e.getNorthEast(),i=e.getSouthWest();return Promise.resolve({north:t.lat,east:t.lng,south:i.lat,west:i.lng,northEast:this._toCoordinate(t),southWest:this._toCoordinate(i)})}async fitBounds(e,t={}){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");let i;if(e.northEast&&e.southWest)i=L.latLngBounds(this._toLatLng(e.southWest),this._toLatLng(e.northEast));else if(e.north&&e.south&&e.east&&e.west)i=L.latLngBounds(L.latLng(e.south,e.west),L.latLng(e.north,e.east));else{if(!Array.isArray(e))throw new Error("Invalid bounds format");{const t=e.map((e=>this._toLatLng(e)));i=L.latLngBounds(t)}}const o={padding:t.padding?L.point(t.padding,t.padding):null,maxZoom:t.maxZoom||null,animate:!1!==t.animate,...t.fitOptions};return this.map.fitBounds(i,o),Promise.resolve()}async addEventListener(e,t){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const i="click"===e?"click":"zoom_changed"===e?"zoomend":"center_changed"===e||"bounds_changed"===e?"moveend":e,o=i=>{const o={type:e,originalEvent:i};if(i.latlng){o.coordinate=this._toCoordinate(i.latlng);const e=this.coordinateToPixel(o.coordinate);o.pixel=e}t(o)};this.map.on(i,o);const n={leafletEventType:i,handlerFunction:o};return this.eventListeners.has(e)||this.eventListeners.set(e,new Map),this.eventListeners.get(e).set(t,n),Promise.resolve(n)}async removeEventListener(e,t){if(!t||!this.map)return Promise.resolve();let i=t;if("function"==typeof t){if(!this.eventListeners.has(e)||!this.eventListeners.get(e).has(t))return console.warn(`No event listener found for ${e}`),Promise.resolve();i=this.eventListeners.get(e).get(t),this.eventListeners.get(e).delete(t)}try{this.map.off(i.leafletEventType,i.handlerFunction)}catch(t){console.warn(`Error removing listener for ${e}:`,t)}return Promise.resolve()}async getElevation(e){return null!==e.elevation&&void 0!==e.elevation?Promise.resolve(e.elevation):(console.warn("LeafletAdapter.getElevation: No elevation service configured"),Promise.resolve(0))}async getElevationsForPath(e){const t=e.map((e=>null!==e.elevation&&void 0!==e.elevation?e.elevation:0));return console.warn("LeafletAdapter.getElevationsForPath: No elevation service configured"),Promise.resolve(t)}coordinateToPixel(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const t=L.latLng(e.lat,e.lng),i=this.map.latLngToContainerPoint(t);return[i.x,i.y]}pixelToCoordinate(e){if(!this.map)throw new Error("Map not initialized. Call initialize() first.");const t=L.point(e[0],e[1]),i=this.map.containerPointToLatLng(t);return this._toCoordinate(i)}}class V extends ${constructor(e={}){super(e),this.apiLoaded=!1,this.apiKey=e.apiKey,this.elevationService=null}async _loadGoogleMapsAPI(){if(window.google&&window.google.maps)return this.apiLoaded=!0,void(!this.elevationService&&window.google.maps.ElevationService&&(this.elevationService=new google.maps.ElevationService));if(!this.apiKey)throw new Error("Google Maps API key is required for initialization");return new Promise(((e,t)=>{const i=`GoogleMapsCallback_${Date.now()}`;window[i]=()=>{this.apiLoaded=!0,this.elevationService=new google.maps.ElevationService,delete window[i],e()};const o=document.createElement("script");o.src=`https://maps.googleapis.com/maps/api/js?key=${this.apiKey}&callback=${i}&libraries=geometry`,o.async=!0,o.defer=!0,o.onerror=()=>t(new Error("Failed to load Google Maps API")),document.head.appendChild(o)}))}_toLatLng(e){return new google.maps.LatLng(e.latitude,e.longitude)}async getElevation(e){if(this.apiLoaded||await this._loadGoogleMapsAPI(),null!==e.elevation&&void 0!==e.elevation)return Promise.resolve(e.elevation);const t=[this._toLatLng(e)];return new Promise(((e,i)=>{this.elevationService.getElevationForLocations({locations:t},((t,o)=>{o===google.maps.ElevationStatus.OK&&t&&t.length>0?e(t[0].elevation):i(new Error(`Elevation service failed: ${o}`))}))}))}async getElevationsForPath(e){this.apiLoaded||await this._loadGoogleMapsAPI();const t=e.map((e=>this._toLatLng(e))),i=Math.min(e.length,512);return new Promise(((e,o)=>{this.elevationService.getElevationAlongPath({path:t,samples:i},((t,i)=>{if(i===google.maps.ElevationStatus.OK&&t&&t.length>0){const i=t.map((e=>e.elevation));e(i)}else o(new Error(`Elevation service failed: ${i}`))}))}))}async getElevationsForLocations(e){this.apiLoaded||await this._loadGoogleMapsAPI();const t=[];for(let i=0;i<e.length;i+=512){const o=e.slice(i,i+512).map((e=>this._toLatLng(e)));t.push(new Promise(((e,t)=>{this.elevationService.getElevationForLocations({locations:o},((i,o)=>{o===google.maps.ElevationStatus.OK&&i?e(i.map((e=>e.elevation))):t(new Error(`Elevation service failed: ${o}`))}))})))}return(await Promise.all(t)).flat()}}let R=class{static createMap(e,t={}){switch(e.toLowerCase()){case"google":return new O(t);case"leaflet":return new z(t);default:throw new Error(`Unsupported map provider type: ${e}`)}}static isProviderAvailable(e,t={}){switch(e.toLowerCase()){case"google":return"undefined"!=typeof window&&(void 0!==window.google||void 0!==t.apiKey);case"leaflet":return"undefined"!=typeof window;default:return!1}}static getSupportedProviders(){return["google","leaflet"]}};class j{constructor(e,t={}){if(this.constructor===j)throw new Error("Abstract class 'RenderingStrategy' cannot be instantiated directly.");this.map=e,this.options=t}async renderPoint(e,t={}){throw new Error("Method 'renderPoint()' must be implemented.")}async renderLine(e,t={}){throw new Error("Method 'renderLine()' must be implemented.")}async renderPolygon(e,t={}){throw new Error("Method 'renderPolygon()' must be implemented.")}async removeFeature(e){throw new Error("Method 'removeFeature()' must be implemented.")}async updateFeature(e,t,i={}){throw new Error("Method 'updateFeature()' must be implemented.")}async highlightFeature(e,t={}){throw new Error("Method 'highlightFeature()' must be implemented.")}async unhighlightFeature(e){throw new Error("Method 'unhighlightFeature()' must be implemented.")}}class N extends j{constructor(e,t={}){if(super(e,t),!e||!e.map)throw new Error("GoogleMapsRenderingStrategy requires a valid GoogleMapsAdapter instance");this.googleMap=e.map,this.renderedFeatures=new Map}async renderPoint(e,t={}){try{const i=e.getCoordinate?e.getCoordinate():e.coordinate;if(!i)throw new Error("Invalid point feature: no coordinate found");console.log("========== RENDERING POINT =========="),console.log(`Coordinate: ${i.lat.toFixed(6)}, ${i.lng.toFixed(6)}`),console.log(`Feature ID: ${e.id||"unknown"}`),console.log(`Source: ${e.properties?.source||"standard"}`);const o=e.style||t.style||this.options.defaultPointStyle||{};if(console.log("Marker style: "+(o.useDualMarker?"dual-marker":o.iconUrl?"image":"circle")),console.log(`Marker color: ${o.color||"default"}`),console.log("======================================="),!this._isAdvancedMarkerAvailable())throw new Error("Advanced Markers are required and not available in the current Google Maps API version");const n=this._createMarkerIcon(o,e),r={position:{lat:i.lat,lng:i.lng},map:this.googleMap,title:e.name||e.properties?.name||"",gmpDraggable:t.draggable||!1,content:n.content},a=new google.maps.marker.AdvancedMarkerElement(r);a.originalFeature=e,(t.onClick||!1!==t.selectable)&&a.addEventListener("gmp-click",(i=>(console.log(`Advanced marker gmp-click received for feature: ${e.id}`),i.stopPropagation&&i.stopPropagation(),i.stopImmediatePropagation&&i.stopImmediatePropagation(),i.preventDefault&&i.preventDefault(),t.onClick&&t.onClick({feature:e,renderedFeature:a,originalEvent:i}),!1!==t.selectable&&this._handleFeatureClick(e,a,i),!1)));const s={id:e.id,type:"point",originalFeature:e,renderedObject:a,options:t};return this.renderedFeatures.set(e.id,s),s}catch(e){throw console.error("Error rendering point feature:",e),e}}async renderLine(e,t={}){try{let i=e.getCoordinates?e.getCoordinates():e.coordinates;i&&Array.isArray(i)||(console.warn("Line feature has no coordinates array"),i=[]);const o=e.style||t.style||this.options.defaultLineStyle||{};let n;if(i.length<2){if(!e.properties?.temporary&&!e.properties?.isPreview)throw new Error("Invalid permanent line feature: insufficient coordinates (need at least 2)");if(console.log(`Creating initial placeholder line with ${i.length} points`),0===i.length){const e=this.googleMap.getCenter();n=[{lat:e.lat(),lng:e.lng()},{lat:e.lat(),lng:e.lng()}]}else{const e=i[0];n=[{lat:e.lat,lng:e.lng},{lat:e.lat,lng:e.lng}]}}else n=i.map((e=>({lat:e.lat,lng:e.lng})));const r={path:n,map:this.googleMap,geodesic:!1!==t.geodesic,strokeColor:o.color||o.strokeColor||"#3388FF",strokeOpacity:o.opacity||o.strokeOpacity||1,strokeWeight:o.width||o.strokeWeight||3,clickable:!0,zIndex:100},a=new google.maps.Polyline(r);a.originalFeature=e,(t.onClick||!1!==t.selectable)&&a.addListener("click",(i=>(console.log(`Line click received for feature: ${e.id}`),i.stop&&i.stop(),i.domEvent&&i.domEvent.stopPropagation&&i.domEvent.stopPropagation(),i.originalEvent&&i.originalEvent.stopPropagation&&i.originalEvent.stopPropagation(),i.domEvent&&i.domEvent.stopImmediatePropagation&&i.domEvent.stopImmediatePropagation(),i.domEvent&&i.domEvent.preventDefault&&i.domEvent.preventDefault(),t.onClick&&t.onClick({feature:e,renderedFeature:a,originalEvent:i}),!1!==t.selectable&&this._handleFeatureClick(e,a,i),!1)));const s={id:e.id,type:"line",originalFeature:e,renderedObject:a,options:t};return this.renderedFeatures.set(e.id,s),s}catch(e){throw console.error("Error rendering line feature:",e),e}}async renderPolygon(e,t={}){try{let i=[];if(e.getRings&&"function"==typeof e.getRings){const t=e.getRings();t&&t.length>0&&(i=t.map((e=>e.map((e=>({lat:e.lat,lng:e.lng}))))))}else e.coordinates&&Array.isArray(e.coordinates)&&(i=[e.coordinates.map((e=>({lat:e.lat,lng:e.lng})))]);if(0===i.length||i[0].length<3){if(!e.properties?.temporary&&!e.properties?.isPreview)throw new Error("Invalid permanent polygon feature: insufficient coordinates (need at least 3)");{console.log(`Creating initial placeholder polygon with ${i.length>0?i[0].length:0} points`);const e=this.googleMap.getCenter(),t=e.lat(),o=e.lng();i=[[{lat:t,lng:o},{lat:t,lng:o+1e-7},{lat:t+1e-7,lng:o}]]}}const o=e.style||t.style||this.options.defaultPolygonStyle||{},n={paths:i,map:this.googleMap,strokeColor:o.outlineColor||o.strokeColor||"#3388FF",strokeOpacity:o.outlineOpacity||o.strokeOpacity||.8,strokeWeight:o.outlineWidth||o.strokeWeight||2,fillColor:o.fillColor||"#3388FF",fillOpacity:o.fillOpacity||.35,clickable:!0,zIndex:100},r=new google.maps.Polygon(n);r.originalFeature=e,(t.onClick||!1!==t.selectable)&&r.addListener("click",(i=>(console.log(`Polygon click received for feature: ${e.id}`),i.stop&&i.stop(),i.domEvent&&i.domEvent.stopPropagation&&i.domEvent.stopPropagation(),i.originalEvent&&i.originalEvent.stopPropagation&&i.originalEvent.stopPropagation(),i.domEvent&&i.domEvent.stopImmediatePropagation&&i.domEvent.stopImmediatePropagation(),i.domEvent&&i.domEvent.preventDefault&&i.domEvent.preventDefault(),t.onClick&&t.onClick({feature:e,renderedFeature:r,originalEvent:i}),!1!==t.selectable&&this._handleFeatureClick(e,r,i),!1)));const a={id:e.id,type:"polygon",originalFeature:e,renderedObject:r,options:t};return this.renderedFeatures.set(e.id,a),a}catch(e){throw console.error("Error rendering polygon feature:",e),e}}async renderFeatureByType(e,t,i={}){switch(t){case"point":return this.renderPoint(e,i);case"line":return this.renderLine(e,i);case"polygon":return this.renderPolygon(e,i);default:throw new Error(`Unsupported feature type: ${t}`)}}async removeFeature(e){try{const t=e.renderedObject;if(!t)return;t instanceof google.maps.marker.AdvancedMarkerElement?t.map=null:(t instanceof google.maps.Polyline||t instanceof google.maps.Polygon)&&t.setMap(null),this.renderedFeatures.delete(e.id)}catch(e){throw console.error("Error removing feature:",e),e}}async updateFeature(e,t,i={}){try{await this.removeFeature(e);return await this.renderFeatureByType(t,e.type,i||e.options)}catch(e){throw console.error("Error updating feature:",e),e}}async highlightFeature(e,t={}){try{const i=e.renderedObject;if(!i)return;switch(i.originalStyles||this._storeOriginalStyles(i,e.type),e.type){case"point":this._highlightMarker(i,t);break;case"line":this._highlightPolyline(i,t);break;case"polygon":this._highlightPolygon(i,t)}}catch(e){throw console.error("Error highlighting feature:",e),e}}async unhighlightFeature(e){try{const t=e.renderedObject;if(!t||!t.originalStyles)return;switch(e.type){case"point":this._unhighlightMarker(t);break;case"line":this._unhighlightPolyline(t);break;case"polygon":this._unhighlightPolygon(t)}}catch(e){throw console.error("Error unhighlighting feature:",e),e}}_storeOriginalStyles(e,t){switch(e.originalStyles={},t){case"point":if(e instanceof google.maps.marker.AdvancedMarkerElement&&e.content){const t=e.content;e.originalStyles.transform=t.style.transform,e.originalStyles.boxShadow=t.style.boxShadow,e.originalStyles.zIndex=t.style.zIndex}break;case"line":e.originalStyles.strokeColor=e.get("strokeColor"),e.originalStyles.strokeWeight=e.get("strokeWeight"),e.originalStyles.strokeOpacity=e.get("strokeOpacity"),e.originalStyles.zIndex=e.get("zIndex");break;case"polygon":e.originalStyles.strokeColor=e.get("strokeColor"),e.originalStyles.strokeWeight=e.get("strokeWeight"),e.originalStyles.strokeOpacity=e.get("strokeOpacity"),e.originalStyles.fillColor=e.get("fillColor"),e.originalStyles.fillOpacity=e.get("fillOpacity"),e.originalStyles.zIndex=e.get("zIndex")}}_highlightMarker(e,t={}){const i=t.color||"#1a73e8";try{if(e.content){const t=e.content;t._originalStyles||(t._originalStyles={transform:t.style.transform||"",transition:t.style.transition||"",boxShadow:t.style.boxShadow||"",zIndex:t.style.zIndex||""}),t.style.transform="scale(1.2)",t.style.transition="transform 0.2s ease-in-out",t.style.boxShadow=`0 0 0 2px ${i}, 0 2px 4px rgba(0,0,0,0.3)`,t.style.zIndex="1000"}}catch(e){console.error("Error highlighting marker:",e)}}_unhighlightMarker(e){try{if(e.content&&e.content._originalStyles){const t=e.content,i=t._originalStyles;t.style.transform=i.transform||"",t.style.transition=i.transition||"",t.style.boxShadow=i.boxShadow||"",t.style.zIndex=i.zIndex||""}}catch(e){console.error("Error unhighlighting marker:",e)}}_highlightPolyline(e,t={}){const i=t.color||"#1a73e8";e.setOptions({strokeColor:i,strokeWeight:e.originalStyles.strokeWeight+2,strokeOpacity:1,zIndex:1e3})}_unhighlightPolyline(e){e.originalStyles&&e.setOptions({strokeColor:e.originalStyles.strokeColor,strokeWeight:e.originalStyles.strokeWeight,strokeOpacity:e.originalStyles.strokeOpacity,zIndex:e.originalStyles.zIndex})}_highlightPolygon(e,t={}){const i=t.color||"#1a73e8";e.setOptions({strokeColor:i,strokeWeight:e.originalStyles.strokeWeight+2,strokeOpacity:1,fillOpacity:1.2*e.originalStyles.fillOpacity,zIndex:1e3})}_unhighlightPolygon(e){e.originalStyles&&e.setOptions({strokeColor:e.originalStyles.strokeColor,strokeWeight:e.originalStyles.strokeWeight,strokeOpacity:e.originalStyles.strokeOpacity,fillColor:e.originalStyles.fillColor,fillOpacity:e.originalStyles.fillOpacity,zIndex:e.originalStyles.zIndex})}_handleFeatureClick(e,t,i){this.options.onFeatureClick&&this.options.onFeatureClick({feature:e,renderedFeature:{id:e.id,type:this._getFeatureType(t),originalFeature:e,renderedObject:t},originalEvent:i})}_getFeatureType(e){return e instanceof google.maps.marker.AdvancedMarkerElement?"point":e instanceof google.maps.Polyline?"line":e instanceof google.maps.Polygon?"polygon":"unknown"}_createMarkerIcon(e,t){let i=e.color;if("gnss"===t.properties?.source&&void 0!==t.properties?.quality&&(i=this._getQualityColor(t.properties.quality)||i),i=i||"#FF5733",e.useDualMarker||e.showPinAndDot){const t=e.size||32,o=document.createElement("div");o.style.position="relative",o.style.width="0",o.style.height="0";const n=document.createElementNS("http://www.w3.org/2000/svg","svg");n.setAttribute("width",`${t}px`),n.setAttribute("height",1.6*t+"px"),n.setAttribute("viewBox","0 0 32 52"),n.style.position="absolute",n.style.left=-t/2+"px",n.style.top=1.6*-t+"px";const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("d","M16 0C7.2 0 0 7.2 0 16c0 9.6 16 36 16 36s16-26.4 16-36c0-8.8-7.2-16-16-16z"),r.setAttribute("fill",i),r.setAttribute("stroke",e.outlineColor||"white"),r.setAttribute("stroke-width",e.outlineWidth||2),n.appendChild(r);const a=document.createElement("div");return a.style.position="absolute",a.style.width="6px",a.style.height="6px",a.style.left="-3px",a.style.top="-3px",a.style.backgroundColor="black",a.style.border="1px solid white",a.style.borderRadius="50%",a.style.zIndex="10",o.appendChild(n),o.appendChild(a),console.log("Created SVG pin marker with absolute positioning from center"),{content:o}}if(e.iconUrl){const t=e.iconSize?.[0]||32,i=e.iconSize?.[1]||32,o=document.createElement("div");o.style.position="relative",o.style.width="0",o.style.height="0";const n=document.createElement("img");return n.src=e.iconUrl,n.style.position="absolute",n.style.width=`${t}px`,n.style.height=`${i}px`,n.style.left=-t/2+"px",n.style.top=-i+"px",o.appendChild(n),console.log("Created image marker with absolute positioning from center"),{content:o}}{const t=e.size||10,o=document.createElement("div");if(o.style.width=2*t+"px",o.style.height=2*t+"px",o.style.borderRadius="50%",o.style.backgroundColor=i,o.style.border=`${e.outlineWidth||2}px solid ${e.outlineColor||"white"}`,o.style.boxSizing="border-box",o.style.position="relative",o.style.margin=`${-t}px 0 0 ${-t}px`,e.showCrosshair){const e=document.createElement("div");e.style.position="absolute",e.style.width="80%",e.style.height="1px",e.style.backgroundColor="black",e.style.left="10%",e.style.top="50%";const t=document.createElement("div");t.style.position="absolute",t.style.width="1px",t.style.height="80%",t.style.backgroundColor="black",t.style.left="50%",t.style.top="10%",o.appendChild(e),o.appendChild(t)}return console.log("Created circle marker centered on coordinate"),{content:o}}}_isAdvancedMarkerAvailable(){return window.google&&window.google.maps&&window.google.maps.marker&&window.google.maps.marker.AdvancedMarkerElement}_getQualityColor(e){return{0:"#888888",1:"#FF0000",2:"#FF9900",4:"#00FF00",5:"#00FFFF"}[e]||"#888888"}}class G{constructor(e,t,i={}){this.map=e,this.renderingStrategy=t,this.options=i,this.layers=new Map,this.selectedFeatures=new Map,i.defaultLayer&&this.createLayer(i.defaultLayer)}_setupFeatureEventListeners(e,t){e&&e.on&&"function"==typeof e.on?(e.on("selected",(()=>{console.log(`Feature ${e.id} selected event received`),this.selectedFeatures.set(e.id,t),this.renderingStrategy.highlightFeature(t).catch((t=>{console.error(`Error highlighting feature ${e.id}:`,t)}))})),e.on("deselected",(()=>{console.log(`Feature ${e.id} deselected event received`),this.selectedFeatures.delete(e.id),this.renderingStrategy.unhighlightFeature(t).catch((t=>{console.error(`Error unhighlighting feature ${e.id}:`,t)}))}))):console.warn("Cannot set up event listeners: feature has no event emitter")}createLayer(e,t={}){if(this.layers.has(e))throw new Error(`Layer with ID '${e}' already exists`);const i={id:e,options:t,features:new Map,visible:!1!==t.visible,selectable:!1!==t.selectable,editable:!1!==t.editable};return this.layers.set(e,i),i}async removeLayer(e){if(!this.layers.has(e))return Promise.resolve();const t=this.layers.get(e),i=[];for(const e of t.features.values())i.push(this.renderingStrategy.removeFeature(e));return await Promise.all(i),this.layers.delete(e),Promise.resolve()}async setLayerVisibility(e,t){if(!this.layers.has(e))throw new Error(`Layer with ID '${e}' does not exist`);const i=this.layers.get(e);if(i.visible===t)return Promise.resolve();i.visible=t;const o=[];for(const e of i.features.values())t?o.push(this.renderingStrategy.renderFeatureByType(e.originalFeature,e.type)):o.push(this.renderingStrategy.removeFeature(e));return await Promise.all(o),Promise.resolve()}async addFeature(e,t,i,o={}){if(!this.layers.has(e))throw new Error(`Layer with ID '${e}' does not exist`);const n=this.layers.get(e);let r=null;if(n.visible)switch(i){case"point":r=await this.renderingStrategy.renderPoint(t,o);break;case"line":r=await this.renderingStrategy.renderLine(t,o);break;case"polygon":r=await this.renderingStrategy.renderPolygon(t,o);break;default:throw new Error(`Unsupported feature type: ${i}`)}else{r={id:t.id||`feature_${Date.now()}_${Math.floor(1e4*Math.random())}`,originalFeature:t,renderedObject:null,type:i,highlighted:!1}}return n.features.set(r.id,r),this._setupFeatureEventListeners(t,r),t.selected&&(console.log(`Feature ${t.id} added while already selected, applying highlight`),this.selectedFeatures.set(t.id,r),r.renderedObject&&this.renderingStrategy.highlightFeature(r).catch((e=>{console.error(`Error highlighting feature ${t.id}:`,e)}))),r}async removeFeature(e,t){if(!this.layers.has(e))throw new Error(`Layer with ID '${e}' does not exist`);const i=this.layers.get(e);if(!i.features.has(t))return Promise.resolve();const o=i.features.get(t),n=o.originalFeature;if(this.selectedFeatures.has(t)&&(console.log(`Removing selected feature ${t} from selection tracking`),this.selectedFeatures.delete(t)),n&&"function"==typeof n.off&&(console.log(`Removing event listeners from feature ${t}`),n.off("selected"),n.off("deselected")),o.renderedObject){if(o.renderedObject.originalStyles)try{await this.renderingStrategy.unhighlightFeature(o)}catch(e){console.error(`Error unhighlighting feature before removal: ${e.message}`)}await this.renderingStrategy.removeFeature(o)}return i.features.delete(t),Promise.resolve()}async updateFeature(e,t,i,o={}){if(!this.layers.has(e))throw new Error(`Layer with ID '${e}' does not exist`);const n=this.layers.get(e);if(!n.features.has(t))throw new Error(`Feature with ID '${t}' does not exist in layer '${e}'`);const r=n.features.get(t);let a;return a=n.visible&&r.renderedObject?await this.renderingStrategy.updateFeature(r,i,o):{...r,originalFeature:i},n.features.set(t,a),a}getLayers(){return Array.from(this.layers.values())}getLayer(e){return this.layers.get(e)||null}getLayerFeatures(e){if(!this.layers.has(e))throw new Error(`Layer with ID '${e}' does not exist`);const t=this.layers.get(e);return Array.from(t.features.values())}getFeature(e,t){if(!this.layers.has(e))return null;return this.layers.get(e).features.get(t)||null}async fitLayerToView(e,t={}){if(!this.layers.has(e))throw new Error(`Layer with ID '${e}' does not exist`);const i=this.layers.get(e);if(0===i.features.size)return Promise.resolve();const o=[];for(const e of i.features.values()){const t=this._getFeatureCoordinates(e);o.push(...t)}return 0===o.length||await this.map.fitBounds(o,t),Promise.resolve()}_getFeatureCoordinates(e){if(!e.originalFeature)return[];switch(e.type){case"point":return[e.originalFeature.coordinate];case"line":case"polygon":return e.originalFeature.coordinates||[];default:return[]}}}function W(e,t={}){return MapFactory.createMap(e,t)}function B(){return MapFactory.getSupportedProviders()}class U extends t{constructor(e={}){super(),this.map=e.map,this.geometryEngine=e.geometryEngine,this.options={mode:"point",enable3D:!0,continuousDrawing:!0,pointSymbol:{color:"#4285F4",size:8},lineSymbol:{color:"#4285F4",width:3},polygonSymbol:{fillColor:"rgba(66, 133, 244, 0.3)",outlineColor:"#4285F4",outlineWidth:2},...e},this.isActive=!1,this.listeners=[],this.currentFeature=null,this.vertices=[],this.markers=[],this.polyline=null,this.polygon=null}activate(e={}){this.isActive&&this._reset(),Object.assign(this.options,e),this.isActive=!0,this._addMapListeners(),console.log(`SimplifiedDrawingTool activated in ${this.options.mode} mode`),this.emit("activated",{mode:this.options.mode})}_addMapListeners(){this._removeMapListeners();const e=google.maps.event.addListener(this.map,"click",this._handleMapClick.bind(this));if(this.listeners.push(e),"line"===this.options.mode||"polygon"===this.options.mode){const e=google.maps.event.addListener(this.map,"mousemove",this._handleMapMouseMove.bind(this));this.listeners.push(e)}}_removeMapListeners(){this.listeners.forEach((e=>{google.maps.event.removeListener(e)})),this.listeners=[]}_handleMapClick(e){const t=e.latLng.lat(),i=e.latLng.lng();switch(console.log(`Map clicked at ${t}, ${i} in ${this.options.mode} mode`),this.options.mode){case"point":this._createPoint(t,i);break;case"line":this._addLineVertex(t,i);break;case"polygon":this._addPolygonVertex(t,i)}}_handleMapMouseMove(e){if(!this.isActive||0===this.vertices.length)return;const t=e.latLng.lat(),i=e.latLng.lng();"line"===this.options.mode?this._updateLinePreview(t,i):"polygon"===this.options.mode&&this._updatePolygonPreview(t,i)}_createPoint(e,t){const i=new google.maps.Marker({position:{lat:e,lng:t},map:this.map,title:`Point (${e.toFixed(6)}, ${t.toFixed(6)})`,animation:google.maps.Animation.DROP});this.markers.push(i);const o=new l(e,t,0);this.emit("featureCreated",{type:"point",coordinate:o,marker:i}),this.options.continuousDrawing||this.deactivate()}_addLineVertex(e,t){this.vertices.push({lat:e,lng:t});const i=new google.maps.Marker({position:{lat:e,lng:t},map:this.map,title:`Vertex ${this.vertices.length}`,icon:{path:google.maps.SymbolPath.CIRCLE,fillColor:this.options.lineSymbol.color,fillOpacity:1,strokeWeight:2,strokeColor:"#FFFFFF",scale:6}});if(this.markers.push(i),1===this.vertices.length)this.polyline=new google.maps.Polyline({path:this.vertices,geodesic:!0,strokeColor:this.options.lineSymbol.color,strokeOpacity:1,strokeWeight:this.options.lineSymbol.width,map:this.map});else if(this.polyline.setPath(this.vertices),this.vertices.length>=2){const e=Date.now();if(this._lastClickTime&&e-this._lastClickTime<300)return void this._completeLine();this._lastClickTime=e}}_addPolygonVertex(e,t){this.vertices.push({lat:e,lng:t});const i=new google.maps.Marker({position:{lat:e,lng:t},map:this.map,title:`Vertex ${this.vertices.length}`,icon:{path:google.maps.SymbolPath.CIRCLE,fillColor:this.options.polygonSymbol.outlineColor,fillOpacity:1,strokeWeight:2,strokeColor:"#FFFFFF",scale:6}});if(this.markers.push(i),1===this.vertices.length)this.polyline=new google.maps.Polyline({path:this.vertices,geodesic:!0,strokeColor:this.options.polygonSymbol.outlineColor,strokeOpacity:1,strokeWeight:this.options.polygonSymbol.outlineWidth,map:this.map});else if(3===this.vertices.length){this.polyline&&(this.polyline.setMap(null),this.polyline=null),this.polygon=new google.maps.Polygon({paths:[...this.vertices,this.vertices[0]],strokeColor:this.options.polygonSymbol.outlineColor,strokeOpacity:1,strokeWeight:this.options.polygonSymbol.outlineWidth,fillColor:this.options.polygonSymbol.fillColor,fillOpacity:.35,map:this.map});const e=Date.now();if(this._lastClickTime&&e-this._lastClickTime<300)return void this._completePolygon();this._lastClickTime=e}else if(this.vertices.length>3){this.polygon.setPaths([...this.vertices,this.vertices[0]]);const e=Date.now();if(this._lastClickTime&&e-this._lastClickTime<300)return void this._completePolygon();this._lastClickTime=e}else this.polyline.setPath(this.vertices)}_updateLinePreview(e,t){if(0===this.vertices.length||!this.polyline)return;const i=[...this.vertices,{lat:e,lng:t}];this.polyline.setPath(i)}_updatePolygonPreview(e,t){if(0!==this.vertices.length)if(this.vertices.length<3){if(this.polyline){const i=[...this.vertices,{lat:e,lng:t}];this.polyline.setPath(i)}}else if(this.polygon){const i=[...this.vertices,{lat:e,lng:t},this.vertices[0]];this.polygon.setPaths(i)}}_completeLine(){if(this.vertices.length<2)return;const e=new google.maps.Polyline({path:this.vertices,geodesic:!0,strokeColor:this.options.lineSymbol.color,strokeOpacity:1,strokeWeight:this.options.lineSymbol.width,map:this.map}),t=this.vertices.map((e=>new l(e.lat,e.lng,0)));this.emit("featureCreated",{type:"line",coordinates:t,polyline:e}),this._reset(),this.options.continuousDrawing||this.deactivate()}_completePolygon(){if(this.vertices.length<3)return;const e=new google.maps.Polygon({paths:this.vertices,strokeColor:this.options.polygonSymbol.outlineColor,strokeOpacity:1,strokeWeight:this.options.polygonSymbol.outlineWidth,fillColor:this.options.polygonSymbol.fillColor,fillOpacity:.35,map:this.map}),t=this.vertices.map((e=>new l(e.lat,e.lng,0)));this.emit("featureCreated",{type:"polygon",coordinates:t,polygon:e}),this._reset(),this.options.continuousDrawing||this.deactivate()}_reset(){this.markers.forEach((e=>e.setMap(null))),this.markers=[],this.polyline&&(this.polyline.setMap(null),this.polyline=null),this.polygon&&(this.polygon.setMap(null),this.polygon=null),this.vertices=[],this._lastClickTime=null}deactivate(){this.isActive&&(this._removeMapListeners(),this._reset(),this.isActive=!1,this.emit("deactivated"))}}async function q(e={}){return await g(e.core),{version:J,core:{initialized:!0,Coordinate:l,GeometryEngine:d,GeoidModel:o,CoordinateUtils:c,TransformerFactory:a}}}const H={Manager:b,Core:{Coordinate:l,GeometryEngine:d,GeoidModel:o,CoordinateUtils:c,TransformerFactory:a,CoordinateTransformer:i,SimpleWGS84Transformer:r,EventEmitter:t},Features:{FeatureBase:u,PointFeature:p,LineFeature:f,PolygonFeature:w,FeatureCollection:v,createPoint:P,createLine:S,createPolygon:E,createFeatureCollection:C,importFromGeoJSON:x},Map:{MapInterface:A,Map3DInterface:T,ElevationService:$,GoogleMapsAdapter:O,LeafletAdapter:z,GoogleMapsElevationService:V,MapFactory:R,LayerManager:G,RenderingStrategy:j,GoogleMapsRenderingStrategy:N,createMap:W,getSupportedProviders:B},Tools:{DrawingTool:M,MeasurementTool:k,EditingTool:F,OffsetTool:D,SnappingManager:_,ToolBase:y,SimplifiedDrawingTool:U}},J="1.0.0",K=(new Date).toISOString();e.BUILD_DATE=K,e.Coordinate=l,e.CoordinateTransformer=i,e.CoordinateUtils=c,e.DrawingTool=M,e.EditingTool=F,e.ElevationService=$,e.EventEmitter=t,e.FeatureBase=u,e.FeatureCollection=v,e.GeoidModel=o,e.GeometryEngine=d,e.GoogleMapsAdapter=O,e.GoogleMapsElevationService=V,e.GoogleMapsRenderingStrategy=N,e.LayerManager=G,e.LeafletAdapter=z,e.LineFeature=f,e.Map3DInterface=T,e.MapFactory=R,e.MapInterface=A,e.MeasurementTool=k,e.OffsetTool=D,e.PointFeature=p,e.PolygonFeature=w,e.RenderingStrategy=j,e.SimpleWGS84Transformer=r,e.SimplifiedDrawingTool=U,e.SnappingManager=_,e.Survey=H,e.SurveyManager=b,e.ToolBase=y,e.TransformerFactory=a,e.VERSION=J,e.createFeatureCollection=C,e.createLine=S,e.createMap=W,e.createPoint=P,e.createPolygon=E,e.createSurvey=async function(e,t,i={}){await q(i);const o=R.createMap(t,{mapInstance:e,...i.mapOptions}),n=new b({mapInterface:o,settings:{enable3D:void 0===i.enable3D||i.enable3D,continuousDrawing:void 0===i.continuousDrawing||i.continuousDrawing,autoSave:i.autoSave||!1,undoLevels:i.undoLevels||20,elevationProvider:i.elevationProvider||"mapInterface",...i.settings}});if(!1!==i.initializeLayers){const e="google"===t?new N(o):new j(o);n.layerManager=new G(o,e,{defaultLayer:"main"}),n.layerManager.createLayer("points",{name:"Points",visible:!0}),n.layerManager.createLayer("lines",{name:"Lines",visible:!0}),n.layerManager.createLayer("polygons",{name:"Polygons",visible:!0}),n.layerManager.createLayer("working",{name:"Working Features",visible:!0,zIndex:1e3})}return n},e.getSupportedProviders=B,e.importFromGeoJSON=x,e.initialize=q,e.initializeCore=g}));
//# sourceMappingURL=gis-survey.min.js.map
